(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{U8Dg:function(n,i,e){"use strict";e.d(i,"a",(function(){return t}));e("PF2M"),e("IZzc");var o={pickingSelectedColor:null,pickingHighlightColor:new Uint8Array([0,255,255,255]),pickingActive:!1,pickingAttribute:!1};var t={name:"picking",vs:"uniform bool picking_uActive;\nuniform bool picking_uAttribute;\nuniform vec3 picking_uSelectedColor;\nuniform bool picking_uSelectedColorValid;\n\nout vec4 picking_vRGBcolor_Avalid;\n\nconst float COLOR_SCALE = 1. / 255.;\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.001;\n}\n\nbool isVertexPicked(vec3 vertexColor) {\n  return\n    picking_uSelectedColorValid &&\n    !picking_isColorValid(abs(vertexColor - picking_uSelectedColor));\n}\n\nvoid picking_setPickingColor(vec3 pickingColor) {\n  if (picking_uActive) {\n    // Use alpha as the validity flag. If pickingColor is [0, 0, 0] fragment is non-pickable\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!picking_uAttribute) {\n      // Stores the picking color so that the fragment shader can render it during picking\n      picking_vRGBcolor_Avalid.rgb = pickingColor * COLOR_SCALE;\n    }\n  } else {\n    // Do the comparison with selected item color in vertex shader as it should mean fewer compares\n    picking_vRGBcolor_Avalid.a = float(isVertexPicked(pickingColor));\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\nvoid picking_setPickingAttribute(vec2 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\nvoid picking_setPickingAttribute(vec3 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n",fs:"uniform bool picking_uActive;\nuniform vec3 picking_uSelectedColor;\nuniform vec4 picking_uHighlightColor;\n\nin vec4 picking_vRGBcolor_Avalid;\n\n/*\n * Returns highlight color if this item is selected.\n */\nvec4 picking_filterHighlightColor(vec4 color) {\n  if (picking_uActive) {\n    return color;\n  }\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    float highLightAlpha = picking_uHighlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking_uHighlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\n\n/*\n * Returns picking color if picking enabled else unmodified argument.\n */\nvec4 picking_filterPickingColor(vec4 color) {\n  if (picking_uActive) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\n\n/*\n * Returns picking color if picking is enabled if not\n * highlight color if this item is selected, otherwise unmodified argument.\n */\nvec4 picking_filterColor(vec4 color) {\n  vec4 highightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highightColor);\n}\n\n",getUniforms:function(n){void 0===n&&(n=o);var i={};if(void 0!==n.pickingSelectedColor)if(n.pickingSelectedColor){var e=n.pickingSelectedColor.slice(0,3);i.picking_uSelectedColorValid=1,i.picking_uSelectedColor=e}else i.picking_uSelectedColorValid=0;if(n.pickingHighlightColor){var t=Array.from(n.pickingHighlightColor,(function(n){return n/255}));Number.isFinite(t[3])||(t[3]=1),i.picking_uHighlightColor=t}return void 0!==n.pickingActive&&(i.picking_uActive=Boolean(n.pickingActive),i.picking_uAttribute=Boolean(n.pickingAttribute)),i}}},aI42:function(n,i,e){"use strict";e.d(i,"a",(function(){return o})),e.d(i,"b",(function(){return t}));var o=function(){function n(){}n.getInfo=function(){return""};var i=n.prototype;return i.start=function(){},i.stop=function(){},i.delete=function(){},i.onFinalize=function(){},i.waitForRender=function(){return Promise.resolve()},i._setDisplay=function(){},i._getCanvas=function(n){var i;if(void 0===n&&(n={}),n.canvas){i=document.getElementById(n.canvas);var e=window.devicePixelRatio||1;i.height=i.clientHeight*e,i.width=i.clientWidth*e}else(i=document.createElement("canvas")).width=800,i.height=600,document.body.appendChild(i);return i},i._getContainer=function(n){if(void 0===n&&(n={}),this.container)return this.container;var i,e;if(this.container=document.createElement("div"),n.canvas){var o=document.getElementById(n.canvas);this.parent=o.parentElement,i=o.clientWidth,e=o.clientHeight,this.container.style.position="relative",this.container.style.top="-"+e+"px"}else this.parent=document.body,i=800,e=800;return this.container.style.width=i+"px",this.container.style.height=e+"px",this.parent.appendChild(this.container),this.container},i._removeContainer=function(n){void 0===n&&(n={}),this.parent.removeChild(this.container)},n}();function t(){var n=1,i=1;return function(){return n=Math.sin(17.23*i),i=Math.cos(27.92*n),(e=1432.71*Math.abs(n*i))-Math.floor(e);var e}}},tNJd:function(n,i,e){"use strict";e.r(i),e.d(i,"default",(function(){return w}));var o=e("dI71"),t=e("q1tI"),r=e.n(t),a=e("z0FI"),c=(e("PF2M"),e("IZzc"),e("3LCa")),l=e("mECX"),s=e("EpVc"),f=e("U8Dg"),u=e("UD/Y"),d=e("LG3w"),g=e("bjw9"),h=e("lHlH"),_=e("g/qQ"),v=e("aI42"),p=new Uint8Array([255,0,0,255]),A="THIS DEMO REQUIRES WEBGL 2, BUT YOUR BROWSER DOESN'T SUPPORT IT",m=Object(v.b)(),k=new _.a({id:"transform"}).enable(),C=[0,0];function b(n){C=[n.offsetX,n.offsetY]}function O(n){C=null}var L=function(n){function i(){return n.apply(this,arguments)||this}Object(o.a)(i,n),i.getInfo=function(){return'\n<p>\n  Instanced triangles animated on the GPU using a luma.gl <code>Transform</code> object.\n\n  This is a port of an example from\n  <a href="https://github.com/WebGLSamples/WebGL2Samples/blob/master/samples/transform_feedback_instanced.html">\n    WebGL2Samples\n  </a>\n'};var e=i.prototype;return e.onInitialize=function(n){n.canvas;var i=n.gl,e=n.width,o=n.height;if(this.demoNotSupported=!Object(h.h)(i),this.demoNotSupported)return k.error(A)(),{};i.canvas.addEventListener("mousemove",b),i.canvas.addEventListener("mouseleave",O);for(var t=new Float32Array([.015,0,-.01,.01,-.01,-.01]),r=new Float32Array(2e3),a=new Float32Array(1e3),s=new Float32Array(3e3),g=new Uint8ClampedArray(2e3),_=0;_<1e3;++_){r[2*_]=2*m()-1,r[2*_+1]=2*m()-1,a[_]=2*m()*Math.PI,m()>.5?(s[3*_+1]=1,s[3*_+2]=1):(s[3*_]=1,s[3*_+2]=1),g[2*_]=Math.floor(_/255),g[2*_+1]=_-255*g[2*_]}var v=new c.a(i,t),p=new c.a(i,s),C=new c.a(i,r),L=new c.a(i,a),w=new c.a(i,g);return{positionBuffer:v,rotationBuffer:L,colorBuffer:p,offsetBuffer:C,renderModel:new u.a(i,{id:"RenderModel",vs:"#version 300 es\n#define OFFSET_LOCATION 0\n#define ROTATION_LOCATION 1\n#define POSITION_LOCATION 2\n#define COLOR_LOCATION 3\nprecision highp float;\nprecision highp int;\nlayout(location = POSITION_LOCATION) in vec2 a_position;\nlayout(location = ROTATION_LOCATION) in float a_rotation;\nlayout(location = OFFSET_LOCATION) in vec2 a_offset;\nlayout(location = COLOR_LOCATION) in vec3 a_color;\nin vec2 instancePickingColors;\nout vec3 v_color;\nvoid main()\n{\n    v_color = a_color;\n\n    float cos_r = cos(a_rotation);\n    float sin_r = sin(a_rotation);\n    mat2 rot = mat2(\n        cos_r, sin_r,\n        -sin_r, cos_r\n    );\n    gl_Position = vec4(rot * a_position + a_offset, 0.0, 1.0);\n    picking_setPickingColor(vec3(0., instancePickingColors));\n}\n",fs:"#version 300 es\n#define ALPHA 0.9\nprecision highp float;\nprecision highp int;\nin vec3 v_color;\nout vec4 color;\nvoid main()\n{\n    color = vec4(v_color * ALPHA, ALPHA);\n    color = picking_filterColor(color);\n}\n",drawMode:i.TRIANGLE_FAN,vertexCount:3,isInstanced:!0,instanceCount:1e3,attributes:{a_position:v,a_color:[p,{divisor:1}],a_offset:[C,{divisor:1}],a_rotation:[L,{divisor:1}],instancePickingColors:[w,{divisor:1}]},modules:[f.a]}),transform:new d.a(i,{vs:"#version 300 es\n#define OFFSET_LOCATION 0\n#define ROTATION_LOCATION 1\n\n#define M_2PI 6.28318530718\n\n// We simulate the wandering of agents using transform feedback in this vertex shader\n// The simulation goes like this:\n// Assume there's a circle in front of the agent whose radius is WANDER_CIRCLE_R\n// the origin of which has a offset to the agent's pivot point, which is WANDER_CIRCLE_OFFSET\n// Each frame we pick a random point on this circle\n// And the agent moves MOVE_DELTA toward this target point\n// We also record the rotation facing this target point, so it will be the base rotation\n// for our next frame, which means the WANDER_CIRCLE_OFFSET vector will be on this direction\n// Thus we fake a smooth wandering behavior\n\n#define MAP_HALF_LENGTH 1.01\n#define WANDER_CIRCLE_R 0.01\n#define WANDER_CIRCLE_OFFSET 0.04\n#define MOVE_DELTA 0.001\nprecision highp float;\nprecision highp int;\nuniform float u_time;\nlayout(location = OFFSET_LOCATION) in vec2 a_offset;\nlayout(location = ROTATION_LOCATION) in float a_rotation;\nout vec2 v_offset;\nout float v_rotation;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    float theta = M_2PI * rand(vec2(u_time, a_rotation + a_offset.x + a_offset.y));\n    float cos_r = cos(a_rotation);\n    float sin_r = sin(a_rotation);\n    mat2 rot = mat2(\n        cos_r, sin_r,\n        -sin_r, cos_r\n    );\n\n    vec2 p = WANDER_CIRCLE_R * vec2(cos(theta), sin(theta)) + vec2(WANDER_CIRCLE_OFFSET, 0.0);\n    vec2 move = normalize(rot * p);\n    v_rotation = atan(move.y, move.x);\n    v_offset = a_offset + MOVE_DELTA * move;\n\n    // wrapping at edges\n    v_offset = vec2 (\n        v_offset.x > MAP_HALF_LENGTH ? - MAP_HALF_LENGTH :\n          ( v_offset.x < - MAP_HALF_LENGTH ? MAP_HALF_LENGTH : v_offset.x ) ,\n        v_offset.y > MAP_HALF_LENGTH ? - MAP_HALF_LENGTH :\n          ( v_offset.y < - MAP_HALF_LENGTH ? MAP_HALF_LENGTH : v_offset.y )\n        );\n\n    gl_Position = vec4(v_offset, 0.0, 1.0);\n}\n",elementCount:1e3,sourceBuffers:{a_offset:C,a_rotation:L},feedbackMap:{a_offset:"v_offset",a_rotation:"v_rotation"}}),pickingFramebuffer:new l.a(i,{width:e,height:o})}},e.onRender=function(n){var i=n.gl,e=n.width,o=n.height,t=n.renderModel,r=n.transform,a=n.time,c=n.pickingFramebuffer;if(!this.demoNotSupported){r.run({uniforms:{u_time:a}}),r.swap();var l=r.getBuffer("v_offset"),f=r.getBuffer("v_rotation");if(l.setAccessor({divisor:1}),f.setAccessor({divisor:1}),t.clear({color:[0,0,0,1],depth:!0}),t.draw({attributes:{a_offset:l,a_rotation:f},parameters:{blend:!0,blendFunc:[i.SRC_ALPHA,i.ONE]}}),l.setAccessor({divisor:0}),f.setAccessor({divisor:0}),C){var u=Object(h.d)(i,C),d=u.x+Math.floor(u.width/2),g=u.y+Math.floor(u.height/2);c.resize({width:e,height:o}),function(n,i,e,o,t){t.clear({color:!0,depth:!0}),o.setUniforms({picking_uActive:1}),o.draw({framebuffer:t}),o.setUniforms({picking_uActive:0});var r=Object(s.b)(t,{sourceX:i,sourceY:e,sourceWidth:1,sourceHeight:1,sourceFormat:n.RGBA,sourceType:n.UNSIGNED_BYTE});r[0]+r[1]+r[2]>0?o.updateModuleSettings({pickingSelectedColor:r,pickingHighlightColor:p}):o.updateModuleSettings({pickingSelectedColor:null})}(i,d,g,t,c)}}},e.onFinalize=function(n){var i=n.renderModel,e=n.transform;i&&i.delete(),e&&e.delete()},e.getAltText=function(){return A},i}(g.a);"undefined"==typeof window||window.website||(new L).start();var w=function(n){function i(){return n.apply(this,arguments)||this}return Object(o.a)(i,n),i.prototype.render=function(){return r.a.createElement(a.a,{AnimationLoop:L,exampleConfig:this.props.pageContext.exampleConfig})},i}(r.a.Component)}}]);