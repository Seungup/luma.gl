{"componentChunkName":"component---node-modules-gatsby-theme-ocular-src-react-templates-search-jsx","path":"/search","result":{"pageContext":{"data":[{"excerpt":"Overview luma.gl is a high-performance toolkit for WebGL-based data visualization. luma.gl is the core 3D rendering library in the  vis.gl  framework suite. Versions These docs are for luma.gl aims to provide tools for WebGL developers wether they wish to do high or low-level GPU programming. Polyfilling and shader composition utilities, for example, can be used while programming directly with the WebGL API, while resource management utilities provide higher-level 3D engine functionality. The core use case for luma.gl is visualization of large datasets, but its design is generic enough for more general usage. Key strengths of luma.gl include: A WebGL 2-first API  - luma.gl polyfills WebGL 1 contexts insofar as possible to support the WebGL 2 API. This allows applications to code using the latest WebGL 2 APIs while transparently keeping the application backwards compatible with WebGL 1 (using WebGL extensions, shader transpilation and other techniques). Modular, Composable Tools  - It is left to the develop to decide what parts of luma.gl suit their application. Program at a higher level using WebGL wrapper classes or a  Model , or simply polyfill the context and program using the WebGL 2 API. High-performance Data Visualization  - luma.gl focuses on simplifying access to APIs that are particularly useful when visualizing large data sets, such as instanced drawing and transform feedback. For some powerful examples of what can be achieved with luma.gl, take a look at  deck.gl ,  kepler.gl  and  avs.auto . Future We share information about the direction of luma.gl in the following ways: RFCs  - RFCs are technical writeups that describe proposed features in upcoming releases. Roadmap Document  - (this document) A high-level summary of our current direction for future releases. Blog  - We use the vis.gl blog to share information about what we are doing. Github Issues  - The traditional way to start or join a discussion.","headings":[{"value":"Overview","depth":1},{"value":"Versions","depth":2},{"value":"Future","depth":2}],"slug":"docs","title":"Overview"},{"excerpt":"Upgrade Guide Upgrading from v8.4 to v8.5 Transpilation The module entry point is now only lightly transpiled for the most commonly used evergreen browsers. This change offers significant savings on bundle size. If your application needs to support older browsers such as IE 11, make sure to include  node_modules  in your babel config. Upgrading from v7.3 to v8.0 The key goals of luma.gl v8.0 were to simplify the core architecture and significantly improve performance. The number of modules has been reduced from 14 to 9, and they are now structured around layers of abstraction (high-level to low-level) to clarify the relationship between them. Unfinished and rarely-used components have been removed, reducing the complexity of the API and leading to significant performance gains (see  What's New ) for details). Module Restructure The module structure has been significantly changed for v8.0 with the intention of clarifying the purpose of each module and the relationships between them. New Module Purpose Components from v7 constants WebGL enum values Same as before shadertools Tools for manipulating and composing shader text shadertools and effects (formerly glfx) gltools Creation, tooling and polyfilling for the WebGL context webgl2-polyfill and webgl-state-tracker webgl Wrapper classes for WebGL Same as before core Single module re-exporting key parts of engine, webgl, gltools, shadertools Changes described below engine High-level drawing APIs core/model, core/animation-loop, core/resource-management, addons/animation, core/geometry, core/transform debug Debug tooling for the other modules Same as before test-utils Test tooling for the other modules Same as before experimental Experimental, unsupported APIs core/scenegraph, gpgpu, addons/gltf, addons/webvr Breaking changes Texture2D 's  unpackFlipY  option is removed. This change ensures that all data sources (Image, ImageBitmap, typed array) are treated consistently. As a result, textures created from Image objects and URL strings are now y-flipped from the v7.3 default. To get the old behavior, specify the  pixelStore  option: createGLContext  will no longer attempt to create a headlessgl context under node.js. One can either create headless context externally and use  instrumentGLContext  to prepare it for use with luma.gl or use  createHeadlessContext  from  @luma.gl/test-utils  to create a headlessgl context. registerShaderModules  has been removed. Modules can be imported and used directly where necessary. createShaderHook  and  createModuleInjection  have been removed. Use  ProgramManager.getDefaultProgramManger(gl).addShaderHook  && the shader module  inject field  instead. ProgramManager.getDefaultProgramManger(gl).addModuleInjection  been removed. Use the shader module  inject field  instead. getParameter  and  setParameter  have been removed. Use  getParameters  and  setParameters  instead. The following are no longer exported by @luma.gl/core, but can still be imported from the modules indicated: Available in Query, VertexArrayObject, VertexArray, UniformBufferLayout, Shader, VertexShader, FragmentShader, clearBuffer, clearBuffer, copyToDataUrl, copyToImage, blit, setPathPrefix, loadFile, loadImage @luma.gl/webgl resizeGLContext @luma.gl/gltools combineInjects, lights, getQualifierDetails, getPassthroughFS, typeToChannelSuffix, typeToChannelCount, convertToVec4 @luma.gl/shadertools Smaller changes Functions are no longer accepted as uniform values to the  Model  class. The same effect can be achieved by updating the uniform values each frame prior to drawing. BaseModel  and  Model  have been consolidated in  Model .  Model  can be used as a substitute for  BaseModel  where necessary. AmbientLight ,  DirectionalLight ,  PointLight ,  PhongMaterial ,  PBRMaterial ,  CameraNode  have been removed from @luma.gl/core. These were either empty classes or simple data objects and so can be replaced by plain JavaScript objects in most cases. ShaderCache  has been removed and superseded by  ProgramManager . VertexArray.getDrawParams  no longer takes overrides as an argument. The calling function can manually override values as needed. @luma.gl/main has been removed. Use individual modules instead. Multipass  classes have been removed. Seer support has been removed. Timeline and Keyframes have been moved from @luma.gl/addons to @luma.gl/engine. Upgrading from v7.2 to v7.3 ProgramManager  has replaced  ShaderCache  in the  Model  class as a more robust resource manager. Use of the  ShaderCache  with  Model  will not affect functionality in any way, but it is now a no-op. Upgrading from v6.x to v7.0 luma.gl v7.0 represents a major overhaul of the API. The majority of changes are in areas that are only infrequently used by applications, and the intention is that most applications should only require very light porting. Core API Removals Loading Functions Removed Extensive loading functionality is now provided by a new companion framework  loaders.gl  and because of this, most of the limited legacy luma.gl loading functions have been removed. For the most common case (loading of images for use with textures), loading functions are no longer needed as the  data  prop in the  Texture2D  constructor now accepts url strings and  Promise  objects (this is the new Async Textures function). Removed Function Replacement loadTexture(url, parameters) new Texture(gl, {data: url, parameters}) loadFiles Multiple calls to  loadFile loadImages Multiple calls to  loadImage loadTextures As per  loadTexture loadProgram Manually load  fs  and  vs , call  new Program(gl, {vs, fs}) loadModel call  loadFile  and copy  parseModel  code from examples/lesson/16 parseModel call  loadFile  and copy  parseModel  code from examples/lesson/16 Attribute Class Removed This experimental class has been moved to deck.gl and is now an internal class. Attribute accessor API improvements in luma.gl v7 should cover any issue. WebGL API Removals Sampler Class Removed The  Sampler  class has been removed as its utility was limited and it added complexity to the library. It may be added back in the future if a clear use case arises. Texture2DArray Class Removed The  Texture2DArray  class has been removed as its utility was limited and the status of support was unclear due to limited testing. It may be added back in the future if a clear use case arises. FenceSync Class Removed The  FenceSync  class has been removed as its utility was limited. It may be added back in the future if a clear use case arises. If required, syncing can be done directly through the  WebGLFenceSync  object. Framebuffer and Texture: Copy and Blit methods Following member function of  Framebuffer  and  Texture  classes are no longer supported, instead use the corresponding new global methods: Removed method Replacement Framebuffer.readPixels readPixelsToArray Framebuffer.readPixelsToBuffer readPixelsToBuffer Frambuffer.copyToDataUrl copyToDataUrl Frambuffer.copyToImage copyToImage Frambuffer.copyToTexture copyToTexture Frambuffer.blit blit Texture.copyFramebuffer copyToTexture Parameters have also changed in some cases, see separate section. Module Structure Changes Debug functionality moved to separate npm module To reduce bundle size and increase separation of concerns, debug functionality is now more cleanly separated from the core library and needs to be imported from a separate npm module: To upgrade, install the new module And replace with Model Changes: Model  no longer extends  ScenegraphNode . This ensures that applications that do not need scenegraph support do not need to include scenegraph related code. Use the new  ModelNode  class to inject  Models  into scenegraphs. Deletions: Redraw flag handling has been removed:  Model.setNeedsRedraw()  and  Model.getNeedsRedraw() . Additions: A new  Model.isAnimated()  method is provided, indicating that redraws are required every frame. Geometry The  Geometry  class has been simplified and is now a conceptually \"immutable\" class that holds typed arrays and accessor metatadata describing attributes for a geometry. Removal Replacement Reason for Change Geometry.drawMode  no longer accepts  String  values Geometry.DRAW_MODE  enum API simplification Geometry.setNeedsRedraw() N/A Not needed for immutable geometry Geometry.getNeedsRedraw() N/A Not needed for immutable geometry Buffer Removed Method Replacement Reason for Change Buffer.updateAccessor(...) Buffer.setAccessor(new Accessor(buffer.accessor, ...) Decoupling accessors from  Buffer Framebuffer To maximize rendering performance, the default framebuffer is no longer preserved between frames. The most common use case for preserving the draw buffer is capturing canvas contents into an image via  toDataURL . This can now be done via  AnimationLoop.toDataURL  which returns a  Promise  that resolves to the canvas data URL: More generally, moving code that depends on canvas contents to the end of  onRender , after all draw operations, will ensure that canvas contents are available. Prior behaviour can re-enabled using the  glOptions  argument to the  createGLContext  or  AnimationLoop  constructors: Note that setting  preserveDrawingBuffers  may result in a performance drop on some platforms. Query Use  Query.getTimerMilliseconds  to retrieve timer results in milliseconds.  Query.getResult  now returns raw query results. To improve performance and simplify the library, support for tracking  Query  instances with promises has changed: The  Query  constructor no longer takes  onComplete  and  onError  callbacks, and  pollGLContext  has been removed. Instead  Query.createPoll  now provides a simple, optional promise-based API. Copy And Blit Parameter Unification Names of certain parameters to these methods have been unified in an effort to reduce confusion and use the same conventions across all functions implementing image read-back, copy or blit. This table lists parameter mapping between old and new function. Framebuffer.readPixels readPixelsToArray - source opts.x opts.sourceX opts.y opts.sourceY opts.width opts.sourceWidth opts.height opts.sourceHeight opts.format opts.sourceFormat opts.type opts.sourceType opts.attachment opts.sourceAttachment opts.pixelArray opts.target Framebuffer.readPixelsToBuffer readPixelsToBuffer - source opts.x opts.sourceX opts.y opts.sourceY opts.width opts.sourceWidth opts.height opts.sourceHeight opts.format opts.sourceFormat opts.type opts.sourceType opts.buffer opts.target opts.byteOffset opts.targetByteOffset Framebuffer.copyToDataUrl copyToDataUrl - source opts.attachment opts.sourceAttachment opts.maxheight opts.targetMaxHeight Framebuffer.copyToImage copyToImage - source opts.attachment opts.sourceAttachment opts.image opts.targetImage Framebuffer.copyToTexture copyToTexture - source opts.target target opts.texture target opts.x opts.sourceX opts.y opts.sourceY opts.xoffset opts.targetX opts.yoffset opts.targetY opts.zoffset opts.targetZ opts.width opts.width opts.height opts.height opts.internalFormat opts.targetInternalFormat opts.mipmapLevel opts.targetMipmapLevel Texture.copyFramebuffer copyToTexture opts.framebuffer source opts.target target opts.x opts.sourceX opts.y opts.sourceY opts.width opts.width opts.height opts.height opts.internalFormat opts.targetInternalFormat opts.level opts.targetMipmapLevel Framebuffer.blit blit opts.srcFramebuffer source - target opts.attachment opts.sourceAttachment opts.srcX0 opts.sourceX0 opts.srcX1 opts.sourceX1 opts.srcY0 opts.sourceY0 opts.srcY1 opts.sourceY1 opts.dstX0 opts.targetX0 opts.dstX1 opts.targetX1 opts.dstY0 opts.targetY0 opts.dstY1 opts.targetY1 opts.color opts.color opts.depth opts.depth opts.stencil opts.stencil opts.mask opts.mask opts.filter opts.filter Geometry Scenegraph Models Geometry scenegraph models have been deprecated. Simply create a  Model  or  ModelNode  and explicitly pass a  Geometry  instance as\nan argument, e.g.: Upgrading from v5.3 to v6.0 luma.gl v6.0 underwent a major API cleanup, resulting in a smaller, easier-to-learn API and smaller application bundles. While there are many smaller changes, the impact on most applications should be limited: Most removed functions were in practice rarely used by applications, and the impact on typical luma.gl applications should be limited. A number of API changes are related to moving attribute management from  Program  to  VertexArray , however for higher level applications that work with the  Model  class rather than  Program  directly, there should not be much impact. GL Constants Import Path The biggest change for many apps will probably be that the static  GL  symbol (that contains all WebGL 2 constants) must now be separately imported GL from 'luma.gl/constants'. Experimental Exports: New Naming Convention Experimental exports are now prefixed with underscore ( _ ). The  experimental  \"name space\" export has been removed. This change will enable tree-shaking bundlers to remove unused experimental exports, resulting in smaller final application bundles. Removed symbols Math functions were moved from luma.gl to the separate math.gl module in v4.1. As of v6.0, they are no longer forwarded by luma.gl and now need to be imported directly from math.gl: luma.gl v6.0 removes a number of previously deprecated symbols. luma.gl will now issue an error rather than a warning if the old usage is detecated. Constants Removed symbol Replacement Reason for change GL import GL from 'luma.gl/constants' Bundle size reduction (by making this import optional). glGet(name) glGet(gl, name) Bundle size reduction (Was deprecated in v5.3) glKey(value) glKey(gl, value) Bundle size reduction (Was deprecated in v5.3) glKeyType(value) glKeyType(gl, value) Bundle size reduction (Was deprecated in v5.3) Context Removed symbol Replacement Reason for change deleteGLContest destroyGLContext Naming audit (Was deprecated in v5.3) pollContext pollGLContext Naming audit (Was deprecated in v5.3) trackContextCreation N/A Rarely used, overly specialized Global Functions Removed symbol Replacement Reason for change readPixels Framebuffer.readPixels Naming audit (was deprecated in v3.0) FrameBufferObject FrameBuffer Naming audit (was deprecated in v3.0) AnimationLoop Removed symbol Replacement Reason for change AnimationLoop.setViewParams() AnimationLoop.setProps() Naming audit Program Removed symbol Replacement Reason for change varyingMap N/A ( configuration ) Program now auto discovers varyings. Program.setAttributes() VertexArray.setAttributes() Attribute management moved to  VertexArray Program.setBuffers() VertexArray.setAttributes() Attribute management moved to  VertexArray Program.setVertexArray() Program.draw({vertexArray}) No longer needed, just supply a  VertexArray  to  Program.draw() Program.unsetBuffers() N/A No longer needed, just supply a  VertexArray  to  Program.draw() Program.use() gl.useProgram(program.handle) Rarely needed by apps, can use raw WebGL API getUniformCount() getParameter(GL.ACTIVE_UNIFORMS) Rarely needed getUniformInfo() gl.getActiveUniform() Rarely needed by apps, can use raw WebGL API getUniformLocation() gl.getUniformLocation() Rarely needed by apps, can use raw WebGL API getUniformValue() gl.getUniform() Rarely needed by apps, can use raw WebGL API 'getVarying()' Rarely needed by apps, can use raw WebGL API 'getFragDataLocation()' Rarely needed by apps, can use raw WebGL API 'getAttachedShaders()' Rarely needed by apps, can use raw WebGL API 'getAttributeCount()' Rarely needed by apps, can use raw WebGL API 'getAttributeLocation()' Rarely needed by apps, can use raw WebGL API 'getAttributeInfo()' Rarely needed by apps, can use raw WebGL API TransformFeedback Removed symbol Replacement Reason for change TransformFeedback.pause() gl.pauseTransformFeedback Rarely needed by apps, can use raw WebGL API TransformFeedback.resume() gl.resumeTransformFeedback Rarely needed by apps, can use raw WebGL API VertexArray Removed symbol Replacement Reason for change VertexArray.setBuffers() VertexArray.setAttributes() API Audit, setAttributes handles more cases. VertexArray.setGeneric() VertexArray.setConstant() API Audit, prefer \"constant\" instead of \"generic\" VertexArray.filledLocations() N/A No longer needed. VertexArray.clearBindings() VertexArray.reset() API Audit VertexArray.setLocations() VertexArray.constructor({program}) Autodetected from  program  parameter VertexArray.setGenericValues() VertexArray.setConstant() API Audit, prefer \"constant\" instead of \"generic\" VertexArray.setDivisor() gl.vertexAttribDivisor() Rarely needed by apps, can use raw WebGL API VertexArray.enable() gl.enableVertexAttribArray() Rarely needed by apps, can use raw WebGL API VertexArray.disable() gl.disableVertexAttribArray() Rarely needed by apps, can use raw WebGL API Upgrading from v5.2 to v5.3 v5.3 deprecates a number of symbols. It is recommended that you replace their usage in your source code. Deprecated symbol Replacement Reason GL import GL from 'luma.gl/constants' Bundle size concerns deleteGLContest destroyGLContext API Audit: Naming alignment pollContext pollGLContext API Audit: Naming alignment Upgrading from v5.1 to v5.2 Running under Node.js Using with Node :  \"import luma.gl/headless\"  is no longer required for luma.gl to load headless gl and the usage has been deprecated. You can now simply remove any such import statements from your code. Using Debug Contexts Debugging : The Khronos group's  WebGLDeveloperTools  are automatically installed when luma.gl is installed, but are not actually bundled into the application unless explicitly imported. This avoids impacting the size of production bundles built on luma.gl that typically do not need debug support. To use debug support, first import the debug tools, then call  getDebugContext  to create a debug contexts from a normal WebGL context: Upgrading from v4 to v5 Please read this documentation before upgrading your luma.gl dependency from v4 to v5. In v5 a number of previously deprecated features have been removed and a number of additional deprecations have been made at the same time. Before upgrading to v5, it is highly recommended to run your application using latest v4 release, and check the console for any deprecated warnings, if there are any replace deprecated API with newer API as listed below. Model Class The  Model  constructor expects a gl context as the first argument. Following style construction was deprecated in v4 and is now removed in v5. useDevicePixelRatio useDevicePixelRatio  is used as a an argument in  AnimationLoop  class constructor and  pickModels  method. It is now deprecated in v5, but still supported with a warning message and will be removed in next major version update. It is recommended to use  useDevicePixels  instead. Geometry Geometry  class construction with inline attributes was deprecated in v4 and now removed in v5. All attributes should be grouped inside  attribute  object. Removed Features Following features were deprecated in v3 and v4 are now removed in v5. Global symbols: Removed symbol / Usage Replacement Comment withState withParameters State management glContextWithState withParameters State management withParameters({frameBuffer}) withParameters({framebuffer}) State management MONOLITHIC_SHADERS MODULAR_SHADERS default shaders isWebGLContext isWebGL WebGL context validation isWebGL2Context isWebGL2 WebGL 2 context validation Camera ,  PerspectiveCamera ,  OrthoCamera None Scene None Texture construction options: Removed symbol / Usage Replacement generateMipmaps mipmaps magFilter parameters[GL.TEXTURE_MAG_FILTER] minFilter parameters[GL.TEXTURE_MIN_FILTER] wrapS parameters[GL.TEXTURE_WRAP_S] wrapT parameters[GL.TEXTURE_WRAP_T] Upgrading from v3 to v4 luma.gl v4 is a major release with API changes. Please read this documentation before upgrading your luma.gl's dependency from v3 to v4.\nIn addition, a number of previously deprecated features have been removed and a number of additional deprecations have been made at the same time in this version. Removed Features Some previously deprecated classes and functions have been removed in luma.gl v4 and applications must be updated with the new classes and functions if they are still using these. Symbol Replacement Comment Vec3 Vector3 New math library Mat4 Matrix4 New math library Quat Quaternion New math library Deprecated Features Some classes and functions have been deprecated in luma.gl v4. They will continue to function in v4, but a warning in the console will be generated. These functions are expected to be removed in a future major versions of luma.gl. Symbol Replacement Comment withState withParameters New WebGL state management glContextWithState withParameters New WebGL state management API Change Model Class The  Model  constructor now expects a gl context as the first argument. the gl context used to be extracted from the supplied program or provided along side with other options, but in luma.gl v4, it is expected as a separate argument to the constructor. This change is because luma.gl v4 emphasizes sharing shaders rather than programs (often indirectly via shader caching / shader assembly), it is less common that a gl context is available. Upgrading from V2 to V3 V3 was a fairly minor release, a number of deprecations were made. Deprecations Symbol Replacement Comment Vec3 Vector3 New math library Mat4 Matrix4 New math library Quat Quaternion New math library","headings":[{"value":"Upgrade Guide","depth":1},{"value":"Upgrading from v8.4 to v8.5","depth":2},{"value":"Transpilation","depth":3},{"value":"Upgrading from v7.3 to v8.0","depth":2},{"value":"Module Restructure","depth":3},{"value":"Breaking changes","depth":3},{"value":"Smaller changes","depth":3},{"value":"Upgrading from v7.2 to v7.3","depth":2},{"value":"Upgrading from v6.x to v7.0","depth":2},{"value":"Core API Removals","depth":2},{"value":"Loading Functions Removed","depth":3},{"value":"Attribute Class Removed","depth":3},{"value":"WebGL API Removals","depth":2},{"value":"Sampler Class Removed","depth":3},{"value":"Texture2DArray Class Removed","depth":3},{"value":"FenceSync Class Removed","depth":3},{"value":"Framebuffer and Texture: Copy and Blit methods","depth":2},{"value":"Module Structure Changes","depth":2},{"value":"Debug functionality moved to separate npm module","depth":3},{"value":"Model","depth":3},{"value":"Geometry","depth":2},{"value":"Buffer","depth":2},{"value":"Framebuffer","depth":3},{"value":"Query","depth":3},{"value":"Copy And Blit Parameter Unification","depth":3},{"value":"Geometry Scenegraph Models","depth":3},{"value":"Upgrading from v5.3 to v6.0","depth":2},{"value":"GL Constants Import Path","depth":3},{"value":"Experimental Exports: New Naming Convention","depth":3},{"value":"Removed symbols","depth":3},{"value":"Constants","depth":3},{"value":"Context","depth":3},{"value":"Global Functions","depth":3},{"value":"AnimationLoop","depth":3},{"value":"Program","depth":3},{"value":"TransformFeedback","depth":3},{"value":"VertexArray","depth":3},{"value":"Upgrading from v5.2 to v5.3","depth":2},{"value":"Upgrading from v5.1 to v5.2","depth":2},{"value":"Running under Node.js","depth":3},{"value":"Using Debug Contexts","depth":3},{"value":"Upgrading from v4 to v5","depth":2},{"value":"Model Class","depth":3},{"value":"useDevicePixelRatio","depth":3},{"value":"Geometry","depth":3},{"value":"Removed Features","depth":3},{"value":"Upgrading from v3 to v4","depth":2},{"value":"Removed Features","depth":2},{"value":"Deprecated Features","depth":2},{"value":"API Change","depth":2},{"value":"Model Class","depth":3},{"value":"Upgrading from V2 to V3","depth":2},{"value":"Deprecations","depth":3}],"slug":"docs/upgrade-guide","title":"Upgrade Guide"},{"excerpt":"What's New Version 8.5 Date: Jul 15, 2021 @luma.gl/shadertools GLSL transpiler now handles  gl_FragColor  in fragment shader when transpliting from ES 1.00 to 3.00 New  magnify  effect @luma.gl/experimental Support for compressed textures in glTF. Now exports  GLTFMaterialParser Version 8.4 Date: Feb 1, 2021 TypeScript TypeScript definitions are available for all modules Texture Supports continuous update from  HTMLVideoElement . gltools createGLContext : adds optional callbacks  onContextLost ,  onContextRestored . Version 8.3 Date: Oct 12, 2020 TypeScript TypeScript definitions are available for @luma.gl/webgl classes (Buffer, Texture, etc.) glTF Support for PBR material.unlit Version 8.1 Date: March 2, 2020 GPU-accelerated point-in-polygon tests The experimental  GPUPointInPolygon  class performs GPU-accerated point-in-polygon tests, which showed a massive improvement in performance over a CPU implementation of the algorithm: Points CPU GPU Improvement 10k 411 6900 16x 1M 4 4200 1000x 10M 0.378 3120 8000x Numbers shown are iterations/second. Improved vertex array object support in WebGL 1 Handling of platforms that do not support vertex array objects has been significantly improved, providing a more stable experience in IE 11 and headless-gl. GLSL 3.0 to 1.0 transpilation assembleShaders  now optionally attempts to transpile shaders from GLSL 3.0 to 1.0, potentially simplifying shader management in systems where both WebGL 1 and 2 are used. Refer to  the documentation  for more information. Version 8.0 Date: December 16, 2019 Performance The key focus of luma.gl v8.0 was optimizing performance. Compared to v7.3, the latest release shows a  2x  improvement in render time on the luma.gl stress test (1 million textured cubes), as detailed below: 7.3 8.0 Improvement CPU Time 30ms 16ms 14ms (47%) GPU Time 26ms 21ms 5ms (19%) luma.gl's optimizations also contributed significantly to deck.gl's performance gains in v8.0, leading to a  3x  improvement over its prior release on the deck.gl stress test (rendering 100,000  ScatterplotLayer  instances): 7.3 8.0 Improvement CPU Time 76ms 26ms 50ms (66%) GPU Time 17ms 10ms 7ms (41%) Stress tests were run on a Macbook Pro 2018, OSX, 2.6 GHz Intel Core i7, Radeon Pro 560X 4 GB. Streamlined API luma.gl v8.0 also brings with it a major simplification of the API and streamlining of architecture. The number of modules as been reduced from 14 to 9, each with a clearly defined purpose and relationship to other modules: Low-level constants : WebGL 1 and 2 enums. gltools : Tools for polyfilling, intrumenting and tracking state for WebGL contexts. shadertools : Tools for creating and composing re-usable GLSL shader modules. Mid-level webgl : WebGL 1 and 2 wrapper classes. High-level engine : Higher-level 3D graphics abstractions and resource management. Utilities debug : Debug instrumentation for WebGL contexts and luma.gl classes. test-utils : Testing utilities. core : Selected re-exports from other modules. experimental : Unfinished and unsupported features. Version 7.3 Date: September 19, 2019 Program Management luma.gl introduces the  ProgramManager  class to manage caching and re-use of  Program  objects, providing powerful load and runtime optimizations: Redundant shader compilation and linking is avoided. Redundant program switching (among the  most expensive  GPU state changes) while rendering is avoided. The  Model  class has been updated to take advantage of these new capabilities, automatically caching and re-using  Program s where possible. The table below shows the effect of program sharing in deck.gl. The test renders 1000  ScatterplotLayers , each of which draws 100 intanced geometries, for a total of 1000 draw calls and 100,000 instances. Timings are milliseconds spent on the CPU and GPU to render a single frame on the following two machines: Macbook Pro 2018, OSX, 2.6 GHz Intel Core i7, Radeon Pro 560X 4 GB Razer Blade, Windows 10, Intel i7-8750H 6 Core, Intel UHD Graphics 630 No Program Sharing Program Sharing Improvement Macbook Pro CPU 113ms 93ms 17% Macbook Pro GPU 43ms 34ms 20% Razer Blade CPU 145ms 125ms 13% Razer Blade GPU 137ms 115ms 16% Custom Device Pixels (Experimental) luma.gl now provides experimental support for specifying the pixel ratio mapping between canvas size and the GL drawing buffer. luma.gl has always provided support for matching the native device pixel ratio on high-resolution screens, but custom ratios allow applications to, for example, use SSAA for improved fidelity or reduced drawing resolution to improve performance. Version 7.2 Date: July 9, 2019 FXAA Shader Module luma.gl now supports FXAA (Fast Approximate Antialiasing) as a post processing effect. This allows for antialiasing on offscreen framebuffers. ImageBitmap Textures The  Texture  class now supports  ImageBitmap  input data. Version 7.1 Date: June 4, 2019 Enhanced Shader Injection System luma.gl now supports a much more robust system for injecting code into shaders. In addition to the pre-defined shader hooks such as  vs:#main-start ,\nthe shader injection system now supports: Definition of arbitrary shader hook functions that can be called anywhere in a shader Injection of arbitrary code into shader hook functions to modify their behavior Automatic injection by shader modules into hook functions or pre-defined shader hooks The combination of these features allows the behavior of the same shader code to be modified depending on included shader modules or other\nrequirements of the application. See  assembleShaders  documentation for more details. Animation Support More robust animations are now supported via the  Timeline  and  KeyFrames  classes. The  Timeline  class supports easily managing a timeline with multiple channels elapsing at different rates, as well as orchestrating playing, pausing, and rewinding behavior between them. A timeline can be attached to an  AnimationLoop  and then queried for time values, which can be used in animations. See  Timeline  documentation for more details. The  KeyFrames  class allows arbitrary data to be associated with time points. The time value of the key frames can be set and the current key frames and interpolation factor can be queried and used in calculating animated values. See  KeyFrames  documentation for more details. Version 7.0 Date: April 19, 2019 glTF Support luma.gl can now load 3D models and scenegraphs in the popular  glTF™  asset format (with the help of the loaders.gl  GLTFLoader . All variants of glTF 2.0 are supported, including binary  .glb  files as well as JSON  .gltf  files with binary assets in base64 encoding or in separate files. The Draco Mesh compression extension is also supported. Physically-based Material Support : Ensures that PBR models display as intended. Scenegraph Improvements : The Scenegraph classes have been refactored to ensure support for glTF objects. Geometry glTF Support : The  Geometry  class and scene graph support has been overhauled to conform to glTF conventions, simplifying loading and manipulation of glTF formatted data. loaders.gl Integration loaders.gl  is a major new companion framework to luma.gl that provides a suite of 3D file format loaders (with an emphasizis on point cloud formats), including: Draco PLY PCD LAS/LAZ OBJ loaders.gl output can now be passed directly into luma.gl classes like  Geometry  and  Model  making it straightforward to use luma.gl with a wide variety of file formats. Asynchronous Textures Image data for  Texture  classes can now be supplied using URLs or  Promise s, making it unnecessary for applications to handle image loading themselves. Lighting A standardized set of light classes are now supported by multiple material models (Phong, Goraud and PBR) enabling various models to be mixed and properly lit in the same scene. Modularization Improvements luma.gl has been restructured to make it easier for applications to select and import only parts of the library that they use. @luma.gl/gpgpu   New  - A new experimental submodule with GPGPU Algorithms and Utilities has been added, containing a growing collection of GPU accelerated algorithms and utility methods. Performance Instrumentation Extensive metrics about frame CPU and GPU times, resource counts, and GPU memory usage are being collected. The data is exposed as a  probe.gl   Stats  object. The new probe.gl  StatsWidget  can be used to present data in applications. Interleaved Attributes To improve support for interleaved attributes and glTF model loading, accessor objecs and the  Accessor  class now support a  buffer  field. In addition, attribute setting functions now accept accessor objects with the  buffer  field set. This allows multiple accessor objects referencing the same buffer: Unified functions for Framebuffers and Textures (Read/Copy/Blit) A set of global methods that perform copying data to and from  Framebuffer  objects. All functions that read from or write to a  Framebuffer  object now also accept a  Texture  object (no need to create and configure a  Framebuffer  just to do a simple operation on a  Texture ). Experimental Features WebVR Support (experimental) Just replace your  AnimationLoop  with  VRAnimationLoop  from  @luma.gl/addons . Works with  Firefox Reality . Version 6.4 Date: January 29, 2018 PBR (Physically Based) Rendering and Material Physically-Based Rendering is now supported and the new  PBRMaterial  class can be used to set up parameters. Material can be selected per model. Copy and Blit methods Several member function of  Framebuffer  and  Texture  classes are now replaced by global methods that peform copying data to and from  Framebuffer  objects. All methods that read from or write to a  Framebuffer  object, can now also accept a  Texture  object. Version 6.3 Date: November 16, 2018 Uniform Caching Uniforms are now cached at  Program  object, which improves performance by eliminating uniform setter calls when uniform values are not changed. New submodules @luma.gl/debug  - an experimental module for debugging WebGL shaders on CPU @luma.gl/glfx  - shader modules for image processing Offscreen Rendering (Experimental) A new experimental class  AnimationLoopProxy  supports running an  AnimationLoop  on a worker thread using the  OffscreenCanvas  API made official in Chrome 70. For more detatils, see  API documentation  and  example app . Version 6.2 Date: September 12, 2018 ShaderModulePass (Experimental) Shader modules that expose \"standard\" filtering and sampling functions can be given extra metadata (the  passes  field) enabling easy construction of a  ShaderModulePass . Look for  ShaderPass  badges in the documentation of shader modules. Transform Texture support (Experimental) Transform  class was introduced in 6.0 provides easy API to perform WebGL's complicated  TransformFeedback . We are now extending this class to provide same easy API to read and write into textures. Running image filters, performing offline rendering and custom texture mip-map generation are some of the use-cases. Moreover, texture and buffer access can be combined, i.e. using single  Transform  instance buffers can be captured using  TransformFeedback  and data can be propagated beyond vertex shader to generate a texture. Version 6.1 Date: Target August 31, 2018 luma.gl 6.1 is a minor release that introduces a number of new experimental capabilities that are expected to be built out and become official over the next few releases. New Multipass Rendering System (Experimental) luma.gl now provides a composable multipass rendering framework, based on a  MultiPassRenderer  class that accepts a list of render passes. Post-Processing Effects (Experimental) A number of classic WebGL/OpenGL post processing effects have been ported to luma.gl and packaged as composable render passes. For maxiumum flexibility, many of the underlying shaders have also been exposed as shader modules, allowing filtering features to be used either directly in existing shaders or applied as a post-processing filter. New loaders.gl Submodule (Experimental) A selection of open source 3D loaders have been ported to a new submodule  loaders.gl . Initial focus is on point cloud loaders (PLY, LAZ, PCD), although a geospatial loader (KML) is also included. In addition it contains both read and write support for GLB (the glTF binary container format). Transform Class now supports Shader Modules The  Transform  class now accepts shader module parameters (such as  modules ,  dependencies  and  inject , see  assembleShaders ), enabling the use of shader modules in transform feedback operations. Documentation Search luma.gl is now using the  ocular  document generator to build its website, which among other things enables search. Version 6.0 Date: July 18, 2018 A major release that as always focuses on WebGL performance and code size optimizations, better support for shader/GLSL programming, improved documentation and API cleanup. WebGL Improvements Attribute Management Optimizations VertexArray  objects are now used for all attribute management in luma.gl, resulting in improved performance and a simpler, more consistent API. The  Program  and  Model  class APIs have been updated to use  VertexArray . Buffer Memory Optimizations The  Buffer  class no longer holds on to the complete JavaScript typed arrays used during initialization. This can lead to significant memory savings in apps that use multiple large GPU buffers initialized from typed arrays. Also for convenience a new method  getElementCount  is added that returns number elements based on its size and type. Transform Feedback Improvements A new method  Model.transform  makes it easier to run basic transform feedback operations, when the full power of the new  Transform  class (see below) is not needed. Transform class (WebGL 2) Transform  is now an officially supported luma.gl class. This new class provides an easy-to-use interface to Transform Feedback. This class hides complexity by internally creating and managing the supporing WebGL objects that are necessary to perform Transform Feedback operations. Shader Module System Improvements GLSL Transpilation The shader assembler now transforms shader code to the GLSL version specified by the top-level shader. GLSL 3.00 ES shader code is transparently transformed into GLSL 1.00 ES compatible code when needed, and vice versa. This allows application to write shader code in the modern GLSL version available (3.00 ES) and still run it under WebGL 1 - Shader \"transpilation\" will automatically convert shader module source code syntax to the target version (assuming that no WebGL 2 only features were used). Shader Code Injection A new shader injection system allows applications to inject additional code into existing shaders. In many cases, this can avoid the need to copy (or \"fork\") large and complicated existing shaders just to add a few lines of code. Shader injection can be used to \"inject\" new shader modules into an existing shader. Adding a shader module to the modules list automatically \"prepends\" the shader module functions to the beginning of your main shader code, but using a shader module still typically requires adding one or two lines of code each to the main functions in the vertex and fragment shaders. In many cases, the new shader injection feature allows this be done without copying the original shaders. Shader Modules now support GLSL 3.00 ES All shader modules are now written in GLSL 3.00 syntax, and leverage the new GLSL transpilation feature to be compatible with both GLSL 3.00 ES and GLSL 1.00 ES main shaders. Care is taken to avoid using GLSL 3.00 specific features whenever possible, and exceptions will be clearly documented. Documentation Developer's Guide luma.gl now has a more extensive Developer's Guide covering more areas of the API, including a new developer guide for shader programming, with sections about writing shaders and the shader module system. Content includes: Guidelines for writing shaders that work in both GLSL 3.00 ES and GLSL 1.00 ES A new GLSL language reference page describing both GLSL 3.00 ES and GLSL 1.00 ES (as well as what has changed between them) in a single place. API Cleanup Being a major release, in v6.0 we took the opportunity to clean up the luma.gl API. Removal of Deprecated/Unused Methods To keep reducing application bundle size, a number of methods have been removed from the luma.gl API. Methods that were deprecated in previous releases have now been removed, and in additional a number of rarely used methods have also been dropped (in most cases, the dropped functionality is still accessible using raw WebGL calls). Renamed Methods In a few cases, methods have been renamed after API Audits, usually to improve API consistency. The details are listed in the Upgrade Guide. In most cases, running your pre-v6 application on v6 should generate messages in the console when old method calls are encountered, and you should be able to quickly address any changes one-by-one by referring to the Upgrade Guide. Version 5.3 Date: June 1, 2018 A minor release with bug fixes and internal improvements. Version 5.2 Date: Apr 24, 2018 Transform class (WebGL 2, Experimental) The new experimental  Transform  class provides an easy-to-use interface to perform Transform Feedback operations. Framebuffer Class Pixel Readback to GPU Buffers  (WebGL 2) - A new method  Framebuffer.readPixelsToBuffer  is added to asynchronously read pixel data into a  Buffer  object. This allows applications to reduce the CPU-GPU sync time by postponing transfer of data or to completely avoid GPU-CPU sync by using the pixel data in the GPU  Buffer  object directly as data source for another GPU draw or transform feedback operation. Bundle Size Reduction The impact of importing luma.gl on production application bundle sizes has been reduced, in particular when using webpack 4 with appropriate configuration. A new article about  bundling and tree shaking  has been added to the Developer Guide, providing in-depth information and guidance on what numbers to expect. Running luma.gl in Node.js Running of luma.gl under Node.js is now easier than ever. luma.gl v5.2 automatically loads headless-gl if installed on the system, avoiding the need for the app to import special files or add other conditional logic. See  Using with Node  and the Upgrade Guide. Debug Mode Changes To further reduce production application bundle sizes, luma.gl no longer support WebGL debug contexts by default, as this requires including the Khronos  WebGLDeveloperTools  into the bundle. WebGL debug contexts are still available, but needs to be explicitly enabled. To understand how to use WebGL debug contexts in v5.2, please refer to the article on  Debugging  and the Upgrade Guide. Examples All examples have been updated to use webpack 4 Version 5.1 A smaller release with improvements to  TransformFeedback  support. Date: Feb 15, 2018 TransformFeedback Class Two improvements Performing Transform Feedback operations has gotten easier, mainly in the following two ways: TransformFeedback  instances can now be supplied directly to  Model.draw  and feedback will begin and end during that draw call. Thus it is no longer necessary to work directly with the  Program  class to use transform feedback. Program  now build a  varyingMap  on creation depending on  varyings  array and  drawMode . This  varyingMap  can be passed to  TransformFeedback.bindBuffers()  enabling buffers to be indexed by the name of the \"varying\" instead of using an index. For more details check  TransformFeedback  and  Model  documentation. Version 5.0 Date: Dec 22, 2017 A smaller release with several new examples and some under the hood changes to improve performance. Examples Additional examples have been ported to the luma.gl v5 API. Lesson 10 Lesson 11 Lesson 12 Lesson 13 Model Class Model.draw  now supports a  moduleSettings  parameters to update shader module settings. Model.render  now supports  attributes  and  samplers  arguments to be used for drawing. Framebuffer Binding Management In v4 we added WebGL state management which automatically tracks all WebGL state settings. In this release we extended this feature to support framebuffer bindings. When restoring context settings, the previous framebuffer binding will also be restored. WebGL 2 Improvements Improvements in particular to the  Buffer ,  TransformFeedback  and  Framebuffer  classes based on use in applications. Shader Modules fp64  - fp64 module works under more platforms/GPUs/drivers picking  shader module is moved from deck.gl to luma.gl and has been enhanced to also support object highlighting. Version 4.0 Release date: July 27th, 2017 A major release that brings full WebGL 2 support to luma.gl, as well as adding support for GL state management and a new shader module system. Full WebGL 2 Support luma.gl now exposes the complete WebGL 2 APIs: New classes expose all the new WebGL 2 objects ( Query ,  Texture3D , and  TransformFeedback ), together with a new  UniformBufferLayout  helper class to make uniform buffers easy to use. Other existing WebGL classes with new functionalites under WebGL 2 have been updated. Add new WebGL 2 texture formats and types support, including floating point textures, and multiple render targets. WebGL Capability Management luma.gl provides a single unified WebGL 2-style API across WebGL 2, WebGL 1 and WebGL extensions, and provides a simple mechanisms for querying what capabilities are available. This simplifies building apps that run on both WebGL 1 and WebGL 2, seamlessly allowing applications to leverage WebGL extensions when available. WebGL State Management In this version, a new WebGL state management is implemented to help address one of the weak spots of the stateful WebGL API: luma.gl can track certain WebGL context state changes so the app could easily set and reset WebGL states for certain operations. luma.gl also has a host-side WebGL state caching system that records certain WebGL states so that expansive queries into the GPU or underlying OpenGL driver won't be necessary. shadertools - A New Shader Module System The new, optional, shadertools module with the  assembleShaders  function system allows shader code to be broken into composable pieces. A new  ShaderCache  class is provided to ensure that identical shaders are only compiled once and no unnecessary examination and/or checks are done on already compiled WebGL shader and program objects, which significantly accelerates app start up under some occasions. Documentation Improvements Complete rewrite of luma.gl's documentation. New structure and contents for every classes provided, featured on a new website with links to other frameworks in Uber's visualization framework suite, such as deck.gl and react-map-gl. Code Size Improvements Significant reduction in the size of distributed luma.gl library Code Size - luma.gl is continuously being tuned for code size. Deprecated Code Removed - Removal of deprecated features to help reduce library size. Tree Shaking support - special care have been taken to avoid so called \"side effects\" that defeat dependency analysis during tree shaking). v3.0 Release Date: March 15, 2017 A smaller release mainly intended to align the luma.gl code base with the big deck.gl v4 release. Major News Examples Examples converted to ES6 to better showcase the luma.gl API. Debug Support Now uses  WEBGL_debug_shaders  extension when available to log translated shader source code. Performance queries, using  EXT_disjoint_timer_query  and  EXT_disjoint_timer_query_webgl2  to provide timings. New  AnimationFrame  class Wraps requestAnimationFrame on browser and Node.js Supports initialization promises (wait for HTML body (canvas) to load, wait for texture images to load, etc). Supplies common uniforms to the frame render function:  width ,  height ,  aspect ,  tick ,  time  etc. Smaller changes Fix glTypeToArray to use  Uint8ClampedArrays  by default Add CORS setting to allow loading image from a different domain New  gl-matrix  based math library Optional library: All math operations directly accept JavaScript arrays Math classes are subclasses of JavaScript arrays (i.e. not {x,y,z} objects)\nand can thus be used interchangeably with arrays. Relies on  gl-matrix  for computations. Adds optional error checking. Offers more control over details like printing precision etc. Library Size Reorganized to only export a minimal surface of functions/classes. Tree-shaking support (package.json module keyword and dist-es6 distribution) Significant reduction of module dependencies. Experimental APIs shader-modules ,  shader-tools ,  shaders  shader module system added to  /experimental probe  moved to  /experimental Deprecations/Deletions Old math lib deprecated. FBO  class deprecated (use  Framebuffer  directly). Camera  class deprecated, use math library directly. Scene  class deprecated, for effects use - TBD Internal improvements Replace wildcard exports with named exports in index.js ES6 Conformant code base: stage-2 extensions removed Webpack based build Multiple examples now work standalone Experimental tree-shaking support: dist and dist-es6 directories Dependency removal, including removal of  autobind-decorator  dependency Changed precommit hook from  husky  to  pre-commit webgl  folder now contains both webgl1 and webgl2 classes Breaking Changes BREAKING CHANGE: Move node IO (loadImage etc) out of main src tree and into  packages . This allows luma.gl to drop a number of big dependencies. The node IO code may be published as a separate module later. v2.0 Release Date: July 05, 2016 (evolved through a number of minor releases) Theme: A bigger official release, a major API refactoring that introduced the WebGL classes that are now a characteristic aspect of the luma.gl API. Major Features CHANGE: Removes glslify as a dependency, apps that depend on glslify must add it to their own package.json. TimerQuery Support EXT_disjoint_timer_query. Debug Support Built-in attribute/uniform logging GLSL shader compiler error handling Linux support Add missing call to getAttribLocation. New gl-matrix based math classes Move old math lib to deprecated folder. Move FBO to deprecated folder. Examples converted to ES6. AnimationFrame class updates. Add back persistence example WebGL type and constant cleanup Fix glTypeToArray and use clamped arrays by default TimerQuery, WebGL Extension doc, fix crash on Travis CI Support EXT_disjoint_timer_query Document luma.gl use of WebGL extensions. Fix: context creation crash when WEBGL_debug_info extension was undefined Debug log improvements, import fix Debug logs now print unused attributes more compactly, number formatting improved. Add ability to import luma without io import \"luma.gl/luma\" will import luma without io functions import \"luma.gl/io\" will import luma io functions only omitting io functions significantly reduces dependencies Makes the luma object available in console for debugging. Some polish on luma's built-in attribute/uniform logging Node.js/AttributeManager/Renderer/Program.render()/Examples Ensure luma.gl does not fail under node until createGLContext is called. Program.render() now takes a map of uniforms, reducing need to \"set\" uniforms before render. New experimental Renderer class -  requestAnimationFrame  replacement. Improvement/fixes to examples Node.js support Ensure luma.gl does not fail under node until createGLContext is called. luma global initialization Makes the luma object available in console for debugging. Makes optional headless support more reliable. Headless support Removed  gl  (headless-gl) dependency, to simplify build and setup for applications that don't use headless-gl. import 'luma.gl/headless'  and  npm install gl  to get headless integration. Improve change detection Redraw flag management improvements Decoupled headless-gl dependency It is now necessary to import luma.gl through  luma.gl/headless  to get headless integration. When using the basic  luma.gl  import, the app no longer needs to have  gl  as a dependency. This should simplify build and setup for applications that don't use headless-gl. Improve change detection Redraw flag management improvements New experimental Renderer class -  requestAnimationFrame  replacement. v1.0 Release Date: 2016 Theme: A smaller, mostly internal version that was the starting point for luma.gl development. Major Features Initial ES6 Port from PhiloGL","headings":[{"value":"What's New","depth":1},{"value":"Version 8.5","depth":2},{"value":"@luma.gl/shadertools","depth":3},{"value":"@luma.gl/experimental","depth":3},{"value":"Version 8.4","depth":2},{"value":"TypeScript","depth":3},{"value":"Texture","depth":3},{"value":"gltools","depth":3},{"value":"Version 8.3","depth":2},{"value":"TypeScript","depth":3},{"value":"glTF","depth":3},{"value":"Version 8.1","depth":2},{"value":"GPU-accelerated point-in-polygon tests","depth":3},{"value":"Improved vertex array object support in WebGL 1","depth":3},{"value":"GLSL 3.0 to 1.0 transpilation","depth":3},{"value":"Version 8.0","depth":2},{"value":"Performance","depth":3},{"value":"Streamlined API","depth":3},{"value":"Version 7.3","depth":2},{"value":"Program Management","depth":3},{"value":"Custom Device Pixels (Experimental)","depth":3},{"value":"Version 7.2","depth":2},{"value":"FXAA Shader Module","depth":3},{"value":"ImageBitmap Textures","depth":3},{"value":"Version 7.1","depth":2},{"value":"Enhanced Shader Injection System","depth":3},{"value":"Animation Support","depth":3},{"value":"Version 7.0","depth":2},{"value":"glTF Support","depth":3},{"value":"loaders.gl Integration","depth":3},{"value":"Asynchronous Textures","depth":3},{"value":"Lighting","depth":3},{"value":"Modularization Improvements","depth":3},{"value":"Performance Instrumentation","depth":3},{"value":"Interleaved Attributes","depth":3},{"value":"Unified functions for Framebuffers and Textures (Read/Copy/Blit)","depth":3},{"value":"Experimental Features","depth":2},{"value":"WebVR Support (experimental)","depth":3},{"value":"Version 6.4","depth":2},{"value":"PBR (Physically Based) Rendering and Material","depth":3},{"value":"Copy and Blit methods","depth":3},{"value":"Version 6.3","depth":2},{"value":"Uniform Caching","depth":3},{"value":"New submodules","depth":3},{"value":"Offscreen Rendering (Experimental)","depth":3},{"value":"Version 6.2","depth":2},{"value":"ShaderModulePass (Experimental)","depth":3},{"value":"Transform Texture support (Experimental)","depth":3},{"value":"Version 6.1","depth":2},{"value":"New Multipass Rendering System (Experimental)","depth":3},{"value":"Post-Processing Effects (Experimental)","depth":3},{"value":"New loaders.gl Submodule (Experimental)","depth":3},{"value":"Transform Class now supports Shader Modules","depth":3},{"value":"Documentation Search","depth":3},{"value":"Version 6.0","depth":2},{"value":"WebGL Improvements","depth":2},{"value":"Attribute Management Optimizations","depth":3},{"value":"Buffer Memory Optimizations","depth":3},{"value":"Transform Feedback Improvements","depth":3},{"value":"Transform class (WebGL 2)","depth":3},{"value":"Shader Module System Improvements","depth":2},{"value":"GLSL Transpilation","depth":3},{"value":"Shader Code Injection","depth":3},{"value":"Shader Modules now support GLSL 3.00 ES","depth":3},{"value":"Documentation","depth":2},{"value":"Developer's Guide","depth":3},{"value":"API Cleanup","depth":2},{"value":"Removal of Deprecated/Unused Methods","depth":3},{"value":"Renamed Methods","depth":3},{"value":"Version 5.3","depth":2},{"value":"Version 5.2","depth":2},{"value":"Transform class (WebGL 2, Experimental)","depth":2},{"value":"Framebuffer Class","depth":2},{"value":"Bundle Size Reduction","depth":2},{"value":"Running luma.gl in Node.js","depth":2},{"value":"Debug Mode Changes","depth":2},{"value":"Examples","depth":2},{"value":"Version 5.1","depth":2},{"value":"TransformFeedback Class","depth":2},{"value":"Version 5.0","depth":2},{"value":"Examples","depth":3},{"value":"Model Class","depth":3},{"value":"Framebuffer Binding Management","depth":3},{"value":"WebGL 2 Improvements","depth":3},{"value":"Shader Modules","depth":3},{"value":"Version 4.0","depth":2},{"value":"Full WebGL 2 Support","depth":3},{"value":"WebGL Capability Management","depth":3},{"value":"WebGL State Management","depth":3},{"value":"shadertools - A New Shader Module System","depth":3},{"value":"Documentation Improvements","depth":3},{"value":"Code Size Improvements","depth":3},{"value":"v3.0","depth":2},{"value":"Major News","depth":2},{"value":"Examples","depth":3},{"value":"Debug Support","depth":2},{"value":"New AnimationFrame class","depth":2},{"value":"Smaller changes","depth":2},{"value":"New gl-matrix based math library","depth":2},{"value":"Library Size","depth":3},{"value":"Experimental APIs","depth":3},{"value":"Deprecations/Deletions","depth":3},{"value":"Internal improvements","depth":3},{"value":"Breaking Changes","depth":3},{"value":"v2.0","depth":2},{"value":"Major Features","depth":2},{"value":"TimerQuery","depth":3},{"value":"Debug Support","depth":2},{"value":"Linux support","depth":3},{"value":"New gl-matrix based math classes","depth":3},{"value":"TimerQuery, WebGL Extension doc, fix crash on Travis CI","depth":3},{"value":"Debug log improvements, import fix","depth":3},{"value":"Add ability to import luma without io","depth":3},{"value":"Node.js/AttributeManager/Renderer/Program.render()/Examples","depth":3},{"value":"Node.js support","depth":3},{"value":"luma global initialization","depth":3},{"value":"Headless support","depth":3},{"value":"Improve change detection","depth":3},{"value":"Decoupled headless-gl dependency","depth":3},{"value":"Improve change detection","depth":3},{"value":"v1.0","depth":2},{"value":"Major Features","depth":3}],"slug":"docs/whats-new","title":"What's New"},{"excerpt":"Overview luma.gl  is split into several modules that are each responsible for a particular part of the rendering stack: engine : High-level constructs such as  Model ,  AnimationLoop  and  Geometry  that allow a developer to work without worrying about rendering pipeline details. webgl : Wrapper classes around WebGL objects such as  Program ,  Buffer ,  VertexArray  that allow a developer to manager the rendering pipeline directly but with a more convenient API. gltools : A set of helper functions for instrumenting and managing state on an WebGL context. This allows developers to program directly against the WebGL API with some helpful polyfilling and state tracking. shadertools : A system for modularizing and composing GLSL shader code. debug : Tooling to aid in debugging. luma.gl  also exposes a  core  module that simply re-exports key parts of the other modules. This can be helpful to just get started without worrying too much about fine-grained control of dependencies. The  core  module re-exports the following functions and classes from other modules: Module Exports engine AnimationLoop, Model, Transform, ProgramManager, Timeline, Geometry, ClipSpace, ConeGeometry, CubeGeometry, CylinderGeometry, IcoSphereGeometry, PlaneGeometry, SphereGeometry, TruncatedConeGeometry webgl lumaStats, FEATURES, hasFeature, hasFeatures, Buffer, Program, Framebuffer, Renderbuffer, Texture2D, TextureCube, clear, readPixelsToArray, readPixelsToBuffer, cloneTextureFrom, copyToTexture, Texture3D, TransformFeedback gltools createGLContext, instrumentGLContext, isWebGL, isWebGL2, getParameters, setParameters, withParameters, resetParameters, cssToDeviceRatio, cssToDevicePixels shadertools normalizeShaderModule, fp32, fp64, project, dirlight, picking, gouraudLighting, phongLighting, pbr","headings":[{"value":"Overview","depth":1}],"slug":"docs/developer-guide","title":"Overview"},{"excerpt":"Accessors \"Buffer accessor objects\" (or \"accessor objects\", or just \"accessors\" for short) are used to describe the structure of data contained in WebGL buffers (for more information see  Buffers ). When using  Buffer s as input to shader programs, applications must tell WebGL how the data in the buffer is formatted, so that the GPU knows how to access buffers' memory. To enable applications to specify how the buffer memory should be accessed, luma.gl APIs that set attribute buffers accept buffer \"accessor objects\". Accessor Object Fields This is an overview of the object accessor fields that are available to applications to define format descriptions. These objects can contain the following fields, this is an excerpt from  Accessor . Property Auto Deduced Default Comment buffer No An accessor can optionally reference a specific buffer. Multiple accessors can point to the same buffer, providing different views or \"slices\" of the buffer's memory. offset No 0 Byte offset to start of data in buffer stride No 0 Extra bytes between each successive data element type Yes GL.FLOAT Low level data type ( GL.BYTE ,  GL.SHORT , ...) size Yes 1 Components per element ( 1 - 4 ) divisor Yes 0 Enables/disables instancing normalize N/A false Normalize integers to  -1,1 , or  0,1  if unsigned integer N/A false Disable conversion of integer values to floats  WebGL 2 Combining Accessors with Buffers When setting attributes (e.g. using  Model.setProps({attributes: {attributeName: value, ...}})) , each attribute value needs to contain both a buffer (a handle to the raw data uploaded to the GPU) and an accessor (describing how that data should be accessed). luma.gl provides three methods to specify attribute values so that both a buffer and an accessor are provided: As a two-element array:  [buffer, accessor] . As an accessor, in which case the accessor object's  buffer  field should be set to the matching  Buffer . As a  Buffer , in which case the  Buffer  objects  accessor  field should be set to the mathing  Accessor . All three methods have their uses: the first option gives the applications full freedom to dynamically select combinations of buffers and accessors, the second option is often the natural choice when working with interleaved buffers (see below), and the last choice is often the most convenient when just setting up an ad-hoc buffer for immediate use, as the accessor can be stored directly on the buffer, avoiding the need to manage separate objects. Accessor Class vs Accessor Objects luma.gl provides the  Accessor  helper class to help you work with accessor objects. For instance, the  Accessor  class supports merging of partial accessor objects, see below. Note that it is not necessary to use the  Accessor  class, as plain old JavaScript objects with the appropriate fields are also accepted by the various APIs that accept accessors. Use the style that works best for your application. \"Partial\" Accessors luma.gl allows \"partial\" accessors to be created, and later combined. Usually many accessor fields can be left undefined (e.g. because defaults are sufficient, or because accessor auto-deduction has already deduced the information, see below). Partial accessors will be created automatically by  Program  when shaders are compiled and linked, and also by  Buffer  objects when they are created. Any application supplied accessors fields will then be merged in (override) these auto-deduceted fields, that can add any fine-tuning or override of parameters. Accessor Auto Deduction luma.gl attempts to \"auto deduce\" as much accessor information as it can, for instance luma.gl can extract fields like  type  and  size  after shaders have been compiled. This relieves applications from having to respecify the same thing multiple times. For instance if the application has already declared an attribute as  in vec2 size  in the vertex shader, it does not need to specify  size:2, type: GL.FLOAT  again in the accessor, when it sets the buffer in JavaScript, since this information will have been auto-deduced. In many cases, when buffers are not shared between attributes (i.e. interleaved) and default behavior is desired, luma.gl applications often do not need to specify any  Accessor  at all. Merging (Resolving) Accessors The  Accessor  API allows for accessors to be merged (or \"resolved\") into a new  Accessor . Accessor mmerging is mainly used internally in luma.gl to implement support for partial accessors and accessor auto deduction, but can be used by applications if necessary. Data Interleaving Using the stride  and  offset  fields in accessor objects, it is possible to interleave two arrays so that the first two elements of one array are next to each other, then the next two elements etc. For more information see the article about attributes. Using Different Size in Buffers and Shaders It is possible to use different size memory attributes than specified by the GLSL shader code, by specifying a different size in the accessor compared to the GLSL shader variable declaration. Extra components in the Buffer memory will be ignored, missing components will be filled in from  (0.0, 0.0, 0.0, 1.0) Be aware that the headless gl integration does not support this feature due to limitations in headless gl. glTF Format Accessors glTF formatted files . glTF files contain two JSON object arrays (\"bufferViews\" and \"accessors\") that describe how raw memory buffers are organized and should be interpreted. The  Accessor  and  Buffer  class APIs have intentionally been designed to be a close representation when converting \"accessors\" and \"bufferViews\" stored in glTF files. Each glTF  accessor  can be mapped to a luma.gl  Accessor  and each glTF  bufferView  can be mapped to a luma.gl  Buffer . For more details see  glTF mapping .","headings":[{"value":"Accessors","depth":1},{"value":"Accessor Object Fields","depth":2},{"value":"Combining Accessors with Buffers","depth":2},{"value":"Accessor Class vs Accessor Objects","depth":2},{"value":"\"Partial\" Accessors","depth":3},{"value":"Accessor Auto Deduction","depth":3},{"value":"Merging (Resolving) Accessors","depth":3},{"value":"Data Interleaving","depth":3},{"value":"Using Different Size in Buffers and Shaders","depth":3},{"value":"glTF Format Accessors","depth":3}],"slug":"docs/developer-guide/accessors","title":"Accessors"},{"excerpt":"Bundling Optimizing for Bundle Size luma.gl and luma.gl provide a lot of functionality and the amount of code these libraries contain will of course impact the size of your application bundle and your startup load time. There are multiple techniques used in JavaScript. Choosing a dist folder When installed from npm, luma.gl and related libraries come with three separate  dist  sub folders. Folder mainField Description dist/es6 esnext The most compact distribution is with very few exceptions essentially untranspiled ES6/ES2015 code (via  babel-preset-env ). This is the smallest distribution, and is the best choice if you are only targeting modern \"evergreen\" browsers (e.g. not IE11 or older mobile devices). dist/esm module Same as  dist/es5 , except  export  and  import  statements are left untranspiled to enable tree shaking. The main reason to use this distribution is if your are targeting older browsers (e.g. IE11 or older mobile devices). dist/es5 main All code is transpiled into ES5 and exports/imports are transpiled into  commonjs  requires. The main reason to use this distribution is if your bundler does not support tree-shaking using  import / export  syntax. You will have to check the documentation of your particular bundler to see what configuration options are available: Webpack 2 and later will pick the  esm  distribution by default (the  module  main field) Webpack 4 allows you to choose the  esnext  distribution by specifying a new  resolve.mainFields  array in your application's webpack config. For other bundlers, please refer to the respective documentation to see if you can control which distribution to use. If not, expect the  es5  distribution to be used. About Tree-Shaking luma.gl is designed to fully leverage tree-shaking. Tree-shaking should be possible with any supporting browser but development has currentle focusing on enabling the webpack 4 + babel 7 combination which provides excellent results. Some things to be aware of when working with tree-shaking: At least in Webpack, tree shaking is done by the uglifier, which is typically only run as the very last step on production builds. This means that it is typically not possible to assess the benefits of tree shaking during development. The lack of tree-shaking during development makes it hard to make statements about bundle size impact of a library just from looking at bundle sizes of development builds or the size of the library's npm module. Our recommendation is to always measure impact on your actual production builds. Pay for What you Use Naturally, an application that uses all the functionality offered by a framework will benefit little from tree shaking, whereas a small app that only uses a few selected components should expect big savings. When we modularize luma.gl, we are less focused on the size of the entire library, and more on making sure that applications only pay for the features they actually use. Also we try to make the core set of functionality small. Bundle Size Numbers So, what kind of impact on bundle sizes should you expect when using luma.gl? When do you know if you have set up your bundler optimally. To help answer these questions, we provide some numbers you can compare against. luma.gl has scripts that measure the size of a minified bundle after each build, which allows us to provide comparison numbers between releases. This bundle imports the  Module  and  AnimationLoop  classes, which are the basic building blocks of most apps. es6-production 6.1 Bundle/Zip 6.0 Bundle/Zip es6-production 144KB / 42KB 181KB / 51KB esm-production 209KB / 49KB 281KB / 66KB es5-production 408KB / 88KB 422KB / 93KB es6-development 787KB / 123KB 926KB / 165KB esm-development 1048KB / 150KB 1167KB / 192KB es5-development 961KB / 142KB 1052KB / 182KB Numbers represent the minified bundle size of a minimal application, bundled with Webpack 4, which means that the  ES6  and ESM numbers benefit from tree shaking. The number in parenthesis are the compressed bundle sizes. This is an indication of the how much extra size will be added to your compressed app bundle if you import luma.gl. For the ES6 and ESM dists, apps that use more luma.gl classes and features will see an increase in bundle size. Future Work This is not the final word on luma.gl bundle size. More work is being done to reduce the size of luma.gl and we are confident that even as fture releases will have more functionality, we will be able to keep the library code from growing and, more importantly, make luma.gl even more \"tree shakeable\", with the intention that apps should only \"pay for what they use\". Remarks Optimizing for minified code  - Due to inclusion of sourcemaps etc, the bundle size impact of luma.gl tends to look more significant in development builds than in the final production builds. While reducing the size of the development libraries is also desirable, the current goal is to ensure the impact of adding luma.gl on the final, minified/uglified application bundle is as small as possible. Compressed bundle sizes are calculated using  gzip -9 . Consider using slower  brotli  compression for static assests, it typically provides an additional 20% reduction.","headings":[{"value":"Bundling","depth":1},{"value":"Optimizing for Bundle Size","depth":2},{"value":"Choosing a dist folder","depth":3},{"value":"About Tree-Shaking","depth":3},{"value":"Pay for What you Use","depth":3},{"value":"Bundle Size Numbers","depth":3},{"value":"Future Work","depth":3},{"value":"Remarks","depth":2}],"slug":"docs/developer-guide/bundling","title":"Bundling"},{"excerpt":"Contributing In order to contribute to luma.gl you need to be able to build and test luma.gl itself. Development Environment To get started developing luma.gl, first make sure to install all dependancies from the repository root: yarn bootstrap luma.gl's source code is in the  modules/  directory. Development is most easily done by running the examples in development mode, e.g.: Any modifications made to the source or example code will cause the example to rebuild and the page to refresh, making quick iterations on code changes straightforward. Testing against the full website can be done by running  yarn start  in the the  website/ . This full website take longer to build but makes it easier to test against all examples. This can be helpful when making core changes to luma.gl. As with running the examples in development mode, a rebuild and page refresh will be triggered whenever source or website code is updated. Testing Testing is performed on Travis CI and using a precommit hook. Local testing is supported on these environments: yarn test  - runs tests under node using headless.gl and a headless Chrome instance (using  SwiftShader ). yarn test browser  - Tests in your browser, may be helpful to quickly debug test case failures since it autoreloads on changes and gives you full access to your browser's debugger. When adding new features, please add relevant unit tests to the  test/  directory in the relevant module. Helpful Hints To only run one test from the suite for debugging purposes, change a call to  test  in the relevant spec to  test.only . Remember to change this back before committing! If a test fails in  headless , but not in the browser, it's likely due to a difference in the contexts created (WebGL 1 versus 2), or the extensions available. Running in a browser without WebGL 2 support (e.g. Safari), might help narrow the issue down.","headings":[{"value":"Contributing","depth":1},{"value":"Development Environment","depth":2},{"value":"Testing","depth":2},{"value":"Helpful Hints","depth":3}],"slug":"docs/developer-guide/contributing","title":"Contributing"},{"excerpt":"Debugging luma.gl has a number of provisions for debugging designed to help you save time during development. id strings Most classes in luma.gl allow you to supply and optional  id  string to their constructors. This allows you to later easily check in the debugger which object (which specific instance of that class) is involved in a stack trace. id s that you provide are also used by the built-in logging. Logging luma.gl has a logging mechanism. Set the global variable luma.log.level to 3 (can be done in the browser console at any time) and luma will print tables for uniforms and attributes providing information about their values and types before each render call. This can be extremely helpful for checking that shaders are getting valid inputs. Shader compilation errors luma.gl takes care to extract as much information as possible about shader compiler errors etc, and will throw exceptions with very detailed error strings when shaders fail to compile. luma.gl also injects and parses  glslify  \"shader names\", making it possible to name shaders inside the shader code, making it easier to identify which shader is involved when e.g shader parsing errors occur. Parameter Validation luma.gl runs checks on attributes and buffers when they are being set, catching many trivial errors such as setting uniforms to  undefined  or wrong type (scalar vs array etc). Buffers will also have their first values checked to ensure that they are not NaN. As an example, setting uniforms to illegal values now throws an exception containing a helpful error message including the name of the problematic uniform. Debug Module Importing  @luma.gl/debug  will enable creation of debug contexts for several  luma.gl  functions. See  @luma.gl/debug  for more information.","headings":[{"value":"Debugging","depth":1},{"value":"id strings","depth":2},{"value":"Logging","depth":2},{"value":"Shader compilation errors","depth":2},{"value":"Parameter Validation","depth":2},{"value":"Debug Module","depth":2}],"slug":"docs/developer-guide/debugging","title":"Debugging"},{"excerpt":"Shader Modules Overview shadertools is a GLSL shader module system built around a GLSL \"assembler\" that allows you build modular shaders. It addresses the lack of a module/import system in the GLSL language and allows you to import chunks of reusable shader code from modules into your shader source code, and organize your shader code in reusable modules. Enables you to import and \"inject\" prepackaged modules of shader code into your shaders. Allows you to package up reusable GLSL code as shader modules. Adds GPU detection and a measure of portability your shaders. Usage To add/inject existing modules into your shaders, just add the modules parameter to your  assembleShaders  call: To create a new shader module, you need to create a descriptor object. This object can be used as shader module directly: Structure of a Shader Module Shader Module Type A shader module is either: Generic  - a set of generic GLSL functions that can be included either in a fragment shader or a vertex shader (or both). The  fp64  module is a good example of this type of module. Functional  - Contains specific vertex and/or fragment shader \"chunks\", often set up so that the vertex shader part sets up a  varying  used by the fragment shader part. Shader Module Descriptor To define a new shader module, you create a descriptor object that brings together all the necessary pieces: Descriptor objects can define the following fields: name  ( String , Required) - The name of the shader module. vs  - (String | null) fs  - (String | null) getUniforms  JavaScript function that maps JavaScript parameter keys to uniforms used by this module uniforms  ( Object ) - a light alternative to  getUniforms , see below inject  ( Object ) - injections the module will make into shader hooks, see below dependencies  ( Array ) - a list of other shader modules that this module is dependent on deprecations  ( Array ) - a list of deprecated APIs. If  deprecations  is supplied,  assembleShaders  will scan GLSL source code for the deprecated constructs and issue a console warning if found. Each API is described in the following format: type :  uniform <type>  or  function old : name of the deprecated uniform/function new : name of the new uniform/function deprecated : whether the old API is still supported. GLSL Code The GLSL code for a shader module typically contains: a mix of uniform and varying declarations one or more GLSL function definitions getUniforms Each shader module provides a method to get a map of uniforms for the shader. This function will be called with two arguments: opts  - the module settings to update. This argument may not be provided when  getUniforms  is called to generate a set of default uniform values. context  - the uniforms generated by this module's dependencies. The function should return a JavaScript object with keys representing uniform names and values representing uniform values. The function should expect the shape of the dependency uniforms to vary based on what's passed in  opts . This behavior is intended because we only want to recalculate a uniform if the uniforms that it depends on are changed. An example is the  project  and  project64  modules in deck.gl. When  opts.viewport  is provided,  project64  will receive the updated projection matrix generated by the  project  module. If  opts.viewport  is empty, then the  project  module generates nothing and so should  project64 . uniforms If the uniforms of this module can be directly pulled from user settings, they may declaratively defined by a  uniforms  object: At runtime, this map will be used to generate the uniforms needed by the shaders. If either  strength  or  center  is present in the user's module settings, then the user's value will be used; otherwise, the default value in the original definition will be used. Each uniform definition may contain the following fields: type  ( String ) - one of  number ,  boolean ,  array  or  object value  - the default value of this uniform With  type: 'number' , the following additional fields may be added for validation: min  ( Number ) max  ( Number ) Note:  uniforms  is ignored if  getUniforms  is provided. inject A map of hook function signatures to either the injection code string, or an object containing the injection code and an  order  option indicating ordering within the hook function. See  assembleShaders  documentation for more information on shader hooks. For example: GLSL Versions Shader modules will undergo some basic text transformations in order to match the GLSL version of the shaders they are injected into. These transformations are generally limited to the naming of input variables, output variables and texture sampling functions. See  assembleShaders  documentation for more information.","headings":[{"value":"Shader Modules","depth":1},{"value":"Overview","depth":2},{"value":"Usage","depth":2},{"value":"Structure of a Shader Module","depth":2},{"value":"Shader Module Type","depth":3},{"value":"Shader Module Descriptor","depth":3},{"value":"GLSL Code","depth":3},{"value":"getUniforms","depth":3},{"value":"uniforms","depth":3},{"value":"inject","depth":2},{"value":"GLSL Versions","depth":2}],"slug":"docs/developer-guide/shader-modules","title":"Shader Modules"},{"excerpt":"Transform Feedback (WebGL 2) Transform Feedback operations represent a GPGPU/GPU compute technique where GPU draw calls are configured so that they write some specified outputs from the vertex shaders to (one or more) GPU memory buffers that have been provided by the application. Applications use transform feedback to data processing from CPU to GPU, where multiple parallel execution units will be used for processing. Data is handled in form of  Buffer  objects, i.e. data resides in the GPU memory. Transform Feedback operations write their output into  Buffer  instances. These buffers can then be directly set as attributes on  Model  or  VertexArray  for regular rendering operations. Buffers can be read back to the CPU, but this has a high performance penaltyh. Ideally, the application's logic can be designed so that CPU access is not required which avoids expensive CPU and GPU sync. To run a single transform feedback operation: Create a  Program  or a  Model  with varyings ( out  variables) declared in the vertex shader's GLSL code, and provide the names of these varyings to the  Program  constructor. Use  Program.draw()  or  Model.draw()  with a  transformFeedback  parameter. Model.transform()  is equivalent to  Model.draw()  but automatically turns off the fragment shader stage. Alternatively, the more powerful  Transform  class is preferable if you don't want to deal with setting up  Program  and  TransformFeedback  instances, or if intend to run a repeating, double buffered transform feedback loop. Usage Use case : Specify source and destination buffers. Create a  Transform  object by passing, vs (vertex shader), source buffer(s), varyings (output variable names in vertex shader) and destination buffers. Then call  run  to perform one transform feedback iteration. Use case : Create destination buffers automatically. Transform  can internally create destination buffers (i.e. feedback buffers), when  feedbackMap  is provided. Each destination buffer is created with same settings and layout as corresponding source buffer as per  feedbackMap . Use case : Multiple iterations using swap(). When  feedbackMap  is specified buffers can be swapped using a single call to  swap() , this is useful for cases like particle simulation, where output of one transform feedback iteration is piped as input to the next iteration. Use case : Update one or more buffers using update() method.. Once  Transform  object is constructed and used, one or more source or destination buffers can be updated using  update .","headings":[{"value":"Transform Feedback (WebGL 2)","depth":1},{"value":"Usage","depth":2},{"value":"Use case : Specify source and destination buffers.","depth":3},{"value":"Use case : Create destination buffers automatically.","depth":3},{"value":"Use case : Multiple iterations using swap().","depth":3},{"value":"Use case : Update one or more buffers using update() method..","depth":3}],"slug":"docs/developer-guide/transform-feedback","title":"Transform Feedback (WebGL 2)"},{"excerpt":"Getting Started This tutorial will walk you through setting up a basic development environment for luma.gl applications using  webpack . Later tutorials will build on this one, so we recommend going through it first. Note:  It is assumed for these tutorials that you have some knowledge of the WebGL API. If you are unfamiliar with how to draw with WebGL, we highly recommend the excellent  WebGL 2 Fundamentals . From the command line, first run to set up our project directory and initialize npm. Next run to install our dependencies. Open the file  package.json  (created when we initialized npm), and add the following to the  scripts  block: The full contents of the  package.json  should be the following (dependency version numbers might differ): Create a file  webpack.config.js  in the project root and add the following to it: (For more information on Webpack, visit their  excellent documentation ). Now create a file  index.js  in the project root and add the following to it: This will be the basic structure of most luma.gl applications. To make sure everything works, let's add a draw command: and run from the command line. If all went well, a tab should open in your default browser, and you should see a black rectangle at the top left of your screen.","headings":[{"value":"Getting Started","depth":1}],"slug":"docs/getting-started","title":"Getting Started"},{"excerpt":"External Contexts This tutorial will be a simple demonstration of how to use an externally created WebGL context with luma.gl's higher-level APIs. So far, we have either created a WebGL context ourselves to use with low-level APIs, or allowed the the  AnimationLoop  class to create a WebGL context for us. luma.gl's higher-level APIs expect some instrumentation on the WebGL context, so we can't just use a context we create ourselves with classes like  Model  and  Buffer . The  AnimationLoop  class performs this instrumentation for us using the  instrumentGLContext  function from  @luma.gl/gltools , and we can use this function directly if we want to control creation of the context or use a context passed to us by another framework (e.g. the  GeoSpatial  example uses this technique with a WebGL context created by  MapboxGL ). We'll create a modified version of the  Hello Triangle  tutorial that creates a WebGL context manually rather than using the  AnimationLoop  class. To start with, we'll modify our imports: We then create our context and pass it to  instrumentGLContext : This performs some polyfilling (done by  polyfillContext , which we saw in the  Hello Instancing Low-level tutorial ) and tracks some additional metadata on the context, ensuring it will work properly with the rest of luma.gl. With that done, we simply create our luma.gl objects and draw as we did in the original example, with the sole difference being we create our own render loop using  requestAnimationFrame  rather than using the  AnimationLoop  callbacks. If all went well, a tri-color triangle should render as it did in the  Hello Triangle  example. A live version is available  here , and the full source code is listed below for reference:","headings":[{"value":"External Contexts","depth":1}],"slug":"docs/getting-started/external-context","title":"External Contexts"},{"excerpt":"Hello Cube In this tutorial, we'll pull together several of the techniques we've looked at in the previous tutorials (and add a few new ones) to render a more complex scene: a rotating 3D cube. We'll use luma.gl's built-in geometry primitives to create a cube mesh and handle 3D math using  math.gl .  math.gl  can be installed by running  npm i math.gl As always, we'll start with our imports: Our shaders are somewhat more involved that we've seen before: The two biggest additions to the shaders we've seen before are transforming the positions to rotate our model and create the 3D perspective effect (via the  uMVP  matrix) and sampling a texture to color fragments (via the  texture2D  call). The set up to render in 3D involves a few extra steps compared to the triangles we've been drawing so far: Some of the new techniques we're leveraging here are: Using  setParameters  to set up depth testing and ensure surfaces occlude each other properly. Compared to setting these parameters directly, the  setParameters  function has the advantage of tracking state and preventing redundant WebGL calls. Creating a texture using the  Texture2D  class. For our purposes, this is as simple as passing a URL to the image location (the image used in this tutorial is available  here , but any JPEG or PNG image will do). Creating view and MVP matrices using  math.gl 's  Matrix4  class to store the matrices we'll pass to our shaders to perform the animation and perspective projection. Generating attribute data using the  CubeGeometry  class and passing it to our  Model  using the  geometry  property. The geometry will automatically feed vertex position data into the  positions  attribute and texture coordinates (or UV coordinates) into the  texCoords  attribute. Our  onRender  is similar to what we've seen before with the extra step of setting up the transform matrix and passing it as a uniform to the  Model : We use  Matrix4 's matrix operations to create our final transformation matrix, taking advantage of a few additional parameters that are passed to the  onRender  method: aspect  is the aspect ratio of the canvas and is used to set up the perspective projection. tick  is simply a counter that increments each frame. We use it to drive the rotation animation. If all went well, you should see a rotating cube with the Uber Visualization logo painted on each side. The live demo is available  here , and the full source code is listed below for reference:","headings":[{"value":"Hello Cube","depth":1}],"slug":"docs/getting-started/hello-cube","title":"Hello Cube"},{"excerpt":"Hello Instancing (High-level) In this tutorial, we'll work through how to do instanced drawing with luma.gl's high-level APIs. We'll also take this opportunity to introduce luma.gl shader modules. We'll begin with our  hello triangle  app and make some modifications. First let's create a shader module: A shader module is essentially just some GLSL code that will be inserted into our vertex and fragment shaders. They're usually used to define functions that implement generic functionality that can be reused in different programs. In this case, we're defining one to simply pass a color from the vertex shader to the fragment shader in a varying. This module also demonstrates a common convention in luma.gl to prefix function and variable names in a shader module with the name of the module to avoid name collisions. Now let's update our vertex and fragment shaders to use the module functions: Now we update the  Model  to use the module: If you rerun the app, it should render as it did before. Now let's add some instancing to this scene! First we'll modify the position and color buffers we created before, and add an offset buffer to set the position of each instance: For this scene, the positions are vertex attributes, while the colors and offsets are instance attributes. Now add the offsets to the vertex shader: Finally, we need to add the new buffer to the  Model , and describe the parameters of the instanced draw: Note the new syntax used for the attributes. The second element in each array is an  accessor  that describes how the buffer should be traversed during a draw. luma.gl will try to infer these parameters from the data or the shader when possible, but when it can't (or when we want to override the inferred values), we have to provide an explicit accessor. We also provide the model with the number of instances we want to draw. If all went well, running the app now should draw four triangles, each a different color. See the live demo  here . For reference the complete code is provided below:","headings":[{"value":"Hello Instancing (High-level)","depth":1}],"slug":"docs/getting-started/hello-instancing-high","title":"Hello Instancing (High-level)"},{"excerpt":"Hello Instancing (Low-level) In this tutorial, we'll work through how to do instanced drawing with luma.gl's low-level APIs. This essentially means writing our app using the WebGL API directly, using only a few low-level helper functions to manage shaders and polyfilling. We'll need to install the  gltools  module so we can get a polyfilled context without the  AnimationLoop : Now we can update the imports: Since we aren't using the  AnimationLoop , we'll create our canvas and get a WebGL context directly: Note that we're creating a WebGL 1 context here. This will allow us to demonstrate the polyfilling. Creating our program is  a little  more verbose than before: Next we'll create our vertex array: Wait a minute... we're calling  createVertexArray  and  bindVertexArray  on a WebGL 1 context. But those functions aren't part of the WebGL 1 API! How is this working? The function  polyfillContext  that we used when creating our context will use WebGL extensions that are available to implement WebGL 2 functions on a WebGL 1 context. So we can just program against the WebGL 2 API! Well... mostly... Polyfilling will only work if the necessary extensions are available. And some WebGL 2 features like occlusion queries and transform feedback simply aren't supported by polyfills. Moving on... setting up the vertex array, concise as always in WebGL: And then we set up our draw loop: If all went well, you should see the same scene as drawn by the high- and mid-level apps: four triangles of different colors. See the live demo  here . We simply used luma.gl's  shadertools  and  gltools  to provide polyfilled instanced drawing and compose our shaders from modules. The full code for the app is available below:","headings":[{"value":"Hello Instancing (Low-level)","depth":1}],"slug":"docs/getting-started/hello-instancing-low","title":"Hello Instancing (Low-level)"},{"excerpt":"Hello Instancing (Mid-level) In this tutorial, we'll work through how to do instanced drawing with luma.gl's mid-level APIs. This will involve using luma.gl's WebGL wrappers to do the drawing instead of the higher-level  Model . We'll start from the  high-level app  we created. First we need to install the  shadertools  module so we can compose shaders without the  Model  class: Now we can update the imports: Most of the initialization is similar, but we'll replace the creation of  Model  with its individual parts: shader composition, a vertex array, and a program. Shader composition is handled by  assembleShaders We can then use the assembled shaders to create a  Program : The attributes for the draw are managed by a  VertexArray : The  VertexArray  takes the  program  as an argument to infer attribute parameters. The  vertexArray  and  program  are required for drawing, so we'll return them from  onInitialize , and then use them in  onRender : The scene should be identical to the one draw with the high-level API. See the live demo  here . The complete app is as follows:","headings":[{"value":"Hello Instancing (Mid-level)","depth":1}],"slug":"docs/getting-started/hello-instancing-mid","title":"Hello Instancing (Mid-level)"},{"excerpt":"Hello Triangle This tutorial will demonstrate how to draw a triangle using luma.gl's high-level APIs. It is assumed you've set up your development environment as described in  Getting Started . Your  index.js  file should look like the following: First, we'll need to update our imports with the classes we'll be using,  Buffer  and  Model : Now let's create some buffers in the  onInitialize  method to hold our attribute data: Next let's add the vertex and fragment shader code we'll be using to draw: As a final step in our initialization, we'll create a  Model  and return it from  onInitialize : A  Model  can be thought of as gathering all the WebGL pieces necessary for a single draw call: programs, attributes, uniforms. Also note that we return the  Model  instance we created. This will make it available to the  onRender  method. Our  onRender  method is comparitavely much simpler: This clears the canvas and draws the  Model . If all went well, you should see a tri-color triangle on a black background. See the live demo  here . The entire application should look like the following:","headings":[{"value":"Hello Triangle","depth":1}],"slug":"docs/getting-started/hello-triangle","title":"Hello Triangle"},{"excerpt":"High, Medium, Low luma.gl is designed to provide support for development at whatever level the user requires. This can roughly be split into three levels of abstraction: Low-level: Program directly with the WebGL API with some lightweight tools for managing the gl context, shaders and debugging. This will primarily involve using the  shadertools ,  gltools  and  debug  modules. Mid-level: Program with convenient wrapper classes around the WebGL API. This involves using the  webgl  module. High-level: Program using 3D engine constructs like models or resource managers. This primarily involves using the  engine  and  webgl  modules. To demonstrate how luma.gl functions at these three levels, we'll implement the same scene, 4 instanced colored triangles, three times, once at each level of abstraction.","headings":[{"value":"High, Medium, Low","depth":1}],"slug":"docs/getting-started/high-medium-low","title":"High, Medium, Low"},{"excerpt":"Instanced Transform In this final tutorial, we'll pull together almost everything we've learned in past tutorials into a single scene: lighing, textures, geometry, shader modules, instancing and transform feedback. Whew! This will build on the  previous tutorial , so it might be helpful to start with its source code. We'll be drawing 4 instanced cubes, textured and lit in the same way as in the lighting tutorial, but with the animations updated by transform feedback. The  Transform  class is the only addition we need for our imports: The vertex shader for our transform feedback is quite simple. It just increments a scalar rotation value on each run: In order to handle rotation updates in the transform feedback, we have to move construction of the rotation matrix into the vertex shader. We'll use an  axis-angle , passing the axis and rotation angle as instanced attributes (with the rotation angles being updated by transform feedback): We also pass an  offsets  instanced attribute to position each cube. Our fragment shader doesn't change at all: Our  onInitialize  method will need several updates. First we create buffers for our instanced data: The  offsetBuffer  sets positions so the cubes will be in a square formation. The  axisBuffer  looks more complicated, but its simply a set of 4 normalized vectors about which we'll rotate our cubes. Finally, the  rotationBuffer  simply starts with 4 random angles between 0 and 2 π . The  Transform  is straightforward to set up, simply taking the  rotationBuffer  and our vertex shader as input: And the  Model  needs to be updated to take the instanced attributes and  instanceCount : Our  onRender  needs an update to perform the transform feedback and pass the transformed rotation buffer to the  Model : If all went well, you should see 4 rotating cubes. This scene is significantly more complex than anything we've seen before, so take some time to play around with it and get to know the various parts. The live demo is available  here , and the full source code is listed below for reference:","headings":[{"value":"Instanced Transform","depth":1}],"slug":"docs/getting-started/instanced-transform","title":"Instanced Transform"},{"excerpt":"Lighting This tutorial will expand on the  previous one , but we'll add some lighting to enhance the feeling of 3D in the scene. To accomplish this, we'll use one of  luma.gl 's built-in shader modules for the first time. To start, we'll add the  phongLighting  module from  @luma.gl/shadertools  to our imports: The  phongLighting  shader module adds functions to our fragment shader to facilitate lighting calculations. We'll modify our shaders to perform our lighting calculations in the following ways: We'll input the surface  normals  as an attribute. We'll pass the world positions and normals to the fragment shader in  varying s We'll call  lighting_getLightColor , which will be added to our fragment shader by the  phongLighting  module, to calculate the final fragment color. Our  onInitialize  method needs a few significant updates: We're splitting the model matrix out on its own so we can use it in our shaders to transform the positions and normals for the lighting calculations. The biggest change, however, is the  moduleSettings  parameter we're passing to our  Model  constructor.  moduleSettings  are passed on to shader modules to help them set up uniforms. In this case, we're passing some material and light properties that  phongLighting  uses to perform its lighting calculations in  lighting_getLightColor . Our  onRender  doesn't change much except to set up the model matrix separately from the MVP matrix and pass it as a uniform: If all went well, you should see a scene almost identical to the one from the  previous tutorial  but with some white light reflecting off the cube. The live demo is available  here , and the full source code is listed below for reference:","headings":[{"value":"Lighting","depth":1}],"slug":"docs/getting-started/lighting","title":"Lighting"},{"excerpt":"Shader Hooks In the  previous tutorial , we used shader modules to insert re-usable functions into the shaders that use them. In this tutorial, we'll focus on another feature of shader modules: the ability to modify the behavior of shaders that use them via  shader hooks . A shader hook is simply a function inserted into a vertex or fragment shader. By default, these functions will be no-ops, but they define entry points into which shader modules can inject code. For high-level API usage, shader hooks are exposed via  ProgramManagers  (we'll look at low-level shader hooks later): Shader modules can then inject code into the hook via their  inject  property: We'll use these features to create a modified version of the previous tutorial, using shader hooks and modules to modify the behavior of a single set of vertex and fragment shaders. We'll start by setting up our imports and defining our base vertex and fragment shaders: Here we have a shader hook function,  OFFSET_POSITION , called in our vertex shader. Next we'll create two shader modules that insert code into the shader hook: These shader modules inject code into the shader hook that will modify the x-coordinate of the position passed in. The  inject  property maps shader hook names to the code to be injected into them. The  vs  prefix indicates that this is a vertex shader hook. The  onInitialize  method of our  AnimationLoop  will be somewhat different from the previous example. To create a shader hook, we need access to a  ProgramManager  instance: The shader hook definition is the function signature with a prefix indicating whether it is intended for the vertex shader ( vs ) or fragment shader ( fs ). Shader hooks are always  void  funtions so they must return values to the caller via  out  or  inout  argurments. The rest of  onInitialize  is similar to what we've seen before with the exception of using the new shader modules and the  ProgramManager  to create our  Model s: The  onRender  method is the same as before. If all went well, a blue trangle and a red triangle should be drawn side-by-side on the canvas. The code injected by the modules into the shader hook is what offsets each triangle to the left or right. See the live demo  here . Shader hooks allowed us to define our vertex and fragment shaders once and modify their behavior based on the shader module included. The entire application should look like the following:","headings":[{"value":"Shader Hooks","depth":1}],"slug":"docs/getting-started/shader-hooks","title":"Shader Hooks"},{"excerpt":"Shader Modules (Low-level) So far, we've been using shader modules and hooks via the  Model  class, but these tools are also available own their via the the  assembleShaders  function in  @luma.gl/shadertools .  assembleShaders  operates on the shader source as text, so it can be used in any framework or even with the WebGL API itself. assembleShaders  takes the base vertex and fragment source, as well as any modules and hookFunctions we want to include, and returns a JavaScript object with the the final shader sources in the  vs  and  fs  properties: To demonstrate how this works, we'll re-implement the  shader hook tutorial  using WebGL calls directly. To start, we'll modify our imports: Our shaders and modules will be the same as before: We then create two programs by first assembling our base shaders with the desired modules and shader hooks, and then using them to create WebGL program objects: With our final programs created, we can draw as we would in any other WebGL application. The complete port of the shader hook demo is listed below and the live version is available  here .","headings":[{"value":"Shader Modules (Low-level)","depth":1}],"slug":"docs/getting-started/shader-modules-low","title":"Shader Modules (Low-level)"},{"excerpt":"Shader Modules This tutorial will demonstrate how to use luma.gl shader modules to make reusable bits of functionality and dynamically insert them into your shaders. Most of this will be fairly similar to the  Hello Triangle  app. We'll start by setting up our imports and defining our base vertex and fragment shaders: We have two vertex and fragment shader pairs: one will move vertices to the left, the other moves vertices to the right. Both fragment shaders take an  HSV color  as input call a  color_hsv2rgb  to convert it to RGB. But  color_hsv2rgb  isn't defined anywhere, so these shaders will not compile as-is. We define  color_hsv2rgb  in a shader module: Shader modules are simply JavaScript objects that contain at least a name and some shader code. They can be defined to inject code into the vertex shader, the fragment shader or both. Our  colorModule  defines the  color_hsv2rgb  function used by our fragment shaders. It converts the HSV value to RGB and returns it. We're applying a shader module best practice of prefixing our function with the module name ( color_ ) to avoid name collisions. In the  onInitialize  method of our  AnimationLoop , we create two models with different vertex and fragment shader sources, but both including the our  colorModule . In  onRender , we simply draw both models: If all went well, a blue trangle and a red triangle should be drawn side-by-side on the canvas. See the live demo  here . Shader modules allowed us to define our HSL to RGB conversion function once and use it across multiple programs. The entire application should look like the following:","headings":[{"value":"Shader Modules","depth":1}],"slug":"docs/getting-started/shader-modules","title":"Shader Modules"},{"excerpt":"Transform Feedback In this tutorial, we'll learn how to use  transform feedback  using luma.gl's high-level API. Transform feedback allows us to capture vertex shader results from one pass and use them in subsequent passes. It is a powerful tool that can be used to set up massively parrallelized animations or data transformations. Note that transform feedback can only be used with WebGL 2. In luma.gl, transform feedback is primarily exposed via the  Transform  class, which simplifies usage by managing input and output buffers. We'll demonstrate its usage by setting up a simple animation that runs completely on the GPU. To start, we'll modify our imports to include  Transform  from  @luma.gl/engine : Then we'll define our shaders, which we'll write in GLSL ES 3.0 since we're using WebGL 2: Internally, we'll be using two separate programs, one for transform feedback and the other for rendering, so we define shaders for both. By default, the  Transform  class will skip rasterization and doesn't require a fragment shader since transform feedback is an operation on vertex data. We define a vertex shader for a transform feedback pass that simply rotates each vertex by 2 degrees in the xy-plane. The rendering vertex and fragment shaders are identical to the ones used in the  Hello Triangle  tutorial aside from being written in GLSL ES 3.0. In  onInitialize , we create our  Transform  instance: We pass the vertex shader we defined, as well as the initial input buffer in the  sourceBuffers  property, which maps attribute names to buffers. The  feedbackMap  property maps input attributes to output varyings from the vertex shader. Internally it will create an output buffer of the same size as the input buffer into which transformed data will be written. Finally, we create a model instance to perform the rendering: We set up the  Model  similarly to how we've done in other tutorials, with the exception that the  position  attribute is backed by the  vPosition  output buffer created by the  Transform . Our  onRender  involves a few additional steps compared to what we've seen before: First, we run the transform feedback to write the rotated positions to the  vPosition  output buffer. We then bind the  Model 's  position  attribute to the  vPosition  output buffer from the last transform pass and draw. Finally, we swap the input and output buffers in the transform so that the newly rotated positions will be used as input for the next pass, allowing the animation to continue. If all went well, you should see a tri-color triangle rotating on the screen. A live demo is available  here , and the complete application is listed below for reference:","headings":[{"value":"Transform Feedback","depth":1}],"slug":"docs/getting-started/transform-feedback","title":"Transform Feedback"},{"excerpt":"What's Next? That concludes our  luma.gl  tutorial series. If you went through the full set of tutorials, you've taken a deep dive into some of  luma.gl 's more powerful features, including polyfilling the WebGL context, shader modules and composition, instanced drawing, and transform feedback. To dig deeper into  luma.gl 's API, we recommend playing around with the examples in the  examples directory  of the repository, which demonstrate various parts of the API in more detail. They can also be browsed on the  website . To explore the examples, clone the  luma.gl  repo and run the following in a given example's directory: This will start a local development server and open the page in your browser. The main application code is in  app.js  and the page will automatically refresh whenever it's udpated. Note that we checkout the latest release branch here ( 8.1-release ), which is recommended as  master  is the active development branch. Happy exploring!","headings":[{"value":"What's Next?","depth":1}],"slug":"docs/getting-started/whats-next","title":"What's Next?"},{"excerpt":"@luma.gl/constants Overview Exports an object with all WebGL1 and WebGL2 constants. Note: This file is framework independent and can be used by any webgl application. About luma.gl luma.gl is the engine that powers applications and frameworks like kepler.gl  WebGL based visualization overlays deck.gl  WebGL based visualization overlays Documentation For details, please refer to the extensive  online website .","headings":[{"value":"@luma.gl/constants","depth":1},{"value":"Overview","depth":2},{"value":"About luma.gl","depth":2},{"value":"Documentation","depth":2}],"slug":"modules/constants","title":"@luma.gl/constants"},{"excerpt":"luma.gl Overview luma.gl is a set of WebGL2 components for high-performance GPU-based rendering and computation in the browser. It is the engine that powers applications and frameworks like kepler.gl  WebGL based visualization overlays deck.gl  WebGL based visualization overlays Installation, Running Examples etc For details, please refer to the extensive  online website .","headings":[{"value":"luma.gl","depth":1},{"value":"Overview","depth":2},{"value":"Installation, Running Examples etc","depth":1}],"slug":"modules/core","title":"luma.gl"},{"excerpt":"@luma.gl/debug This is the debugging helper module for luma.gl. See  luma.gl  for documentation.","headings":[{"value":"@luma.gl/debug","depth":1}],"slug":"modules/debug","title":"@luma.gl/debug"},{"excerpt":"@luma.gl/experimental Code in this module represents early-stage experiments and are not considered officially supported parts of the API. Use at your own risk!","headings":[{"value":"@luma.gl/experimental","depth":1}],"slug":"modules/experimental","title":"@luma.gl/experimental"},{"excerpt":"@luma.gl/shadertools This is the shader module system module for luma.gl. See  luma.gl  for documentation.","headings":[{"value":"@luma.gl/shadertools","depth":1}],"slug":"modules/shadertools","title":"@luma.gl/shadertools"},{"excerpt":"@luma.gl/test-utils Client-side utility for browser-based WebGL render tests. This class is intended to be used with  BrowserTestDriver  from  @probe.gl/test-utils . Together they support the following workflow: Launch a Puppeteer instance (headless or non-headless) to run a test application In the test application, create a canvas and  WebGLContext . For each test case, render something to the  WebGLContext , take a screenshot, and perform pixel-diffing with a pre-defined \"golden image\". Report the matching result. Proceed to the next test case until done. See  luma.gl website  for documentation.","headings":[{"value":"@luma.gl/test-utils","depth":1}],"slug":"modules/test-utils","title":"@luma.gl/test-utils"},{"excerpt":"@luma.gl/webgl This module contains a set of JavaScript class wrappers for the WebGL2 API. webgl-utils This luma.gl sub-module contains a number of completely generic WebGL helper functions that luma.gl relies on. They are independent of the luma.gl API and of each other, and could possibly be of generic interest for other webgl programs or frameworks that don't want to use luma.gl itself. Since all luma.gl code is MIT licensed you are of course welcome to copy these into your projects should you find them helpful. Canvas Management The canvas manages the default drawing buffer including the size of the default drawing buffer, so the canvas typically needs to be updated when the window resizes getPageLoadPromise Returns a promise that resolves when the page's HTML has loaded (meaning that any canvas specified in the HTML can now be queried by id). createCanvas Programatically creates a canvas element with a certain size and id, and inserts it into the documents body once the page is loaded (see  getPageLoadPromise ). createContext Gives a controlled interface to create a WebGL1 or WebGL2 context from a canvas. GLSL Error Parser formatGLSLError A formatter for parsing errors and warnings from the GLSL compiler. see  parseGLSLError . errLog  (String) - error log (from  gl.getShaderInfoLog ) src  (String) - original shader source code shaderType  (Number) - shader type (GL constant)\nReturn (String) - Formatted string, has the error marked inline with src. parseGLSLError A parse for GLSL compiler error logs. Note that the format of the error logs generated by the GLSL compiler is defined the WebGL spec, so it is possible to portably parse these logs. This function formats each GLSL shader compiler error or warning and generates text showing the source code around the error with marks pointing out where the issue was encountered. errLog  (String) - error log (from  gl.getShaderInfoLog ) src  (String) - original shader source code shaderType  (Number) - shader type (GL constant)\nReturn (object) - with  shaderName ,  errors  and  warnings  fields (all strings). WebGL Constants GL (namespace) All WebGL2 and extension constants exported as a single namespace  GL . Allows constants to be referenced without tracking which version of WebGL or what extensions are available. getKeyValue Resolves a WebGL enumeration  name  (returns itself if already a number) getKeyValue(gl, name) gl  (WebGLRenderingContext) - gl context name  (String) getKeyValue Returns a key that matches the number. getKey(gl, value) gl  (WebGLRenderingContext) - gl context","headings":[{"value":"@luma.gl/webgl","depth":1},{"value":"webgl-utils","depth":1},{"value":"Canvas Management","depth":2},{"value":"getPageLoadPromise","depth":2},{"value":"createCanvas","depth":3},{"value":"createContext","depth":3},{"value":"GLSL Error Parser","depth":2},{"value":"formatGLSLError","depth":3},{"value":"parseGLSLError","depth":3},{"value":"WebGL Constants","depth":2},{"value":"GL (namespace)","depth":3},{"value":"getKeyValue","depth":3},{"value":"getKeyValue","depth":3}],"slug":"modules/webgl","title":"@luma.gl/webgl"},{"excerpt":"Debug Warning: Debug contexts impose a significant performance penalty (due to waiting for the GPU after each WebGL call to check error codes) and should not be used in production builds. luma.gl is pre-integrated with the Khronos group's WebGL debug tools (the  WebGLDeveloperTools ) and can use these to \"instrument\"  WebGLRenderingContext s. The  WebGLDeveloperTools  are automatically installed when luma.gl is installed, but are not actually bundled into the application unless explicitly imported. This avoids impacting the size of production bundles built on luma.gl that typically do not need debug support. To use debug support, first import the debug tools, then call  createGLContext  or  instrumentGLContext  from  @luma.gl/gltools  to create a debug context: If the debug tools haven't been imported, both funcitons will print a warning and simply return the original context, so the debug code can be left in the applicatin even when debug support is not imported. Debug contexts perform the following: Detects WebGL Errors  - Check the WebGL error status after each WebGL call and throws an exception if an error was detected, taking care to extract helpful information into the error message. Checks WebGL Parameters  - Ensure that WebGL parameters are set to valid values.","headings":[{"value":"Debug","depth":1}],"slug":"modules/debug/docs","title":"Debug"},{"excerpt":"AnimationLoop Manages an animation loop and optionally a WebGL context and a WebGL canvas. It provides a number of features related to initialization and animation of a WebGL context. Provides a number of commonly needed variables as part of the  context  object which is passed to  onRender  and  onFinalize  callbacks. Objects returned by  onInitialize  will be appended to  context  object hence available to  onRender  and  onFinalize . To avoid problems with page load timing, move context creation to the  onCreateContext  method. By default,  onRender  method manages resizing of canvas, viewport and framebuffer. Makes it easy to wait for the HTML page to load before creating a canvas and WebGL resources. References: WebGL Fundamentals  contains excellent information on the subtleties of the how the WebGL context's drawing buffer and the HTML canvas interact. When running in the browser, this class uses  requestAnimationFrame Usage Autocreates a canvas/context Use a canvas in the existing DOM through its HTML id Methods constructor(props : Object) props.onCreateContext = null  (callback) - function without parameters that returns a  WebGLRenderingContext . This callback will be called exactly once, after page load completes. props.onInitialize  (callback) - if supplied, will be called once after first  start()  has been called, after page load completes and a context has been created. props.onRender = null  (callback) - Called on every animation frame. props.onFinalize = null  (callback) - Called once when animation is stopped. Can be used to delete objects or free any resources created during  onInitialize . props.onError = null  (callback) - Called when an error is about to be thrown. props.autoResizeViewport = true  - If true, calls  gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight)  each frame before  onRender  is called. Set to false to control viewport size. props.autoResizeDrawingBuffer = true  - If true, checks the canvas size every frame and updates the drawing buffer size if needed. props.useDevicePixels  - Whether to use  window.devicePixelRatio  as a multiplier, e.g. in  autoResizeDrawingBuffer  etc. Refer to  Experimental API  section below for more use cases of this prop. props.gl = null  (WebGLContext) - If supplied, will render into this external context instead of creating a new one. props.glOptions = {}  (object) - Options to create the WebGLContext with. See  createGLContext . props.debug = false  (bool) - Enable debug mode will provide more validations and error messages, but less performant. props.createFramebuffer = false  (bool) - If true, will make a  framebuffer  (FrameBuffer) parameter available to  onInitialize  and  onRender  callbacks. start( options : Object ) : AnimationLoop Restarts the animation animationLoop.start(options) options = {}  (object) - Options to create the WebGLContext with. See  createGLContext . stop() : AnimationLoop Stops the animation animationLoop.stop() waitForRender() : Promise Returns a promise which resolves in the next frame after rendering and the  onRender  callback have completed. redraw() : AnimationLoop Immediately invokes a redraw (call  onRender  with updated animation props). Only use if the canvas must be updated synchronously. setNeedsRedraw(reason : String) : AnimationLoop animationLoop.setNeedsRedraw(reason) reason  ( String ) - A human readable string giving a hint as to why redraw was needed (e.g. \"geometry changed\"). If set, the value will be provided as the  needsRedraw  field to the  onRender  callback. Notes: onRender  will be called for each animation frame regardless of whether this flag is set, and the redraw reason is automatically cleared. If called multiple times, the  reason  provided in the first call will be remembered. AnimationLoop  automatically sets this flag if the WebGL context's drawing buffer size changes. setProps(props : Object) : AnimationLoop animationLoop.setProps({...props}) props.autoResizeViewport  - Call  gl.viewport  before each call to  onRender() props.autoResizeDrawingBuffer  - Update the drawing buffer size to match the canvas size before each call to  onRender() props.useDevicePixels  - Whether to use  window.devicePixelRatio  as a multiplier, e.g. in  autoResizeDrawingBuffer  etc. attachTimeline(timeline: Timeline) Attach an  Timeline  object to the animation loop. Allows time produced for animations to be paused, played, etc. See  Timeline  documentation for more info. detachTimeline() Detach the currently attached timeline from the animation loop. toDataURL Returns returns a  Promise  that resolves to the data URL of the canvas once drawing operations are complete for the current frame. The data URL can be used as the  src  for an HTML image element. animationLoop.toDataURL() isContextLost() Returns the current state of the WebGL context used by the animation loop. Callback Parameters The callbacks  onInitialize ,  onRender  and  onFinalize  that the app supplies to the  AnimationLoop , will be called with an object containing named parameters: Parameter Type Description _animationLoop AnimationLoop ( experimental ) The calling  AnimationLoop  instance gl WebGLRenderingContext This  AnimationLoop 's gl context. canvas HTMLCanvasElement  or  OffscreenCanvas The canvas associated with this context. width The drawing buffer width, in \"device\" pixels (can be different from canvas.width). height The drawing buffer height, in \"device\" pixels (can be different from canvas.width). aspect The canvas aspect ratio (width/height) to update projection matrices useDevicePixels Boolean indicating if canvas is utilizes full resolution of Retina/ needsRedraw String Redraw flag (will be automatically set if drawingBuffer resizes) time Number Milliseconds since  AnimationLoop  was created (monotonic). tick Number Counter that updates for every frame rendered (monotonic). framebuffer FrameBuffer Availabel if  createFrameBuffer: true  was passed to the constructor. _mousePosition [x, y]  or  null ( experimental ) Current mouse position over the canvas. _offScreen Boolean ( experimental ) If the animation loop is rendering to an OffscreenCanvas. _timeline Trimeline ( experimental )  Timeline  object tracking the animation timeline and channels. ... Any fields in the object that was returned by the  onInitialize  method. Frame timers The animation loop tracks GPU and CPU render time of each frame the in member properties  cpuTime  and  gpuTime . If  gpuTime  is set to  -1 , then the timing for the last frame was invalid and should not be used (this rare and might occur, for example, if the GPU was throttled mid-frame). Experimental API ( useDevicePixels ) useDevicePixels  can accept a custom ratio (Number), instead of  true  or  false . This allows rendering to a much smaller or higher resolutions. When using high value (usually more than device pixel ratio), it is possible it can get clamped down, this happens due to system memory limitation, in such cases a warning will be logged to the browser console. For additional details check device pixels  document . Remarks You can instantiate multiple  AnimationLoop  classes in parallel, rendering into the same or different  WebGLRenderingContext s. Works both in browser and under Node.js. All  AnimationLoop  methods can be chained. Postpones context creation until the page (i.e. all HTML) has been loaded. At this time it is safe to specify canvas ids when calling  createGLContext . The supplied callback function must return a WebGLRenderingContext or an error will be thrown. This callback registration function should not be called if a  WebGLRenderingContext  was supplied to the AnimationLoop constructor.","headings":[{"value":"AnimationLoop","depth":1},{"value":"Usage","depth":2},{"value":"Methods","depth":2},{"value":"constructor(props : Object)","depth":3},{"value":"start(options : Object) : AnimationLoop","depth":3},{"value":"stop() : AnimationLoop","depth":3},{"value":"waitForRender() : Promise","depth":3},{"value":"redraw() : AnimationLoop","depth":3},{"value":"setNeedsRedraw(reason : String) : AnimationLoop","depth":3},{"value":"setProps(props : Object) : AnimationLoop","depth":3},{"value":"attachTimeline(timeline: Timeline)","depth":3},{"value":"detachTimeline()","depth":3},{"value":"toDataURL","depth":3},{"value":"isContextLost()","depth":3},{"value":"Callback Parameters","depth":2},{"value":"Frame timers","depth":3},{"value":"Experimental API (useDevicePixels)","depth":2},{"value":"Remarks","depth":2}],"slug":"modules/engine/docs/api-reference/animation-loop","title":"AnimationLoop"},{"excerpt":"Built-in Geometries @luma.gl/engine  provides several built in geometry primitives (subclasses of  Geometry ). The generated geometry instances will have  indices  and  POSITION ,  NORMAL  and  TEXCOORD_0  attributes. ConeGeometry Create a  ConeGeometry  of base radius 2 and height 3. constructor(props : Object) props.radius  ( number ): The radius of the base of the cone. props.cap = false  ( boolean , optional): Whether to put the cap on the base of the cone. props.nradial = 10  ( number ): Number of vertices used to create the disk for a given height. props.nvertical = 10  ( number ): Number of vertices for the height. CubeGeometry CylinderGeometry Create a  CylinderGeometry  of radius 2 and height 3. constructor(props : Object) props.height = - ( number ) The height of the cylinder. props.radius = - ( number ) The radius of the cylinder. props.nradial = 10  - ( number ) The number of vertices for the disk. props.nvertical = 10  - ( number ) The number of vertices for the height. props.verticalAxis = y  - ( string ) The axis along which the height is measured. One of  x ,  y ,  z . props.topCap = false  - ( boolean ) Whether to put the cap on the top of the cylinder. props.bottomCap = false  - ( boolean ) Whether to put the cap on the bottom\npart of the cylinder. IcoSphereGeometry Create an IcoSphereGeometry of radius 1 constructor(props : Object) props.iterations = 0  - ( number ) The number of iterations used to subdivide the Icosahedron. PlaneGeometry Create a XZ plane. constructor(props : Object) props.type  - ( string ) Whether is a XY, YZ or XZ plane. Possible values are  x,y ,  x,z ,  y,z . props.xlen  - ( number ) The length along the x-axis. Only used in  x,z  or  x,y  planes. props.ylen  - ( number ) The length along the y-axis. Only used in  y,z  or  x,y  planes. props.zlen  - ( number ) The length along the z-axis. Only used in  x,z  or  y,z  planes. props.nx  - ( number ) The number of subdivisions along the x-axis. Only used in  x,z  or  x,y  planes. props.ny  - ( number ) The number of subdivisions along the y-axis. Only used in  y,z  or  x,y  planes. props.nz  - ( number ) The number of subdivisions along the z-axis. Only used in  x,z  or  y,z  planes. props.offset  - ( number ) For XZ planes, the offset along the y-axis. For XY planes, the offset along the z-axis. For YZ planes, the offset along the x-axis. SphereGeometry constructor(props : Object) props.nlat = 10  - ( number , optional) The number of vertices for latitude. props.nlong = 10  - ( number , optional) The number of vertices for longitude. props.radius = 1  - ( number , optional) The radius of the sphere.","headings":[{"value":"Built-in Geometries","depth":1},{"value":"ConeGeometry","depth":2},{"value":"constructor(props : Object)","depth":3},{"value":"CubeGeometry","depth":2},{"value":"CylinderGeometry","depth":2},{"value":"constructor(props : Object)","depth":3},{"value":"IcoSphereGeometry","depth":2},{"value":"constructor(props : Object)","depth":3},{"value":"PlaneGeometry","depth":2},{"value":"constructor(props : Object)","depth":3},{"value":"SphereGeometry","depth":2},{"value":"constructor(props : Object)","depth":3}],"slug":"modules/engine/docs/api-reference/geometries","title":"Built-in Geometries"},{"excerpt":"Geometry The Geometry class holds a collection of vertex array attributes representing a geometric primitive. A geometry is considered a \"primitive\" when it can be rendered with a single GPU draw call. Multiple geometry primitives can be composed into a composite geometry using the  Mesh  and  Model  classes. To learn more about attributes refer to the  Accessor  class that holds metadata for each attributes. Usage Create a pyramid geometry (used in lesson 4 of learning WebGL examples). Properties id  - ( string , optional) An id for the model. If not provided, a random unique identifier will be created. drawMode : Number The draw mode, or primitive type. Some options are  GL.TRIANGLES  (default),  GL.TRIANGLE_STRIP ,  GL.POINTS ,  GL.LINES . attributes  - ( object , optional) An object with buffer/attribute names and buffer/attribute descriptors to be set before rendering the model. attributes : Object A map of  Accessor  instances describing the geometry of this primitive. indices : Accessor An optional  Accessor  instance that contains the indices (aka elements) for this geometry. Can be  null  or  undefined  if this primitive doesn't use indices. Note that indices can also be stored inside  attributes . material : Object An object with key/value pairs that indicate how various uniforms should be set up before the GPU draw call. The  Geometry  class itself does not directly use the contents of the  material  field, however other classes such as  Mesh  will refer to it if available, and normally expects it to be set to an instance of the  Material  class. Methods constructor(props : Object) The constructor for the  Geometry  class. Use this to create a new  Geometry . setProps(props : Object) Update properties Types and Enumerations drawMode Follows glTF/OpenGL/WebGL conventions: Value Primitive Mode 0 POINTS 1 LINES 2 LINE_LOOP 3 LINE_STRIP 4 TRIANGLES 5 TRIANGLE_STRIP 6 TRIANGLE_FAN Typical Attributes Attribute Description indices ( array , optional) An array of numbers describing the vertex indices for each face. positions ( array , optional) An array of floats that describe the vertices of the model. normals ( array , optional) An array of floats that describe the normals of the model. texCoords ( mixed , optional) Can be an array of floats indicating the texture coordinates for the texture to be used or an object that has texture ids as keys and an array of floats as values. colors ( array , optional) An array of colors in RGBA. If just one color is specified that color will be used for all faces. pickingColors ( array , optional) A custom set of colors to render the object to texture when performing the color picking algorithm. Remarks The Geometry class does not take a  WebGLRenderingContext  and is intentionally The  Geometry  class holds the  glTF2 \"primitive\" specification , although morph  targets  are not yet supported.","headings":[{"value":"Geometry","depth":1},{"value":"Usage","depth":2},{"value":"Properties","depth":2},{"value":"id - (string, optional)","depth":3},{"value":"drawMode : Number","depth":3},{"value":"attributes - (object, optional)","depth":3},{"value":"attributes : Object","depth":3},{"value":"indices : Accessor","depth":3},{"value":"material : Object","depth":3},{"value":"Methods","depth":2},{"value":"constructor(props : Object)","depth":3},{"value":"setProps(props : Object)","depth":3},{"value":"Types and Enumerations","depth":2},{"value":"drawMode","depth":3},{"value":"Typical Attributes","depth":3},{"value":"Remarks","depth":2}],"slug":"modules/engine/docs/api-reference/geometry","title":"Geometry"},{"excerpt":"Model A  Group  is a subclass of  ScenegraphNode  that holds a reference to a mesh with a transformation matrix that describes its position and orientation. A  Model  holds all the data necessary to draw an object, e.g.: shaders  (via a  Program  instance) uniforms  these can also reference textures. vertex attributes  (holds a  Mesh  or a  Geometry  instance, plus any additional attributes for instanced rendering) The  Model  class also provides the following features: Shader Module integration:  see  Shader Assembly Automatic creation of GPU  Buffer s from typed array attributes Detailed debug logging of draw calls Exposes the functionality provided by the managed WebGL resources Usage Provide attribute data using Geometry object Create model object by passing shaders, uniforms, geometry and render it by passing updated uniforms. Provide attribute data using Buffer When using  Buffer  objects, data remains on GPU and same  Buffer  object can be shared between multiple models. Provide attribute data using VertexArray object A  VertexArray  object can be build and passed to  Model.draw()  to provide attribute data. Attribute data can be changed by changing  VertexArray  object. Properties Model  extends the  BaseModel  class and inherits all properties from that class. moduleSettings: object any uniforms needed by shader modules. uniforms: object uniform values to be used for drawing. onBeforeRender function to be called before every time this model is drawn. onAfterRender function to be called after every time this model is drawn. Deprecated Properties in v7 geometry Geometry  object, from which attributes, vertex count and drawing mode are deduced. isInstanced: boolean default value is false. instanceCount: Number default value is 0. vertexCount: Number when not provided will be deduced from  geometry  object. Constructor Model(gl: WebGLRenderingContext, props: object) The constructor for the Model class. Use this to create a new Model. vs  - (VertexShader| string ) - A vertex shader object, or source as a string. fs  - (FragmentShader| string ) - A fragment shader object, or source as a string. varyings  (WebGL 2) - An array of vertex shader output variables, that needs to be recorded (used in TransformFeedback flow). bufferMode  (WebGL 2) - Mode to be used when recording vertex shader outputs (used in TransformFeedback flow). Default value is  gl.SEPARATE_ATTRIBS . modules  - shader modules to be applied. program  - pre created program to use, when provided, vs, ps and modules are not used. programManager  -  ProgramManager  to use for program creation and caching. transpileToGLSL100  - Transpile vertex and fragment shaders to GLSL 1.0. delete() Free WebGL resources associated with this model Methods setProps(props: object); this Updates properties isAnimated(): boolean Returns  true  if the model is animated (i.e. needs to be redrawn every frame). getProgram(): Program Get model's  Program  instance getUniforms(): object Returns map of currently stored uniforms setUniforms(uniforms: object); this Stores named uniforms {key, value} updateModuleSettings(moduleSettings: object); this draw(options: object): boolean Renders the model with provided uniforms, attributes and samplers Model.draw()  calls  Program.draw()  but adds and extends the available parameters as follows: moduleSettings = null  (Object) - any uniforms needed by shader modules. attributes = {}  (Object) - attribute definitions to be used for drawing. In additions to  Buffer  and constant values,  Model s can also accept typed arrays and attribute descriptor objects which it converts to buffers. uniforms = {}  (Object) - uniform values to be used for drawing. In addition to normal uniform values,  Model  can also accept function valued uniforms which will be evaluated before every draw call. animationProps  (Object) - if any function valued uniforms are set on the  Model ,  animationProps  must be provided to the draw call. The  animationProps  are passed as parameter to the uniform functions. The remaining draw options are passed directly to  Program.draw() : uniforms = {}  (Object) - uniform values to be used for drawing. samplers = {}  (Object) - texture mappings to be used for drawing. parameters = {}  (Object) - temporary gl settings to be applied to this draw call. framebuffer = null  ( Framebuffer ) - if provided, renders into the supplied framebuffer, otherwise renders to the default framebuffer. transformFeedback  - an instance  TranformFeedback  object, that gets activated for this rendering. vertexArray  - an instance of  VertexArray  object, that holds required buffer bindings for vertex shader inputs. transform(options: object); this Renders the model with provided uniforms, and samplers. Calls  Program.draw()  with rasterization turned off. discard = true  (Boolean) - Turns off rasterization feedbackBuffers = null  (Object) - Optional map of feedback buffers. A  TransformFeedback  object will be created, initialized with these buffers, and passed to  Model.draw . unbindModels = []  (Model[]) - Array of models whose VertexAttributes will be temporarily unbound during the transform feeback to avoid triggering a possible  Khronos/Chrome bug .\n. clear(options: object); this Deprecated Methods in v7 render(options: object): boolean Use Model.setUniforms() and Model.draw() getDrawMode(): Enum Gets the WebGL drawMode getVertexCount(): GLInt Gets vertex count Note: might be autocalculated from  Geometry getInstanceCount(): GLInt Defaults to 0 getAttributes(): object Get a map of named attributes setDrawMode(); this Sets the WebGL  drawMode . GL.POINTS  etc. setVertexCount(); this Sets the number of vertices setInstanceCount(); this How many instances will be rendered setGeometry(); this Use a  Geometry  instance to define attribute buffers setAttributes(attributes: object); this Sets map of attributes (passes through to  VertexArray.setAttributes ) Remarks The  Model  class is arguably the most useful class for typical applications. It manages the WebGL resources needed to perform draw calls and provide additional functionality as described below.","headings":[{"value":"Model","depth":1},{"value":"Usage","depth":2},{"value":"Provide attribute data using Geometry object","depth":3},{"value":"Provide attribute data using Buffer","depth":3},{"value":"Provide attribute data using VertexArray object","depth":3},{"value":"Properties","depth":2},{"value":"moduleSettings: object","depth":3},{"value":"uniforms: object","depth":3},{"value":"onBeforeRender","depth":3},{"value":"onAfterRender","depth":3},{"value":"Deprecated Properties in v7","depth":2},{"value":"geometry","depth":3},{"value":"isInstanced: boolean","depth":3},{"value":"instanceCount: Number","depth":3},{"value":"vertexCount: Number","depth":3},{"value":"Constructor","depth":2},{"value":"Model(gl: WebGLRenderingContext, props: object)","depth":3},{"value":"delete()","depth":3},{"value":"Methods","depth":2},{"value":"setProps(props: object); this","depth":3},{"value":"isAnimated(): boolean","depth":3},{"value":"getProgram(): Program","depth":3},{"value":"getUniforms(): object","depth":3},{"value":"setUniforms(uniforms: object); this","depth":3},{"value":"updateModuleSettings(moduleSettings: object); this","depth":3},{"value":"draw(options: object): boolean","depth":3},{"value":"transform(options: object); this","depth":3},{"value":"clear(options: object); this","depth":3},{"value":"Deprecated Methods in v7","depth":2},{"value":"render(options: object): boolean","depth":3},{"value":"getDrawMode(): Enum","depth":3},{"value":"getVertexCount(): GLInt","depth":3},{"value":"getInstanceCount(): GLInt","depth":3},{"value":"getAttributes(): object","depth":3},{"value":"setDrawMode(); this","depth":3},{"value":"setVertexCount(); this","depth":3},{"value":"setInstanceCount(); this","depth":3},{"value":"setGeometry(); this","depth":3},{"value":"setAttributes(attributes: object); this","depth":3},{"value":"Remarks","depth":2}],"slug":"modules/engine/docs/api-reference/model","title":"Model"},{"excerpt":"ProgramManager The  ProgramManager  manages the creation and caching of programs. It allows the application to request a program based on a vertex shader, fragment shader and set of defines, modules and code injections. The  ProgramManager  will return the requested program, creating it the first time, and re-using a cached version if it is requested more than once. It also allows for the definition of hook functions and module code injections to be inserted into shaders. Usage Methods get(opts : Object) : Program Get a program that fits the parameters provided. If one is already cached, return it, otherwise create and cache a new one.\n opts  can include the following (see  assembleShaders  for details): vs : Base vertex shader source. fs : Base fragment shader source. defines : Object indicating  #define  constants to include in the shaders. modules : Array of module objects to include in the shaders. inject : Object of hook injections to include in the shaders. transpileToGLSL100 : Transpile shaders to GLSL 1.0. addDefaultModule(module: Object) Add a module that will automatically be added to any programs created by the program manager. removeDefaultModule(module: Object) Remove a module that is automatically being added to programs created by the program manager. addShaderHook(hook : String, [opts : Object]) Creates a shader hook function that shader modules can injection code into. Shaders can call these functions, which will be no-ops by default. If a shader module injects code it will be executed upon the hook function call. This mechanism allows the application to create shaders that can be automatically extended by included shader modules. hook :  vs:  or  fs:  followed by the name and arguments of the function, e.g.  vs:MYHOOK_func(inout vec4 value) . Hook name without arguments\nwill also be used as the name of the shader hook opts.header  (optional): code always included at the beginning of a hook function opts.footer  (optional): code always included at the end of a hook function getUniforms(program : Program) : Object Returns an object containing all the uniforms defined for the program. Returns  null  if  program  isn't managed by the  ProgramManager . release(program : Program) Indicate that a program is no longer in use. When all references to a program are released, the program is deleted.","headings":[{"value":"ProgramManager","depth":1},{"value":"Usage","depth":2},{"value":"Methods","depth":2},{"value":"get(opts : Object) : Program","depth":3},{"value":"addDefaultModule(module: Object)","depth":3},{"value":"removeDefaultModule(module: Object)","depth":3},{"value":"addShaderHook(hook : String, [opts : Object])","depth":3},{"value":"getUniforms(program : Program) : Object","depth":3},{"value":"release(program : Program)","depth":3}],"slug":"modules/engine/docs/api-reference/program-manager","title":"ProgramManager"},{"excerpt":"Transform (WebGL 2) The  Transform  class provides easy interface to perform Transform Feedback operations on given data. Applications can use this class to move data processing from CPU to GPU, where multiple parallel execution units will be used for processing. Data is handled in form of  Buffer  objects, i.e. data resides in the GPU memory. Output of this class can directly set as attributes on  Model  or  VertexArray  for regular rendering operations, CPU access is not required hence avoids expensive CPU and GPU sync. Transform  class creates and holds  Model  and  TransformFeedback  instances. This class is only supported when using  WebGL2RenderingContext . Use case : Specify source and destination buffers. Create a  Transform  object by passing, vs (vertex shader), source buffer(s), varyings (output variable names in vertex shader) and destination buffers. Then call  run  to perform one transform feedback iteration. Use case : Create destination buffers automatically. Transform  can internally create destination buffers (i.e. feedback buffers), when  feedbackMap  is provided. Each destination buffer is created with same settings and layout as corresponding source buffer as per  feedbackMap . Use case : Multiple iterations using swap(). When  feedbackMap  is specified buffers can be swapped using a single call to  swap() , this is useful for cases like particle simulation, where output of one transform feedback iteration is piped as input to the next iteration. Use case : Update one or more buffers using update() method.. Once  Transform  object is constructed and used, one or more source or destination buffers can be updated using  update . Use case : Reading source data from texture object (Experimental) In addition to reading data from Buffer objects, Transform can read from texture objects. Transform allows to access texture data in the same way as buffer data and internally generates required texture co-ordinates and sample instructions. Use case : Generating a texture object (Experimental) In addition to reading data from a texture object, Transform can generate texture object, by rendering data into it offline. Source data can be either buffer(s), texture(s) or any combination. Constructor Transform(gl : WebGL2RenderingContext, props: Object) Constructs a  Transform  object. It then creates destination buffers if needed and binds the buffers to  Model  and  TransformFeedback  objects. gl  ( WebGL2RenderingContext ) gl - context props.sourceBuffers  ( Object ) - key and value pairs, where key is the name of vertex shader attribute and value is the corresponding  Attribute ,  Buffer  or attribute descriptor object. props.feedbackBuffers  ( Object , Optional) - key and value pairs, where key is the name of vertex shader varying and value is the corresponding  Buffer  object or buffer params object. If a buffer params object is specified, it will contain following fields, these can be used to capture data into the buffer a particular offset and size. buffer =(Buffer) - Buffer object to be bound. byteOffset =(Number, default: 0) - Byte offset that is used to start recording the data in the buffer. byteSize =(Number, default: remaining buffer size) - Size in bytes that is used for recording the data. props.vs  ( String ) - vertex shader string. props.modules  - shader modules to be applied. props.varyings  ( Array ) - Array of vertex shader varyings names. When not provided this can be deduced from  feedbackMap . Either  varyings  or  feedbackMap  must be provided. props.feedbackMap  ( Object , Optional) - key and value pairs, where key is a vertex shader attribute name and value is a vertex shader varying name. props.drawMode  ( GLEnum  = gl.POINTS, Optional) - Draw mode to be set on  Model  and  TransformFeedback  objects during draw/render time. props.elementCount  ( Integer ) - Number set to vertex count when rendering the model. Experimental props._sourceTextures  ( Object ) - key and value pairs, where key is the name of vertex shader attribute and value is the corresponding  Texture2D  object. props._targetTexture  ( Texture2D  or  String ) - Defines texture object that is used as color attachment for rendering. If  Texture2D  object, it is used as is, if  String , it must be one of the source texture attributes name, a new texture object is cloned from corresponding texture and used as color attachment. props._targetTextureVarying  ( String ) : varying name used in vertex shader who's data should go into target texture. props._swapTexture  ( String ) : source texture attribute name, that is swapped with target texture every time  swap()  is called. props._fs  ( String , Optional) - fragment shader string, when rendering to a texture, fragments can be processed using this custom shader, when not specified, pass through fragment shader will be used. Notes: Internally, creates  Model ,  TransformFeedback  and  Framebuffer  instances. delete() : Transform Deletes all owned resources,  Model ,  TransformFeedback  and any  Buffer  objects that are crated internally. Methods getBuffer(varyingName : String) : Buffer Returns current destination buffer corresponding to given varying name. varyingName  ( String ) - varying name. getData( options : Object ) : ArrayBufferView Reads and returns data from current destination buffer corresponding to the given varying name. When no 'varyingName' is provided, it reads and returns data from current target texture. options.varyingName  ( String , Optional) - when specified, first checks if there is a corresponding feedback buffer, if so reads data from this buffer and returns. When not specified, there must be target texture and data is read from this texture and returned. options.packed  (Boolean, Optional, Default: false) - applicable only when reading data from target texture, when true, data is packed to the actual size varyings. When false return array contains 4 values (R, G, B and A) for each element. Un-used element value will be 0 for R, G and B and 1 for A channel. getFramebuffer() : Framebuffer When rendering to a texture, i.e.  _targetTexture  is set,  Transform  class internally setups a  Framebuffer  object.  getFramebuffer()  returns this  Framebuffer  object. run({uniforms : Object, unbindModels : Object}) : Transform Performs one transform feedback iteration. uniforms = null  ( Object  = {}, Optional) - Sets uniforms before rendering. unbindModels = []  (Model[]) - Array of models whose VertexAttributes will be temporarily unbound during the transform feedback to avoid triggering a possible  Khronos/Chrome bug . update(props) : Transform Updates buffer bindings with provided buffer objects for one or more source or destination buffers. props.sourceBuffers  ( Object ) - key and value pairs, where key is the name of vertex shader attribute and value is the corresponding  Attribute ,  Buffer  or attribute descriptor object. props.feedbackBuffers  ( Object , Optional) - key and value pairs, where key is the name of vertex shader varying and value is the corresponding  Buffer  object. props.elementCount  ( Integer , Optional) - Number set to vertex count when rendering the model. If not supplied, the previously set element count is used. swap() : Transform Swaps source and destination buffers and textures. Buffer swapping is performed when  feedbackMap  is provided and texture swapping is performed when  _swapTexture  is provided. If buffer swapping is needed,  sourceBuffers  and  feedbackBuffers  supplied to the constructor and/or the  update  method must be  Buffer  objects. _ getTargetTexture() : Texture2D/null (EXPERIMENTAL) When transform is setup to render to a texture, returns current target texture, otherwise null.","headings":[{"value":"Transform (WebGL 2)","depth":1},{"value":"Use case : Specify source and destination buffers.","depth":3},{"value":"Use case : Create destination buffers automatically.","depth":3},{"value":"Use case : Multiple iterations using swap().","depth":3},{"value":"Use case : Update one or more buffers using update() method..","depth":3},{"value":"Use case : Reading source data from texture object (Experimental)","depth":3},{"value":"Use case : Generating a texture object (Experimental)","depth":3},{"value":"Constructor","depth":2},{"value":"Transform(gl : WebGL2RenderingContext, props: Object)","depth":3},{"value":"Experimental","depth":4},{"value":"delete() : Transform","depth":3},{"value":"Methods","depth":2},{"value":"getBuffer(varyingName : String) : Buffer","depth":3},{"value":"getData(options : Object) : ArrayBufferView","depth":3},{"value":"getFramebuffer() : Framebuffer","depth":3},{"value":"run({uniforms : Object, unbindModels : Object}) : Transform","depth":3},{"value":"update(props) : Transform","depth":3},{"value":"swap() : Transform","depth":3},{"value":"_getTargetTexture() : Texture2D/null (EXPERIMENTAL)","depth":3}],"slug":"modules/engine/docs/api-reference/transform","title":"Transform (WebGL 2)"},{"excerpt":"Caveat Emptor! Modules in  @luma.gl/experimental  are incomplete and not officially supported. Use at your own risk!","headings":[{"value":"Caveat Emptor!","depth":1}],"slug":"modules/experimental/docs/api-reference/warning","title":"Caveat Emptor!"},{"excerpt":"Context Management gltools  provides functions to initialize, instrument and manipulate WebGL contexts. Usage Create a WebGL context, autocreating a canvas Create a WebGL 2 context. Polyfill a WebGL context with features available in extensions. Instrument an externally-created context to work with other luma.gl classes. Functions createGLContext Creates and returns a WebGL context, both in browsers and in Node.js. options  ( Object ) - key/value pairs containing context creation options Parameter Default Description webgl2 true If  true , will attempt to create a WebGL 2 context. Will silently fall back to WebGL 1 contexts unless  webgl1  is set to  false . webgl1 true If  true , will attempt to create a WebGL 1 context. The  webgl2  flag has higher priority. throwOnError true Normally the context will throw an error on failure. If  false , it will log to console instead. break [] Insert a break point ( debugger ) if one of the listed gl functions is called. manageState true Instrument the context to enable state caching and  withParameter  calls. Leave on unless you have special reasons not to. debug false WebGL API calls will be logged to the console and WebGL errors will generate JavaScript exceptions.  NOTE:  requires importing  @luma.gl/debug . onContextLost undefined A handler for webglcontextlost event that is fired if the user agent detects that the drawing buffer associated with a WebGLRenderingContext object has been lost. onContextRestored undefined A handler for webglcontextrestored event that is fired if the user agent restores the drawing buffer for a WebGLRenderingContext object. canvas null A  string  containing the  id  of an existing HTML element or a  DOMElement  instance. If  null  or not provided, a new canvas will be created. alpha true Default render target has an alpha buffer. depth true Default render target has a depth buffer of at least 16 bits. stencil false Default render target has a stencil buffer of at least 8 bits. antialias true Boolean that indicates whether or not to perform anti-aliasing. premultipliedAlpha true Boolean that indicates that the page compositor will assume the drawing buffer contains colors with pre-multiplied alpha. preserveDrawingBuffer false Default render target buffers will not be automatically cleared and will preserve their values until cleared or overwritten failIfMajorPerformanceCaveat false Do not create if the system performance is low. instrumentGLContext Instrument an externally-created context with the same options as  createGLContext . This performs WebGL 2 polyfilling (which is required for higher-level luma.gl classes) as well as optional state tracking and debug context creation. gl  ( Object ) - An externally-created WebGL context. options  ( Object ) - key/value pairs containing context creation options (same as for  createGLContext ). polyfillContext Polyfill a WebGL context integrating available extensions. gl  {WebGLRenderingContext} - A WebGL context resizeGLContext Resize the drawing surface. gl  ( Object ) - A WebGL context. options  ( Object ) - key/value pairs containing resize options. width : New drawing surface width. height : New drawing surface height. useDevicePixels : Whether to scale the drawing surface using the device pixel ratio. getContextDebugInfo Get debug information about a WebGL context. Depends on  WEBGL_debug_renderer_info  extension. getContextDebugInfo(gl) gl  ( Object ) - A WebGL context. Returns (Object): vendor : GPU vendor (unmasked if possible) renderer : Renderer (unmasked if possible) vendorMasked : Masked GPU vendor rendererMasked : Masked renderer version : WebGL version shadingLanguageVersion : shading language version isWebGL Test if an object is a WebGL 1 or 2 context, including correctly identifying a luma.gl debug context (which is not a subclass of a  WebGLRendringContext ). isWebGL(gl) gl  (Object) - Object to test.\nReturns true if the context is a WebGL 1 or 2 Context. isWebGL2 Test if an object is a WebGL 1 or 2 context, including correctly identifying a luma.gl debug context (which is not a subclass of a  WebGL2RendringContext ). isWebGL2(gl) gl  (Object) - Object to test.\nReturns true if the context is a WebGL 2 Context.","headings":[{"value":"Context Management","depth":1},{"value":"Usage","depth":2},{"value":"Functions","depth":2},{"value":"createGLContext","depth":3},{"value":"instrumentGLContext","depth":3},{"value":"polyfillContext","depth":3},{"value":"resizeGLContext","depth":3},{"value":"getContextDebugInfo","depth":3},{"value":"isWebGL","depth":3},{"value":"isWebGL2","depth":3}],"slug":"modules/gltools/docs/api-reference/context","title":"Context Management"},{"excerpt":"Device Pixels Many modern devices support retina or UHD displays can render 2 or 4 times the number of pixels indicated by the CSS dimensions. By rendering to a drawing surface that matches the device and then down sampling it to the smaller (CSS) area, sharper images can be produced but at the cost of rendering more pixels. The  resizeGLContext  function takes a  useDevicePixels  option that can resize the drawing buffer without resizing the the canvas as displayed on the screen. The following functions are provided to simplify calculations between the display size and device size of the drawing buffer: cssToDeviceRatio(gl): Number Returns the ratio of device buffer resolution size to displayed resolution. gl  (WebGLContext) - WebGL context. Returns: ratio (Number). cssToDevicePixels(gl, cssPixel, yInvert) : Object Converts CSS pixel location to Device pixel range. gl  (WebGLContext) - WebGL context. cssPixels  (Array) - Array in  x, y  form, where x and y are location in CSS window. yInvert  (Boolean, optional, default: true) - when true it will perform y-inversion when converting to Device pixels. Returns an Object,  {x, y, width, height}  that represents entire range of device pixels that correspond to given cssPixel location. Following fields define the rectangle. x  (Number): lower x-coordinate y  (Number): lower y-coordinate width  (Number): width in pixels height  (Number): height in pixels\nWhen  devicePixelRatio  is <=1,  width  and  height  are equal to  one , otherwise  width  and  height  are greater than one.","headings":[{"value":"Device Pixels","depth":1},{"value":"cssToDeviceRatio(gl): Number","depth":3},{"value":"cssToDevicePixels(gl, cssPixel, yInvert) : Object","depth":3}],"slug":"modules/gltools/docs/api-reference/device-pixels","title":"Device Pixels"},{"excerpt":"Parameter Setting luma.gl simplifies the usage of WebGL parameters by providing a unified API for setting and getting values. Any GL parameter can be queried or set using  getParameters  and  setParameters  (no need to keep track of what underlying WebGL calls are required), and luma.gl also provide  setting names  that allow the normal WebGL setter functions (like  gl.blendEquation  or  gl.clearColor ) to be specified as keys in a  setParameters  call. In addition, state queries are done towards cached values and are thus much faster than working directly with the WebGL API, where synchronous WebGL queries can be a performance bottleneck. The following functions are provided: getParameters  - Returns the values of some or all GL context parameters setParameters  - Sets a the value(s) of the specified GL context parameters resetParameters  - Resets all gl context parameters to default values Usage Set a global parameter value using a WebGL GLenum Set a global parameter value using a luma.gl setting function name Get all gl parameter values (values will be an object map keyed with parameter names) Set parameters temporarily for a function call (automatically restoring them after the call) Functions getParameters Gets the values of a gl context parameter. gl  {WebGLRenderingContext} - context values = {Object | GLenum[] | null} - parameters, either as keys in object or elements of array. Defaults to all parameters.\nReturns {Object} - object with keys and values corresponding to supplied parameter names and the current values of those parameters. setParameters Sets a number of parameters. gl  {WebGLRenderingContext} - context key  {String} - parameter names, (, either )luma.gl setting name or a GL parameter constants value  { } - parameter value\nReturns { } - \"normalized\" parameter value after assignment Note: If both luma.gl setting names and GL parameter constants representing the same value are submitted the results are undefined. value may be \"normalized\" (in case a short form is supported). In that case the normalized value is returned. resetParameters Resets all gl context parameters to default values. gl  {WebGLRenderingContext} - context\nReturns no value. Note that technically, resetting context parameters does not fully reset the context, as buffer binding, z buffer values etc are not reset. withParameters Executes a function after temporarily setting the parameters. Will restore the parameters to their previously value after the completion of the function, even if the function exits with an exception. gl  {WebGLRenderingContext} - context params  {Object} - any parameter names accepted by  setParameters Returns: the value returned by  func , if any. Parameters Describes luma.gl setting names and values Blending Function style Sets parameter(s) blendColor GL.BLEND_COLOR blendEquation GL.BLEND_EQUATION_RGB ,  GL.BLEND_EQUATION_ALPHA blendFunc GL.BLEND_SRC_RGB ,  GL.BLEND_SRC_ALPHA blendFuncSeparate GL.BLEND_SRC_RGB ,  GL.BLEND_SRC_ALPHA ,  GL.BLEND_DST_RGB ,  GL.BLEND_DST_ALPHA Parameter Type Default Description GL.BLEND GLboolean false Blending enabled GL.BLEND_COLOR Float32Array(4) [0, 0, 0, 0] GL.BLEND_EQUATION_RGB GLenum GL.FUNC_ADD GL.BLEND_EQUATION_ALPHA GLenum GL.FUNC_ADD GL.BLEND_SRC_RGB GLenum GL.ONE srcRgb GL.BLEND_SRC_ALPHA GLenum GL.ZERO srcAlpha GL.BLEND_DST_RGB GLenum GL.ONE dstRgb GL.BLEND_DST_ALPHA GLenum GL.ZERO dstAlpha Clear Color Function Sets parameters clearColor GL.COLOR_CLEAR_VALUE Parameter Type Default Description GL.COLOR_CLEAR_VALUE new Float32Array(4) 0, 0, 0, 0 . Color Mask Function Sets parameters colorMask GL.COLOR_WRITEMASK Parameter Type Default Description GL.COLOR_WRITEMASK GLboolean, GLboolean, GLboolean, GLboolean true, true, true, true . Depth Test Function style Sets parameters clearDepth GL.DEPTH_CLEAR_VALUE depthFunc GL.DEPTH_FUNC depthRange GL.DEPTH_RANGE depthMask GL.DEPTH_WRITEMASK Parameter Type Default Description GL.DEPTH_TEST GLboolean false GL.DEPTH_CLEAR_VALUE GLfloat true GL.DEPTH_FUNC GLenum null GL.DEPTH_RANGE Float32Array(2) null, null  // TBD GL.DEPTH_WRITEMASK GLboolean null Derivative Hints (WebGL 2 or extension) Requires WebGL 2 or  OES_standard_derivatives . Parameter Type Default Description GL.FRAGMENT_SHADER_DERIVATIVE_HINT GLenum GL.DONT_CARE Accuracy of derivates in built-in GLSL functions Hints Value Description GL.FASTEST The most efficient behavior should be used GL.NICEST The most correct or the highest quality option should be used GL.DONT_CARE There is no preference for this behavior Dithering Parameter Type Default Description GL.DITHER GLboolean true Enable dithering of color components before they get written to the color buffer Note: Dithering is driver dependent and typically has a stronger effect when the color components have a lower number of bits. Face Culling Function Sets parameters cullFace GL.CULL_FACE_MODE frontFace GL.FRONT_FACE Parameter Type Default Description GL.CULL_FACE GLboolean false Enable face culling GL.CULL_FACE_MODE GLenum GL.BACK Which face to cull GL.FRONT_FACE GLenum GL.CCW Which face is front Cull Face Modes Value Description GL.FRONT Clock wise GL.BACK Counter clock wise GL.FRONT_AND_BACK No polygons are drawn (but LINES and POINTS are) Face orientation Value Description GL.CW Clock wise GL.CCW Counter clock wise MipmapHint Hint for quality of images generated with glGenerateMipmap Parameter Type Default Description GL.GENERATE_MIPMAP_HINT GLenum GL.DONT_CARE . Mipmap Hints Value Description GL.FASTEST The most efficient behavior should be used GL.NICEST The most correct or the highest quality option should be used GL.DONT_CARE There is no preference for this behavior LineWidth Line widths are between 1 and GL.ALIASED_LINE_WIDTH_RANGE. Function Sets parameters lineWidth GL.LINE_WIDTH Parameter Type Default Description GL.LINE_WIDTH GLfloat 1 . Example: Note: Line widths will be clamped to  1,  GL.ALIASED_LINE_WIDTH_RANGE . This is different from  gl.lineWidth  which generates errors on lineWidth 0. Caution: line aliasing is driver dependent and  GL.LINES  may not give desired results. PolygonOffset Add small offset to fragment depth values (by factor × DZ + r × units)\nUseful for rendering hidden-line images, for applying decals to surfaces,\nand for rendering solids with highlighted edges. Function Sets parameters polygonOffset GL.POLYGON_OFFSET_FACTOR, GL.POLYGON_OFFSET_UNITS Parameter Type Default Description GL.POLYGON_OFFSET_FILL GLboolean false . GL.POLYGON_OFFSET_FACTOR GLfloat 0 . GL.POLYGON_OFFSET_UNITS GLfloat 0 . Note: The semantics of polygon offsets are loosely specified by the WebGL standard and results can thus be driver dependent. Rasterization (WebGL 2) Primitives are discarded immediately before the rasterization stage, but after the optional transform feedback stage.  gl.clear()  commands are ignored. Parameter Type Default Description GL.RASTERIZER_DISCARD GLboolean false Disable rasterization Sampling Specify multisample coverage parameters Function Sets parameters sampleCoverage GL.SAMPLE_COVERAGE_VALUE ,  GL.SAMPLE_COVERAGE_INVERT Parameter Type Default Description GL_SAMPLE_COVERAGE GLboolean false Activates the computation of a temporary coverage value determined by the alpha value. GL_SAMPLE_ALPHA_TO_COVERAGE GLboolean false Activates ANDing the fragment's coverage with the temporary coverage value GL.SAMPLE_COVERAGE_VALUE GLfloat 1.0 GL.SAMPLE_COVERAGE_INVERT GLboolean false Scissor Test Settings for scissor test and scissor box. Function Sets parameters scissor GL.SCISSOR_BOX scissorTest GL.SCISSOR_TEST Parameter Type Default Description GL.SCISSOR_TEST GLboolean false GL.SCISSOR_BOX Int32Array(4) null, null, null, null ), // TBD Stencil Test Setting any value will enable stencil testing (i.e. enable  GL.STENCIL_TEST ). Function Parameters Set clearStencil GL.STENCIL_CLEAR_VALUE stencilMask GL.STENCIL_WRITEMASK stencilMaskSeparate GL.STENCIL_WRITEMASK ,  GL.STENCIL_BACK_WRITEMASK stencilFunc GL.STENCIL_FUNC ,  GL.STENCIL_REF ,  GL.STENCIL_VALUE_MASK stencilFuncSeparate GL.STENCIL_FUNC ,  GL.STENCIL_REF ,  GL.STENCIL_VALUE_MASK ,  GL.STENCIL_BACK_FUNC ,  GL.STENCIL_BACK_REF ,  GL.STENCIL_BACK_VALUE_MASK   stencilOp GL.STENCIL_FAIL ,  GL.STENCIL_FAIL_DEPTH_FAIL ,  GL.STENCIL_FAIL_DEPTH_PASS stencilOpSeparate GL.STENCIL_FAIL ,  GL.STENCIL_FAIL_DEPTH_FAIL ,  GL.STENCIL_FAIL_DEPTH_PASS ,  GL.STENCIL_BACK_FAIL ,  GL.STENCIL_BACK_FAIL_DEPTH_FAIL ,  GL.STENCIL_BACK_FAIL_DEPTH_PASS Parameter Type Default Description GL.STENCIL_TEST GLboolean false Enables stencil testing GL.STENCIL_CLEAR_VALUE GLint 0 Sets index used when stencil buffer is cleared. GL.STENCIL_WRITEMASK GLuint 0xFFFFFFFF Sets bit mask enabling writing of individual bits in the stencil planes GL.STENCIL_BACK_WRITEMASK GLuint 0xFFFFFFFF Sets bit mask enabling writing of individual bits in the stencil planes GL.STENCIL_FUNC GLenum GL.ALWAYS GL.STENCIL_REF GLint 0 GL.STENCIL_VALUE_MASK GLuint 0xFFFFFFFF Sets bit mask GL.STENCIL_BACK_FUNC GLenum GL.ALWAYS GL.STENCIL_BACK_REF GLint 0 GL.STENCIL_BACK_VALUE_MASK GLuint 0xFFFFFFFF Sets bit mask enabling writing of individual bits in the stencil planes GL.STENCIL_FAIL GLenum GL.KEEP stencil test fail action GL.STENCIL_PASS_DEPTH_FAIL GLenum GL.KEEP depth test fail action GL.STENCIL_PASS_DEPTH_PASS GLenum GL.KEEP depth test pass action GL.STENCIL_BACK_FAIL GLenum GL.KEEP stencil test fail action, back GL.STENCIL_BACK_PASS_DEPTH_FAIL GLenum GL.KEEP depth test fail action, back GL.STENCIL_BACK_PASS_DEPTH_PASS GLenum GL.KEEP depth test pass action, back Stencil Test Functions Values for  GL.STENCIL_TEST Value Description GL.NEVER Never pass GL.LESS Pass if (ref & mask) < (stencil & mask) GL.EQUAL Pass if (ref & mask) = (stencil & mask) GL.LEQUAL Pass if (ref & mask) <= (stencil & mask) GL.GREATER Pass if (ref & mask) > (stencil & mask) GL.NOTEQUAL Pass if (ref & mask) != (stencil & mask) GL.GEQUAL Pass if (ref & mask) >= (stencil & mask) GL.ALWAYS Always pass Stencil Operations Value Description GL.KEEP Keeps the current value GL.ZERO Sets the stencil buffer value to 0 GL.REPLACE Sets the stencil buffer value to the reference value as specified by  stencilFunc GL.INCR Increments the current stencil buffer value. Clamps to the maximum representable unsigned value GL.INCR_WRAP Increments the current stencil buffer value. Wraps to zero when incrementing the maximum representable unsigned value GL.DECR Decrements current stencil buffer value. Clamps to 0 GL.DECR_WRAP Decrements current stencil buffer value, wraps to maximum unsigned value when decrementing 0 GL.INVERT Inverts the current stencil buffer value bitwise Action when the stencil test fails, front and back. stencil test fail action, depth test fail action, pass action Viewport Specifies the transformation from normalized device coordinates to\nwindow/framebuffer coordinates. The maximum supported value, is defined by the\n GL.MAX_VIEWPORT_DIMS  limit. Function Parameters viewport GL.VIEWPORT Parameter Type Default Description GL.VIEWPORT Int32Array(4) ...  TBD Viewport Example: Pixel Pack/Unpack Modes Specifies how bitmaps are written to and read from memory Parameter Type Default Description GL.PACK_ALIGNMENT GLint 4 Byte alignment of pixel row data in memory (1,2,4,8 bytes) when storing data GL.UNPACK_ALIGNMENT GLint 4 Byte alignment of pixel row data in memory (1,2,4,8 bytes) when reading data GL.UNPACK_FLIP_Y_WEBGL GLboolean false Flip source data along its vertical axis GL.UNPACK_PREMULTIPLY_ALPHA_WEBGL GLboolean false Multiplies the alpha channel into the other color channels GL.UNPACK_COLORSPACE_CONVERSION_WEBGL GLenum GL.BROWSER_DEFAULT_WEBGL Use default or no color space conversion. Pixel Pack/Unpack Modes  WebGL 2 Specifies how bitmaps are written to and read from memory Parameter Type Default Description GL.PACK_ROW_LENGTH GLint 0 Number of pixels in a row GL.PACK_SKIP_PIXELS GLint 0 Number of pixels skipped before the first pixel is written into memory GL.PACK_SKIP_ROWS GLint 0 Number of rows of pixels skipped before first pixel is written to memory GL.UNPACK_ROW_LENGTH GLint 0 Number of pixels in a row. GL.UNPACK_IMAGE_HEIGHT GLint 0 Image height used for reading pixel data from memory GL.UNPACK_SKIP_PIXELS GLint 0 Number of pixel images skipped before first pixel is read from memory GL.UNPACK_SKIP_ROWS GLint 0 Number of rows of pixels skipped before first pixel is read from memory GL.UNPACK_SKIP_IMAGES GLint 0 Number of pixel images skipped before first pixel is read from memory Remarks WebGL State Management can be quite complicated. A large part of the WebGL API is devoted to parameters. When reading, querying individual values using GL constants is the norm, and when writing, special purpose functions are provided for most parameters. luma.gl supports both forms for both reading and writing parameters. Reading values from WebGL can be very slow if it requires a GPU roundtrip. To get around this, luma.gl reads values once, caches them and tracks them as they are changed through luma functions. The cached values can get out of sync if the context is shared outside of luma.gl. luma.gl's state management enables \"conflict-free\" programming, so that even when setting global state, one part of the code does not need to worry about whether other parts are changing the global state. Note that to fully support the conflict-free model and detect changes done e.g. in other WebGL libraries, luma.gl needs to hook into the WebGL context to track state changes.","headings":[{"value":"Parameter Setting","depth":1},{"value":"Usage","depth":2},{"value":"Functions","depth":2},{"value":"getParameters","depth":3},{"value":"setParameters","depth":3},{"value":"resetParameters","depth":3},{"value":"withParameters","depth":3},{"value":"Parameters","depth":2},{"value":"Blending","depth":3},{"value":"Clear Color","depth":3},{"value":"Color Mask","depth":3},{"value":"Depth Test","depth":3},{"value":"Derivative Hints (WebGL 2 or extension)","depth":3},{"value":"Hints","depth":4},{"value":"Dithering","depth":3},{"value":"Face Culling","depth":3},{"value":"Cull Face Modes","depth":4},{"value":"Face orientation","depth":4},{"value":"MipmapHint","depth":3},{"value":"Mipmap Hints","depth":4},{"value":"LineWidth","depth":3},{"value":"PolygonOffset","depth":3},{"value":"Rasterization (WebGL 2)","depth":3},{"value":"Sampling","depth":3},{"value":"Scissor Test","depth":3},{"value":"Stencil Test","depth":3},{"value":"Stencil Test Functions","depth":4},{"value":"Stencil Operations","depth":4},{"value":"Viewport","depth":2},{"value":"Pixel Pack/Unpack Modes","depth":2},{"value":"Pixel Pack/Unpack Modes WebGL 2","depth":2},{"value":"Remarks","depth":2}],"slug":"modules/gltools/docs/api-reference/parameter-setting","title":"Parameter Setting"},{"excerpt":"Shader Assembly luma.gl's module shader system is primarily exposed via the function  assembleShaders  which composes base vertex and fragment shader source with shader modules, hook functions and injections to generate the final vertex and fragment shader source that can be used to create a program. assembleShaders Takes the source code of a vertex shader and a fragment shader, and a list of modules, defines, etc. Outputs resolved source code for both shaders, after adding prologue, adding defines, importing and transpiling modules, and injecting any shader fragments). vs  - vertex shader source fs  - fragment shader source code id  -  id  for the shader, will be used to inject shader names (using  #define SHADER_NAME ) if not already present in the source. prologue = true  (Boolean) - Will inject platform prologue (see below) defines = {}  (Object) - a map of key/value pairs representing custom  #define s to be injected into the shader source modules = []  (Array) - list of shader modules (either objects defining the module, or names of previously registered modules) inject = {}  (Object) - map of substituions, hookFunctions = []  Array of hook functions descriptions. Descriptions can simply be the hook function signature (with a prefix  vs  for vertex shader, or  fs  for fragment shader) or an object with the hook signature, and a header and footer that will always appear in the hook function. For example: transpileToGLSL100 : force transpilation to GLSL ES 1.0 (see below) Returns: vs  - the resolved vertex shader fs  - the resolved fragment shader getUniforms  - a combined  getUniforms  function covering all modules. moduleMap  - a map with all resolved modules, keyed by name Shader Hooks and Module Injections Shader hooks and module injections are a system that allows for shader to be written in a generic manner, with behaviour modified when modules are included. For example if we define a shader hook as  fs:MY_HOOK_FUNCTION(inout vec4 color) ,  assembleShader  will inject the following function automatically into our fragment shader: We can the write our fragment shader as follows: By default, the hook function is a no-op, so this doesn't do anything. However, if we add a module injection like the following: And pass the  picking  module to  assembledShaders , the hook function will be updated as follows: The hook function now changes the color from white to red. Constants and Values Predefined Injection Hooks Key Shader Description vs:#decl Vertex Inject at top of shader (declarations) vs:#main-start Vertex Injected at the very beginning of main function vs:#main-end Vertex Injected at the very end of main function fs:#decl Fragment Inject at top of shader (declarations) fs:#main-start Fragment Injected at the very beginning of main function fs:#main-end Fragment Injected at the very end of main function NOTE : Injections assume that the  main  function appears last in a shader. Usage Injection Map assembleShaders  (and  Model  constructor) will take an  inject  argument that contains a map of: keys indicating hooks (predefined or functions) values representing code to be injected. This can be either a simple string or an object containing the  injection  string and an  order  indicating its priority. Examples: Transpilation If the  transpileToGLSL100  option is used,  assembleShaders  will attempt to transpile shaders to GLSL ES 1.0. This is a limited text replacement and requires that certain conventions be followed: Statements are written one per line. Only one fragment shader output is supported. GLSL 3.0-only features, such as 3D textures are not supported. Text transformations are performed according to the following tables: Vertex Shaders 3.00 ES 1.00 ES Comment in attribute out varying Fragment Shaders 3.00 ES 1.00 ES Comment in varying out vec4 <varName> gl_FragColor <varName>  declaration is removed and usage in the code are replaced with  gl_FragColor texture texture2D texture  will be replaced with  texture2D  to ensure 1.00 code is correct. See note on  textureCube  below. textureCube   * textureCube textureCube  is not valid 3.00 syntax, but must be used to ensure 1.00 code is correct, because  texture  will be substituted with  texture2D  when transpiled to 100. Also  textureCube  will be replaced with correct  texture  syntax when transpiled to 300.","headings":[{"value":"Shader Assembly","depth":1},{"value":"assembleShaders","depth":3},{"value":"Shader Hooks and Module Injections","depth":2},{"value":"Constants and Values","depth":2},{"value":"Predefined Injection Hooks","depth":3},{"value":"Usage","depth":2},{"value":"Injection Map","depth":3},{"value":"Transpilation","depth":2}],"slug":"modules/shadertools/docs/api-reference/assemble-shaders","title":"Shader Assembly"},{"excerpt":"Core Shader Modules picking Provides support for color-coding-based picking. In particular, supports picking a specific instance in an instanced draw call. Color based picking lets the application draw a primitive with a color that can later be used to index this specific primitive. Usage In your vertex shader, your inform the picking module what object we are currently rendering by supplying a picking color, perhaps from an attribute. In your fragment shader, you simply apply (call) the  picking_filterPickingColor  filter function at the very end of the shader. This will return the normal color, or the highlight color, or the picking color, as appropriate. If you would like to apply the highlight color to the currently selected element call  picking_filterHighlightColor  before calling  picking_filterPickingColor . You can also apply other filters on the non-picking color (vertex or highlight color) by placing those instruction between these two function calls. JavaScript Functions getUniforms getUniforms  returns an object with key/value pairs representing the uniforms that the  picking  module shaders need. getUniforms({pickingActive, ...}) pickingActive = false  ( boolean ) - Renders the picking colors instead of the normal colors. Normally only used with an off-screen framebuffer during picking. pickingSelectedColor = null  ( array|null ) - The picking color of the selected (highlighted) object. pickingHighlightColor =  [0, 255, 255, 255]  ( array ) - Color used to highlight the currently selected object. pickingAttribute = false  ( boolean ) - Renders a color that encodes an attribute value. Normally only used with an off-screen framebuffer during picking. Vertex Shader Functions picking_setPickingColor Sets the color that will be returned by the fragment shader if color based picking is enabled. Typically set from a  pickingColor  uniform or a  pickingColors  attribute (e.g. when using instanced rendering, to identify the actual instance that was picked). void picking_setPickingColor(vec3 pickingColor) picking_setPickingAttribute Sets the attribute value that needs to be picked. void picking_setPickingAttribute(float value) \n void picking_setPickingAttribute(vec2 value) \n void picking_setPickingAttribute(vec3 value) Fragment Shader Functions picking_filterPickingColor If picking active, returns the current vertex's picking color set by  picking_setPickingColor , otherwise returns its argument unmodified. vec4 picking_filterPickingColor(vec4 color) picking_filterHighlightColor Returns picking highlight color if the pixel belongs to currently selected model, otherwise returns its argument unmodified. vec4 picking_filterHighlightColor(vec4 color) Remarks It is strongly recommended that  picking_filterPickingColor  is called last in a fragment shader, as the picking color (returned when picking is enabled) must not be modified in any way (and alpha must remain 1) or picking results will not be correct.","headings":[{"value":"Core Shader Modules","depth":1},{"value":"picking","depth":2},{"value":"Usage","depth":3},{"value":"JavaScript Functions","depth":3},{"value":"getUniforms","depth":4},{"value":"Vertex Shader Functions","depth":3},{"value":"picking_setPickingColor","depth":4},{"value":"picking_setPickingAttribute","depth":4},{"value":"Fragment Shader Functions","depth":3},{"value":"picking_filterPickingColor","depth":4},{"value":"picking_filterHighlightColor","depth":4},{"value":"Remarks","depth":3}],"slug":"modules/shadertools/docs/api-reference/core-shader-modules","title":"Core Shader Modules"},{"excerpt":"Effects Shader Modules Screen space effects packaged as reusable shader modules in  @luma.gl/shadertools  based on the  glfx library . Attribution / License This is a repackaging of shader code from  Evan Wallace 's glfx library. The code and documentation is included here under MIT license. Usage Import brightnessContrast shader module Shader Modules brightnessContrast Provides additive brightness and multiplicative contrast control. brightness  -1 to 1 (-1 is solid black, 0 is no change, and 1 is solid white). Default value is  0 . contrast  -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast). Default value is  0 . hueSaturation Provides rotational hue and multiplicative saturation control. RGB color space can be imagined as a cube where the axes are the red, green, and blue color values. Hue changing works by rotating the color vector around the grayscale line, which is the straight line from black (0, 0, 0) to white (1, 1, 1). Saturation is implemented by scaling all color channel values either toward or away from the average color channel value. hue  -1 to 1 (-1 is 180 degree rotation in the negative direction, 0 is no change, and 1 is 180 degree rotation in the positive direction). Default value is  0 . saturation  -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast). Default value is  0 . noise Adds black and white noise to the image. amount  0 to 1 (0 for no effect, 1 for maximum noise). Default value is  0.5 . sepia Gives the image a reddish-brown monochrome tint that imitates an old photograph. amount  0 to 1 (0 for no effect, 1 for full sepia coloring). Default value is  0.5 . vibrance Modifies the saturation of desaturated colors, leaving saturated colors unmodified. amount  -1 to 1 (-1 is minimum vibrance, 0 is no change, and 1 is maximum vibrance). Default value is  0 . vignette Adds a simulated lens edge darkening effect. size  0 to 1 (0 for center of frame, 1 for edge of frame). Default value is  0.5 . amount  0 to 1 (0 for no effect, 1 for maximum lens darkening). Default value is  0.5 . tiltShift Simulates the shallow depth of field normally encountered in close-up photography, which makes the scene seem much smaller than it actually is. This filter assumes the scene is relatively planar, in which case the part of the scene that is completely in focus can be described by a line (the intersection of the focal plane and the scene). An example of a planar scene might be looking at a road from above at a downward angle. The image is then blurred with a blur radius that starts at zero on the line and increases further from the line. start   x, y  coordinate of the start of the line segment.  [0, 0]  is the bottom left corner,  [1, 1]  is the up right corner. Default value is  [0, 0] . end   x, y  coordinate of the end of the line segment.  [0, 0]  is the bottom left corner,  [1, 1]  is the up right corner. Default value is  [1, 1] . blurRadius  The maximum radius of the pyramid blur in pixels. Default value is  15 . gradientRadius  The distance in pixels from the line at which the maximum blur radius is reached. Default value is  200 . triangleBlur This is the most basic blur filter, which convolves the image with a pyramid filter. The pyramid filter is separable and is applied as two perpendicular triangle filters. radius  The radius of the pyramid in pixels convolved with the image. Default value is  20 . zoomBlur Blurs the image away from a certain point, which looks like radial motion blur. center   x, y  coordinate of the blur origin.  [0, 0]  is the bottom left corner,  [1, 1]  is the up right corner. Default value is  [0.5, 0.5] . strength  The strength of the blur. Values in the range 0 to 1 are usually sufficient, where 0 doesn't change the image and 1 creates a highly blurred image. Default value is  0.3 . colorHalftone Simulates a CMYK halftone rendering of the image by multiplying pixel values with a four rotated 2D sine wave patterns, one each for cyan, magenta, yellow, and black. center   x, y  coordinate of the pattern origin.  [0, 0]  is the bottom left corner,  [1, 1]  is the up right corner. Default value is  [0.5, 0.5] . angle  The rotation of the pattern in radians. Default value is  1.1 . size  The diameter of a dot in pixels. Default value is  4 . dotScreen Simulates a black and white halftone rendering of the image by multiplying pixel values with a rotated 2D sine wave pattern. center   x, y  coordinate of the pattern origin.  [0, 0]  is the bottom left corner,  [1, 1]  is the up right corner. Default value is  [0.5, 0.5] . angle  The rotation of the pattern in radians. Default value is  1.1 . size  The diameter of a dot in pixels. Default value is  3 . edgeWork Picks out different frequencies in the image by subtracting two copies of the image blurred with different radii. radius  The radius of the effect in pixels. Default value is  2 . hexagonalPixelate Renders the image using a pattern of hexagonal tiles. Tile colors are nearest-neighbor sampled from the centers of the tiles. center   x, y  coordinate of the pattern center.  [0, 0]  is the bottom left corner,  [1, 1]  is the up right corner. Default value is  [0.5, 0.5] . scale  The width of an individual tile in pixels. Default value is  10 . ink Simulates outlining the image in ink by darkening edges stronger than a certain threshold. The edge detection value is the difference of two copies of the image, each blurred using a blur of a different radius. strength  The multiplicative scale of the ink edges. Values in the range 0 to 1 are usually sufficient, where 0 doesn't change the image and 1 adds lots of black edges. Negative strength values will create white ink edges instead of black ones. Default value is  0.25 . bulgePinch Bulges or pinches the image in a circle. center   x, y  coordinate of the center of the circle of effect.  [0, 0]  is the bottom left corner,  [1, 1]  is the up right corner. Default value is  [0.5, 0.5] . radius  The radius of the circle of effect in pixels. Default value is  200 . strength  -1 to 1 (-1 is strong pinch, 0 is no effect, 1 is strong bulge). Default value is  0.5 . swirl Warps a circular region of the image in a swirl. center   x, y  coordinate of the center of the circular region.  [0, 0]  is the bottom left corner,  [1, 1]  is the up right corner. Default value is  [0.5, 0.5] . radius  The radius of the circular region in pixels. Default value is  200 . angle  The angle in radians that the pixels in the center of the circular region will be rotated by. Default value is  3 . magnify Apply magnify effect to the surrounding area of a given position. screenXY : x, y position in screen coords, both x and y is normalized and in range  [0, 1] .  [0, 0]  is the up left corner,  [1, 1]  is the bottom right corner. Default value is  [0, 0] . radiusPixels : effect radius in pixels. Default value is  100 . zoom : magnify level. Default value is  2 . borderWidthPixels : border width of the effect circle, will not show border if value <= 0.0. Default value is  0 . borderColor : border color of the effect circle. Default value is  [255, 255, 255, 255] . Remarks Coordinate is based on the original image.  [0, 0]  is the bottom left corner,  [1, 1]  is the up right corner.","headings":[{"value":"Effects Shader Modules","depth":1},{"value":"Attribution / License","depth":2},{"value":"Usage","depth":2},{"value":"Shader Modules","depth":2},{"value":"brightnessContrast","depth":3},{"value":"hueSaturation","depth":3},{"value":"noise","depth":3},{"value":"sepia","depth":3},{"value":"vibrance","depth":3},{"value":"vignette","depth":3},{"value":"tiltShift","depth":3},{"value":"triangleBlur","depth":3},{"value":"zoomBlur","depth":3},{"value":"colorHalftone","depth":3},{"value":"dotScreen","depth":3},{"value":"edgeWork","depth":3},{"value":"hexagonalPixelate","depth":3},{"value":"ink","depth":3},{"value":"bulgePinch","depth":3},{"value":"swirl","depth":3},{"value":"magnify","depth":3},{"value":"Remarks","depth":2}],"slug":"modules/shadertools/docs/api-reference/effects-shader-modules","title":"Effects Shader Modules"},{"excerpt":"SnapshotTestRunner Client-side utility for browser-based WebGL render tests. This class is intended to be used with  BrowserTestDriver  from  @probe.gl/test-utils . Together they support the following workflow: Launch a Puppeteer instance (headless or non-headless) to run a test application In the test application, create a canvas and  WebGLContext . For each test case, render something to the  WebGLContext , take a screenshot, and perform pixel-diffing with a pre-defined \"golden image\". Report the matching result. Proceed to the next test case until done. Example In your node.js start script: In your script that is run on the browser: Methods constructor(props: Object) Create a SnapshotTestRunner instance. The  props  argument is forwarded to the  AnimationLoop  constructor. add(testCase: Array|Object) Add one or a list of test cases. Each test case may contain the following fields: name  (String) - name of the test case. goldenImage  (String) - path to the golden image, relative to the root where the node script is executed. timeout  (Number) - time to wait for this test case to resolve (by calling the  done  callback) before aborting, in milliseconds. If not provided, fallback to the shared option that is passed to  SnapshotTestRunner.run . imageDiffOptions  (Object) - image diffing options for this test case. See \"Image Diff Options\" section below. onInitialize  (Function) - called once when the test case starts. Receives a single object that is the  AnimationLoop callback parameters . If this callback returns an object or a promise, the content that it resolves to will be passed to  onRender  and  onFinalize  later. onRender  (Function) - called every animation frame when the test case is running. Receives a single object that is the  AnimationLoop callback parameters , plus the following: done  (Function) - must be called when the test case is done rendering and ready for screen capture and comparison. onFinalize  (Function) - called once when the test case is done to finalize all resources. Receives a single object that is the  AnimationLoop callback parameters . run(options: Object) Run all test cases. Options: timeout  (Number) - time to wait for each test case to resolve (by calling the  done  callback) before aborting, in milliseconds. Default  2000 . imageDiffOptions  (Object) - image diffing options for all test cases. This will be overridden if a test case defines its own  imageDiffOptions . See \"Image Diff Options\" section below. onTestStart  (Function) - callback when a test starts. Receives the current test case. Default logs the test name to console. onTestPass  (Function) - callback when a test passes. Receives the current test case and the diffing result. Default logs the pixel matching percentage to console. onTestFail  (Function) - callback when a test fails, either because the matching rate is below threshold or a critical error. Receives the current test case. Default logs the error message or the pixel matching percentage to console. Returns: a  Promise  that resolves when all test cases are done. Members isHeadless Whether the test is being run in headless mode. In headless mode, Chromium uses software render which behaves slightly differently from non-headless. Image diffing tolerance may need to be adjusted accordingly. Image Diff Options The test renderer and each test case may choose to override the default image diffing options. The following options from  captureAndDiffScreen  are supported: tolerance threshold includeAA createDiffImage saveOnFail saveAs","headings":[{"value":"SnapshotTestRunner","depth":1},{"value":"Example","depth":2},{"value":"Methods","depth":2},{"value":"constructor(props: Object)","depth":3},{"value":"add(testCase: Array|Object)","depth":3},{"value":"run(options: Object)","depth":3},{"value":"Members","depth":2},{"value":"isHeadless","depth":3},{"value":"Image Diff Options","depth":2}],"slug":"modules/test-utils/docs/api-reference/snapshot-test-runner","title":"SnapshotTestRunner"},{"excerpt":"Accessor The  Accessor  class is a helper class that describes how a buffers memory is structured and should be accessed. Accessors are used. The type of values, number of values per element, any offset and strides, etc. as well as some additional parameters relating to how the GPU should access buffer data (instance divisors, integer normalization etc). By using multiple  Accessor  instances, the application can defined different \"views\" of the data in a single buffer. Accessors are immutable by design. Once they have been created they cannot be changed. Accessors can be resolved (merged) into a new Accessor. This is useful since while some accessor properties can be extracted directly from a program's shaders (and some can be extracted when data is set to the buffer), some properties needs to be set by the application. Properties Property Category Auto Deduce Default Comment offset data layout N/A 0 Byte offset to start of data in buffer stride data layout N/A 0 Extra bytes between each successive data element type data type Vertex Shader/ Buffer.setData GL.FLOAT Low level data type ( GL.BYTE ,  GL.SHORT , ...) size data type Vertex Shader 1 Components per element ( 1 - 4 ) divisor instancing Attribute name 0 Enables/disables instancing normalize data access N/A false Normalize integers to  -1,1 , or  0,1  if unsigned integer data access N/A false Disable conversion of integer values to floats  WebGL 2 Notes: type  and  size  values for attributes are read from the shaders when a program is created and linked, and normally do not need to be supplied. Also any attribute with  instance  in its name will automatically be given an instance divisor of  1 . divisor  is automatically set to  1  for any attribute that has some capitalization of  instance  in the name. offset  and  stride  are typically used to interleave data in buffers and are normally left undefined (i.e.  0 ). normalize  and  integer  need to be enabled by applications through an  Accessor . offset Byte offset to start of data in buffer stride type Low level data type (GL.BYTE, GL.SHORT, GL.FLOAT, GL.INT, ...) size Number of (1-4 values per vertex) divisor : Number Enables/disables instancing. normalize If  true  normalizes integer values ( GL.BYTE , ...). Signed values are normalized to  -1,1  and unsigned values are normalized to  0,1 . integer   WebGL 2 Disable conversion of integer values to floats. Static Methods Accessor.merge(accessor1, accessor2, ...) : Accessor Merges a number of partial accessors into a merged accessor that can be used to set vertex attributes. Any unspecified accessor properties will be set to their default values. Note: Most applications do not need to merge accessors directly. Merging is done by the  VertexArray.setAttributes  method. Methods constructor(props : Object) Creates a new partial  Accessor . The new object will be immutable, i.e. its values cannot be changed after creation. BYTES_PER_ELEMENT  : Number Returns the number of bytes per \"element\", based on the  type  field in the accessor. Asserts if type is not set. BYTES_PER_VERTEX  : Number Returns the number of bytes per \"vertex\", based on the  type  and  size  fields in the accessor. Asserts if  type  and  size  are not set. Remarks: Auto-deduction type  and  size  are automatically inferred (through WebGL APIs that provide access to metadata extracted during compilation and linking of shader programs). divisor  - if attribute name starts with  instance...  this will be automatically set to  1 . offset  and  stride  are assumed to be 0 which corresponds to the simple non-interleaved case. integer  - if type is  GL.INT  or  GL.UINT , then integer is automatically true, as floating point shader inputs cannot be mapped to such attributes.","headings":[{"value":"Accessor","depth":1},{"value":"Properties","depth":2},{"value":"offset","depth":3},{"value":"stride","depth":3},{"value":"type","depth":3},{"value":"size","depth":3},{"value":"divisor: Number","depth":3},{"value":"normalize","depth":3},{"value":"integer WebGL 2","depth":3},{"value":"Static Methods","depth":2},{"value":"Accessor.merge(accessor1, accessor2, ...) : Accessor","depth":3},{"value":"Methods","depth":2},{"value":"constructor(props : Object)","depth":3},{"value":"BYTES_PER_ELEMENT : Number","depth":3},{"value":"BYTES_PER_VERTEX : Number","depth":3},{"value":"Remarks: Auto-deduction","depth":2}],"slug":"modules/webgl/docs/api-reference/accessor","title":"Accessor"},{"excerpt":"Buffer A  Buffer  is a WebGL object that stores an chunk of memory allocated by the GPU. This memory can be accessed directly by the GPU and is used to store things like vertex data, pixel data retrieved from images or the framebuffer, etc. The  Buffer  class provides mechanism for allocating such memory, together with facilities for copying data to and from the GPU (usually via JavaScript typed arrays). For additional information, see  OpenGL Wiki . Usage Creating a generic buffer Creating an elements buffer Allocating memory in a buffer Allocating and initializing a buffer Updating a buffer Copying data between buffers (WebGL 2) Getting data from a buffer (WebGL 2) Members handle  :  WebGLBuffer Holds the underlying WebGL object reference. byteLength  : Number Number of bytes of allocated memory. bytesUsed  : Number Same as  byteLength  unless the  Buffer.reallocate  has been called with a value smaller than the actual length of the buffer. accessor  :  Accessor Holds an  Accessor  instance. By default it contains type information that is automatically deducted from the type of data used to initialize the buffer, but the application can store any  Accessor  it wants with the  Buffer . This can simplify handling of buffer related data in many basic use cases (e.g. when buffers are not shared by multiple attributes etc). Constructor Buffer(gl : WebGLRenderingContext, props : Object | TypedArray | Number) Creates a new  Buffer . Multiple signatures are supported: gl  ( WebGLRenderingContext ) - gl context target = ( GLenum , optional) - the type of buffer, see below. ...initOptions  ( Object ) - options passed on to  initialize . accessor  - options used to create the  accessor ...accessorOptions  (DEPRECATED) - options passed on to  setAccessor . Use  accessor  instead. gl  ( WebGLRenderingContext ) - gl context typedArray  - typed array with values that should be used to size and initialize the new GPU buffer. Short hand for  new Buffer({data: typedArray}) . gl  ( WebGLRenderingContext ) - gl context byteLength  - specifies the number of bytes that should be allocated (but not initialized). Short hand for  new Buffer({byteLength}) . The newly constructed buffer will either be a an \"element\" buffer used for storing vertex indices, or a \"generic\" buffer that can be used to store other things. To create an element buffer, specify  target: GL.ELEMENT_ARRAY_BUFFER . If target is not specified, it will be a generic buffer that can be used in a variety of situations. In WebGL 1, the default target is  GL.ARRAY_BUFFER  which will work as a \"generic\" (i.e. non-element) buffer. In WebGL 2, the default target is  GL.COPY_READ_BUFFER  which means the buffer can work either as a generic buffer and an element buffer. This will be determined when it is first used with (bound to) a specific target. From that point on, WebGL will consider it either as an element buffer or a generic buffer. Methods initialize(props : Object) : Buffer Allocates and optionally initializes buffer memory/data store (releasing any previously allocated memory). Also extracts characteristics of stored data, hints for vertex attribute. data  (ArrayBufferView) - contents byteLength  (Number) - the size of the buffer object's data store. usage = GL.STATIC_DRAW  (GLenum) - Allocation hint for GPU driver. accessor  (Object) - object with accessor props to be stored as accessor. ...accessorOptions  (DEPRECATED) - parameters passed to  setAccessor reallocate(byteLength : Number) : Buffer If necessary, increases buffer size to  byteLength . Does not decrease the buffer's size if already long enough. byteLength  (Number) - the minimum size of the buffer object's data store. Returns: true  - if reallocation happened (in which case any stored data was invalidated). false  - if the  Buffer  was already big enough in which case any uploaded data remains intact. subData({data , offset=, srcOffset=, length=}) : Buffer Updates part or all of a buffer's allocated memory. Buffer.subData({data, offset=, srcOffset=, length=}) data  ( ArrayBufferView ) - length is inferred unless provided offset = 0  - Offset into buffer srcOffset = 0  - WebGL 2: Offset into srcData length  - WebGL 2: Number of bytes to be copied copyData(options : Object) : Buffer (WebGL 2) Copies part of the data of another buffer into this buffer. The copy happens on the GPU and is expected to be efficient. Buffer.copyData({sourceBuffer, readOffset=, writeOffset=, size}) options.sourceBuffer  ( Buffer ) - the buffer to read data from. options.readOffset = 0  (GLint) - byte offset from which to start reading from the buffer. options.writeOffset = 0  (GLint) - byte offset from which to start writing to the buffer. options.size  (GLsizei) - byte count, specifying the size of the data to be copied. Note: readOffset ,  writeOffset  and  size  must all be greater than or equal to zero. readOffset + sizereadOffset + size  must not exceeed the size of the source buffer object writeOffset + sizewriteOffset + size  must not exceeed the size of the buffer bound to writeTarget. If the source and destination are the same buffer object, then the source and destination ranges must not overlap. getData() : TypedArray (WebGL 2) Reads data from buffer into an  ArrayBufferView  or  SharedArrayBuffer . Buffer.getData({dstData, srcByteOffset, srcOffset, length}) dstData = null  ( ArrayBufferView  |  SharedArrayBuffer  |  null ) - memory to which to write the buffer data. New ArrayBufferView allocated with correct type if not provided. srcByteOffset = 0  (GLintptr) - byte offset from which to start reading from the buffer. srcOffset = 0  (GLuint) - element index offset where to start reading the buffer. length = 0  (GLuint) Optional, Element count to be copied, optimal value calculated when not provided. Returns a typed array containing the data from the buffer (if  dstData  was supplied it will be returned, otherwise this will be a freshly allocated array). getElementCount( accessor : Accessor ) : Number Returns number of elements in the buffer. In a buffer created with Float32Array typed array, each float is an element and takes 4 bytes (or 32 bits). setAccessor(accessor : Accessor | Object) : Buffer Allows you to optionally describe the accessor properties of the data in the buffer. This does not affect the buffer itself, but if supplied can avoid having to supply this data again when you use this buffer as an attribute later (see  VertexArray.setAttributes ). For details on accessor props, see the documentation for the  Accessor  class. Types Usage Usage WebGL 2 WebGL 1 Description GL.STATIC_DRAW Yes Yes Buffer will be used often and not change often. Contents are written to the buffer, but not read. GL.DYNAMIC_DRAW Yes Yes Buffer will be used often and change often. Contents are written to the buffer, but not read. GL.STREAM_DRAW Yes Yes Buffer will not be used often. Contents are written to the buffer, but not read. GL.STATIC_READ Yes No Buffer will be used often and not change often. Contents are read from the buffer, but not written. GL.DYNAMIC_READ Yes No Buffer will be used often and change often. Contents are read from the buffer, but not written. GL.STREAM_READ Yes No Buffer will not be used often. Contents are read from the buffer, but not written. GL.STATIC_COPY Yes No Buffer will be used often and not change often. Contents are neither written or read by the user. GL.DYNAMIC_COPY Yes No Buffer will be used often and change often. Contents are neither written or read by the user. GL.STREAM_COPY Yes No Buffer will be used often and not change often. Contents are neither written or read by the user. Parameters Parameter Type Value GL.BUFFER_SIZE GLint The size of the buffer in bytes GL.BUFFER_USAGE GLenum The  usage  pattern of the buffer \"Manually\" Binding Buffers If you are an experienced WebGL or OpenGL programmer you are probably used to constantly binding buffers. Buffer binding and unbinding is handled internal by luma.gl methods and applications typically do not need to bind buffers. To support use cases integrating with external libraries or raw webgl code, it is of course possible to \"manually\" bind and unbind luma.gl  Buffer  instances: WebGL 2 examples Remarks All instance methods in a buffer (unless they return some documented value) are chainable. While transferring memory between CPU and GPU takes some time, once the memory is available as a buffer on the GPU it can be very efficiently used as inputs and outputs by the GPU. Note that in WebGL, there are two types of buffers: \"element\" buffers. These can only store vertex attributes with indices (a.k.a \"elements\") and can only be used by binding them to the  GL.ELEMENT_ARRAY_BUFFER  before draw calls. \"generic\" buffers. These can be used interchangeably to store different types of data, including (non-index) vertex attributes. For more on the  GL.ELEMENT_ARRAY_BUFFER  restrictions in WebGL, see  this page  for WebGL 1 and  this page  for WebGL 2.","headings":[{"value":"Buffer","depth":1},{"value":"Usage","depth":2},{"value":"Members","depth":2},{"value":"handle : WebGLBuffer","depth":5},{"value":"byteLength : Number","depth":5},{"value":"bytesUsed : Number","depth":4},{"value":"accessor : Accessor","depth":5},{"value":"Constructor","depth":2},{"value":"Buffer(gl : WebGLRenderingContext, props : Object | TypedArray | Number)","depth":3},{"value":"Methods","depth":2},{"value":"initialize(props : Object) : Buffer","depth":3},{"value":"reallocate(byteLength : Number) : Buffer","depth":3},{"value":"subData({data , offset=, srcOffset=, length=}) : Buffer","depth":3},{"value":"copyData(options : Object) : Buffer (WebGL 2)","depth":3},{"value":"getData() : TypedArray (WebGL 2)","depth":3},{"value":"getElementCount(accessor : Accessor) : Number","depth":3},{"value":"setAccessor(accessor : Accessor | Object) : Buffer","depth":3},{"value":"Types","depth":2},{"value":"Usage","depth":3},{"value":"Parameters","depth":3},{"value":"\"Manually\" Binding Buffers","depth":3},{"value":"Remarks","depth":2}],"slug":"modules/webgl/docs/api-reference/buffer","title":"Buffer"},{"excerpt":"Framebuffer A  Framebuffer  is a WebGL container object that the application can use for \"off screen\" rendering. A framebuffer does not itself contain any image data but can optionally contain attachments (one or more color buffers, a depth buffer and a stencil buffer) that store data. Attachments must be in the form of  Texture s and  Renderbuffer s. For additional information, see OpenGL Wiki  Framebuffer  and  Framebuffer Object Functionality luma.gl adds Usage Creating a framebuffer with default color and depth attachments Attaching textures and renderbuffers Resizing a framebuffer to the size of a window. Resizes all attachements with a single  framebuffer.resize()  call Clearing a framebuffer Specifying a framebuffer for rendering in each render calls Binding a framebuffer for multiple render calls Reading, copying or blitting data from a Framebuffer attachment. For reading data into CPU memory check  readPixelsToArray For reading into a Buffer object (GPU memory), doesn't result in CPU and GPU sync, check  readPixelsToBuffer For reading into a Texture object (GPU memory), doesn't result in CPU and GPU sync, check  copyToTexture For blitting between framebuffers (WebGL 2), check  blit Using Multiple Render Targets Specify which framebuffer attachments the fragment shader will be writing to when assigning to  gl_FragData[] Writing to multiple framebuffer attachments in GLSL fragment shader Clearing a specific draw buffer in a framebuffer (WebGL 2) Methods constructor(gl : WebGLRenderingContext, props : Object) Creates a new framebuffer, optionally creating and attaching  Texture  and  Renderbuffer  attachments. id = - ( String ) - An optional name (id) of the buffer. width = 1  - ( number ) The width of the framebuffer. height = 1  - ( number ) The height of the framebuffer. attachments ={} - ( Object , optional) - a map of Textures and/or Renderbuffers, keyed be \"attachment points\" (see below). color  - shortcut to the attachment in  GL.COLOR_ATTACHMENT0 depth  - shortcut to the attachment in  GL.DEPTH_ATTACHMENT stencil  - shortcut to the attachment in  GL.STENCIL_ATTACHMENT The luma.gl  Framebuffer  constructor enables the creation of a framebuffer with all the proper attachments in a single step and also the  resize  method makes it easy to efficiently resize a all the attachments of a  Framebuffer  with a single method. When no attachments are provided during  Framebuffer  object creation, new resources are created and used as default attachments for enabled targets (color and depth).\nFor color, new  Texture2D  object is created with no mipmaps and following filtering parameters are set. Texture parameter Value GL.TEXTURE_MIN_FILTER GL.LINEAR GL.TEXTURE_MAG_FILTER GL.LINEAR GL.TEXTURE_WRAP_S GL.CLAMP_TO_EDGE GL.TEXTURE_WRAP_T GL.CLAMP_TO_EDGE For depth, new  Renderbuffer  object is created with  GL.DEPTH_COMPONENT16  format. delete() Destroys the underlying WebGL object. When destroying  Framebuffer s it can be important to consider that a  Framebuffer  can manage other objects that may also need to be destroyed. initialize(props : Object) : Framebuffer Initializes the  Framebuffer  to match the supplied parameters. Unattaches any existing attachments, attaches any supplied attachments. All new attachments will be resized if they are not already at the right size. Framebuffer.initialize({width, height}) width = 1  - ( number ) The width of the framebuffer. height = 1  - ( number ) The height of the framebuffer. attachments ={} - ( Object , optional) - a map of Textures and/or Renderbuffers, keyed be \"attachment points\" (see below). color  - shortcut to the attachment in  GL.COLOR_ATTACHMENT0 depth  - shortcut to the attachment in  GL.DEPTH_ATTACHMENT stencil  - shortcut to the attachment in  GL.STENCIL_ATTACHMENT update(options: Object) : Framebuffer Updates Framebuffers attachments using provided Texture and Renderbuffer objects. Optionally sets read and draw buffers when using WebGL 2 context. attachments  - a map of attachments. readBuffer  - Buffer to be set as read buffer (WebGL 2) drawBuffers  - Buffers to be set as draw buffers (WebGL 2) clearAttachments  - When set to true, will first unattach all binding points, default value is  false . resizeAttachments  - When set to true, all attachments will be re-sized to Framebuffers size, default value is  true . resize({width: Number, height: Number}) : Framebuffer Framebuffer.resize({width, height}) Resizes all the  Framebuffer 's current attachments to the new  width  and  height  by calling  resize  on those attachments. width  (GLint) - width of  Framebuffer  in pixels height  (GLint) - height of  Framebuffer  in pixels Returns itself to enable chaining Each attachment's  resize  method checks if  width  or  height  have actually changed before reinitializing their data store, so calling  resize  multiple times with the same  width  and  height  does not trigger multiple resizes. If a resize happens,  resize  erases the current content of the attachment in question. WebGL References see  initialize . attach(attachments : Object, options: Object) : Framebuffer Used to attach or unattach  Texture s and  Renderbuffer s from the  Framebuffer s various attachment points. Framebuffer.attach(attachments) attachments  - a map of attachments. options clearAttachments  - When set to true, will first unattach all binding points, default value is  false . resizeAttachments  - When set to true, all attachments will be re-sized to Framebuffers size, default value is  true . Returns itself to enable chaining. The key of an attachment must be a valid attachment point, see below. The following values can be provided for each attachment null  - unattaches any current binding Renderbuffer  - attaches the  Renderbuffer Texture  - attaches the  Texture Texture , layer=0 (Number), mipmapLevel=0 (Number)  - attaches the specific layer from the  Texture  (WebGL 2) This function makes calls to the following WebGL APIs: gl.framebufferRenderbuffer ,\n gl.bindFramebuffer ,\n gl.framebufferTexture2D ,\n gl.bindFramebuffer ,\n gl.framebufferTextureLayer ,\n gl.bindFramebuffer  (This is for WebGL 2 only) checkStatus() : Framebuffer Check that the framebuffer contains a valid combination of attachments gl.checkFramebufferStatus ,  gl.bindFramebuffer clear(options: Object) : Framebuffer Clears the contents (pixels) of the framebuffer attachments. options.color  (Boolean or Array) - clears all active color buffers (any selected  drawBuffer s) with either the provided color or the default color. options.depth options.stencil options.drawBuffers = []  - An array of color values, with indices matching the buffers selected by  drawBuffers  argument. Notes: The scissor box bounds the cleared region. The pixel ownership test, the scissor test, dithering, and the buffer writemasks affect the operation of  clear . Alpha function, blend function, logical operation, stenciling, texture mapping, and depth-buffering are ignored by  clear . invalidate (WebGL 2) Signals to the GL that it need not preserve the pixels of a specified region of the framebuffer (by default all pixels of the specified framebuffer attachments are invalidated). Parameters attachments - list of attachments to invalidate This function makes calls to the following WebGL APIs: gl.invalidateFramebuffer ,  gl.invalidateSubFramebuffer ,  gl.bindFramebuffer Limits GL.MAX_COLOR_ATTACHMENTS  - The maximum number of color attachments supported. Can be  0  in WebGL 1. GL.MAX_DRAW_BUFFERS  - The maximum number of draw buffers supported. Can be  0  in WebGL 1, which means that  gl_FragData[]  is not available in shaders. It is possible that you can have a certain number of attachments, but you can't draw to all of them at the same time. Framebuffer Parameters Framebuffer Attachment Points Attachment Point Description GL.COLOR_ATTACHMENT0 Attaches the texture to one of the framebuffer's color buffers GL.COLOR_ATTACHMENT {1-15} Attaches the texture to one of the framebuffer's color buffers GL.DEPTH_ATTACHMENT Attaches the texture to the framebuffer's depth buffer GL.STENCIL_ATTACHMENT Attaches the texture to the framebuffer's stencil buffer GL.DEPTH_STENCIL_ATTACHMENT Combined depth and stencil buffer The attachment point  GL.BACK  refersn to the default framebuffer's back buffer. The set of available attachments is larger in WebGL 2, and also the extensions  WEBGL_draw_buffers  and  WEBGL_depth_texture  provide additional attachments that match or exceed the WebGL 2 set. Framebuffer Attachment Values The following values can be provided for each attachment point null  - unattaches any current binding Renderbuffer  - attaches the  Renderbuffer Texture2D  - attaches at mipmapLevel 0 of the supplied  Texture2D . Texture2D , 0, mipmapLevel  - attaches the specified mipmapLevel from the supplied  Texture2D  (WebGL 2), or cubemap face. The second element in the array must be  0 . In WebGL 1, mipmapLevel must be 0. TextureCube , face (Number), mipmapLevel=0 (Number)  - attaches the specifed cubemap face from the  Texture , at the specified mipmap level. In WebGL 1, mipmapLevel must be 0. Texture2DArray , layer (Number), mipmapLevel=0 (Number)  - attaches the specifed layer from the  Texture2DArray , at the specified mipmap level. Texture3D , layer (Number), mipmapLevel=0 (Number)  - attaches the specifed layer from the  Texture3D , at the specified mipmap level. Remarks In the raw WebGL API, creating a set of properly configured and matching textures and renderbuffers can require a lot of careful coding and boilerplate. This is further complicated by many capabilities (such as support for multiple color buffers and various image formats) depending on WebGL extensions or WebGL versions.","headings":[{"value":"Framebuffer","depth":1},{"value":"Functionality","depth":2},{"value":"Usage","depth":2},{"value":"Reading, copying or blitting data from a Framebuffer attachment.","depth":3},{"value":"Using Multiple Render Targets","depth":3},{"value":"Methods","depth":2},{"value":"constructor(gl : WebGLRenderingContext, props : Object)","depth":3},{"value":"delete()","depth":3},{"value":"initialize(props : Object) : Framebuffer","depth":3},{"value":"update(options: Object) : Framebuffer","depth":3},{"value":"resize({width: Number, height: Number}) : Framebuffer","depth":3},{"value":"attach(attachments : Object, options: Object) : Framebuffer","depth":3},{"value":"checkStatus() : Framebuffer","depth":3},{"value":"clear(options: Object) : Framebuffer","depth":3},{"value":"invalidate (WebGL 2)","depth":3},{"value":"Limits","depth":2},{"value":"Framebuffer Parameters","depth":2},{"value":"Framebuffer Attachment Points","depth":3},{"value":"Framebuffer Attachment Values","depth":3},{"value":"Remarks","depth":2}],"slug":"modules/webgl/docs/api-reference/framebuffer","title":"Framebuffer"},{"excerpt":"Moving Data luma.gl  offers a set of functions that copy or blit data from and to Texture and Framebuffer objects. Image data can also be copied into Buffer, TypedArray, Images or Urls. Readback Functions readPixelsToArray(source : Framebuffer|Texture  , options: Object ) : TypedArray Reads data from a  Framebuffer  or  Texture  object into a TypedArray object and returns it. A new TypedArray object is created when not provided. This method requires a sync between CPU and GPU as pixel values are copied from GPU texture memory to CPU Array object memory. This could introduce a delay as it waits for GPU to finish updating the texture. For asynchronous read, check  copyToBuffer  method. source  ( Texture  or  Framebuffer ) - This object will be bound and data copied from it. Optional parameters: options.sourceX  - ( number , default: 0) X offset of the area to be copied, options.sourceY  - ( number , default: 0) Y offset of the area to be copied, options.sourceFormat  - ( GLenum , default: GL.RGBA) The format of the data. options.sourceAttachment  - ( GLenum , default:  COLOR_ATTACHMENT0 ) Used to deduce the  type  when not provided. options.target  - ( TypedArray , default: null) Array object, into which data to be copied, new object is created when not provided. options.sourceWidth  - ( number , default: source width) The width of the area to be copied. options.sourceHeight  - ( number , default: source height) The height of the area to be copied. options.sourceType  - ( GLenum , default: type of  pixelArray  or  UNSIGNED_BYTE ) The type of the data. Notes: Reading from floating point textures is dependent on an extension both in WebGL 1 and WebGL 2. When supported, the  {format: GL.RGBA, type: GL.FLOAT, ...}  combination becomes valid for reading from a floating-point color buffer. When color attachment is a float texture with format less than 4 channels, i.e,  GL.R32F , or  GL.RG32F ,  readPixels  should still be called with a 4 component  format ( GL.RGBA ), and default value (R:0, G:0, B: 0 and A: 1) will be returned for un-used channel. This function makes calls to the following WebGL APIs: gl.readPixels ,  gl.bindFramebuffer readPixelsToBuffer(source : Framebuffer|Texture, options: Object) : Buffer (WebGL 2) Reads data from a  Framebuffer  or  Texture  object into A  Buffer  object and returns it. A new  Buffer  object is created when not provided. This method avoids a sync between CPU and GPU as pixel values are copied from GPU texture memory to GPU Buffer memory. This method returns right away without any delays. A CPU and GPU sync will be triggered when the returned buffer data is read using  buffer.getData() , but applications can delay this read, which can reduces the delay due to the sync, or the sync can be completely avoided by using the  Buffer  as the source of input to the GPU (either as  ARRAY_BUFFER  or  PIXEL_UNPACK_BUFFER ). source  ( Texture  or  Framebuffer ) - This object will be bound and data copied from it. Optional parameters: options.sourceX  - ( number , default: 0) X offset of the area to be copied, options.sourceY  - ( number , default: 0) Y offset of the area to be copied, options.sourceFormat  - ( GLenum , default: GL.RGBA) The format of the data. options.target  - ( Buffer ) Buffer object, into which data to be copied, new object is created when not provided. options.targetByteOffset  - ( number , default: 0) Byte offset from which data should be copied into buffer. options.sourceWidth  - ( number , default: source.width) The width of the area to be copied, options.sourceHeight  - ( number , default: source.height) The height of the area to be copied, options.sourceType  - ( GLenum , default: type of  target  or  UNSIGNED_BYTE ) The type of the data. Notes: Reading from floating point textures is dependent on an extension both in WebGL 1 and WebGL 2. When supported, the  {format: GL.RGBA, type: GL.FLOAT, ...}  combination becomes valid for reading from a floating-point color buffer. This function makes calls to the following WebGL APIs: gl.readPixels ,  gl.bindFramebuffer ,  gl.bindBuffer Copy Functions copyToDataUrl(source : Framebuffer|Texture, options: Object) : Data URL Reads data form a  Texture  or  Framebuffer  object and returns a  Data URL  containing the pixel data in PNG format. source  ( Texture  or  Framebuffer ) - This object will be bound and data copied from it. Optional parameters: options.sourceAttachment  - ( GLenum , default:  COLOR_ATTACHMENT0 ) Used to deduce the  type  when not provided. options.targetMaxHeight  - ( number , default: Number.MAX_SAFE_INTEGER) Maximum height of the image to be in returned Data URL. Note: Works only under a browser environment, doesn't work under Node. This function makes calls to the following WebGL APIs: gl.readPixels ,  gl.bindFramebuffer copyToImage(source : Framebuffer|Texture, options: Object) : Image Reads data form a  Texture  or  Framebuffer  object and copies it to provided image, new  Image  instance is created if not provided. source  ( Texture  or  Framebuffer ) - This object will be bound and data copied from it. Optional parameters: options.sourceAttachment  - ( GLenum , default:  COLOR_ATTACHMENT0 ) Used to deduce the  type  when not provided. options.targetImage  - ( Image , Optional)  Image  to to which pixel data to be copied, new one is created if not provide. Note: Works only under a browser environment, doesn't work under Node. This function makes calls to the following WebGL APIs: gl.readPixels ,  gl.bindFramebuffer copyToTexture(source : Framebuffer|Texture, target: Texture|GL-enum, options: Object) : Texture Copies pixels from a  Framebuffer  or  Texture  object into the specified area of a two-dimensional texture image or cube-map texture image. (gl.copyTexImage2D, gl.copyTexSubImage2D and gl.copyTexSubImage3D wrapper) source  ( Texture  or  Framebuffer ) - If provided this object will be bound and data copied from it. target  ( Texture  or  GL enum ) - Texture object or GL enum specifying the target binding point, to which data to be copied. If target binding point is specified, it is assumed that a valid texture object is already bound. options.sourceX  ( GLint , optional, default: 0) - x coordinate of the lower left corner where to start copying. options.sourceY  ( GLint , optional, default: 0) - y coordinate of the lower left corner where to start copying. options.targetX  ( GLint , optional) - X offset with in target texture. options.targetY  ( GLint , optional) - Y offset with in target texture. options.targetZ  ( GLint , optional, WebGL 2) - Z offset with in target texture, when using copying into 2D Array of 3D texture. options.width  ( GLint , optional, default: texture.width) - Width of the pixel rectangle to be copied. options.height  ( GLint , optional, default: texture.height) - Height of the pixel rectangle to be copied. Notes: targetX ,  targetY ,  targetZ  : when an offset is specified, it implies we are copying data into a sub region of the target texture and internally  gl.copyTexSubImage2D  or  gl.copyTexSubImage3D  are used based on the  target , for these cases it is assumed that target texture has enough GPU memory already allocated. When none of the offsets are specified,  gl.copyTexImage2D  is used to copy data to entire target region and GPU memory is allocated if needed, target texture GPU memory doesn't have to be pre-allocated. This function makes calls to the following WebGL APIs: gl.copyTexImage2D ,  gl.copyTexSubImage2D  and  gl,copyTexSubImage3D Blit Functions blit(options: Object) : (WebGL 2) Copies a rectangle of pixels from a  Texture  or  Framebuffer  object into a  Texture  or  Framebuffer  object. source  ( Texture  or  Framebuffer ) - This object will be bound and data copied from it. options.target  ( Texture  or  Framebuffer ) - This object will be bound and data is copied into it. options.sourceAttachment  ( GLenum , default:  COLOR_ATTACHMENT0 ) - Attachment index from which data to be copied from. options.sourceX0  ( GLint , default:  0 ) - Lower X bound of copy rectangle in source. options.sourceY0  ( GLint , default:  0 ) - Lower Y bound of copy rectangle in source. options.sourceX1  ( GLint ) - Higher X bound of copy rectangle in source. options.sourceY1  ( GLint ) - Higher Y bound of copy rectangle in source. options.targetX0  ( GLint , default:  0 ) - Lower X bound of copy rectangle in destination. options.targetY0  ( GLint , default:  0 ) - Lower Y bound of copy rectangle in destination. options.targetX1  ( GLint ) - Higher X bound of copy rectangle in destination. options.targetY1  ( GLint ) - Higher Y bound of copy rectangle in destination. options.mask  ( GLbitfild , default:  0 ) - A  GLbitfield  specifying a bitwise OR mask indicating which buffers are to be copied, possible buffers masks are  GL.COLOR_BUFFER_BIT ,  GL.DEPTH_BUFFER_BIT  and  GL.STENCIL_BUFFER_BIT options.color  ( Boolean , default:  true ) - When true  GL.COLOR_BUFFER_BIT  is added to the mask. options.depth  ( Boolean , default:  false ) - When true  GL.DEPTH_BUFFER_BIT  is added to the mask. options.stencil  ( Boolean , default:  false ) - When true  GL.STENCIL_BUFFER_BIT  is added to the mask. options.filter = GL.NEAREST  - specifies interpolation mode if stretching is needed.  GL.LINEAR  can be used exclusively for color buffers. Notes: There are a number of restrictions when blitting between integer and floating point formats. This function makes calls to the following WebGL APIs: gl.blitFramebuffer ,  gl.readBuffer ,  gl.bindFramebuffer","headings":[{"value":"Moving Data","depth":1},{"value":"Readback Functions","depth":2},{"value":"readPixelsToArray(source : Framebuffer|Texture , options: Object) : TypedArray","depth":3},{"value":"readPixelsToBuffer(source : Framebuffer|Texture, options: Object) : Buffer (WebGL 2)","depth":3},{"value":"Copy Functions","depth":2},{"value":"copyToDataUrl(source : Framebuffer|Texture, options: Object) : Data URL","depth":3},{"value":"copyToImage(source : Framebuffer|Texture, options: Object) : Image","depth":3},{"value":"copyToTexture(source : Framebuffer|Texture, target: Texture|GL-enum, options: Object) : Texture","depth":3},{"value":"Blit Functions","depth":2},{"value":"blit(options: Object) : (WebGL 2)","depth":3}],"slug":"modules/webgl/docs/api-reference/moving-data","title":"Moving Data"},{"excerpt":"Program A  Program  contains a matched pair of vertex and fragment  shaders  that can be exectued on the GPU by calling  Program.draw() . Programs handle compilation and linking of shaders, and store uniform values. They provide  draw  call which allows the application to run the shaders on specified input data. Usage Creating a program Set or update uniforms, in this case world and projection matrices Create a  VertexArray  to store buffer values for the vertices of a triangle and drawing Creating a program for transform feedback, specifying which varyings to use Members gl  :  WebGLRenderingContext handle  :  WebGLProgram  - The WebGL  WebGLProgram  instance. id  :  String  -  id  string for debugging. Constructor Program(gl : WebGLRenderingContext, props : Object) Creates a new program using the supplied vertex and fragment shaders. The shaders are compiled into WebGLShaders and is created and the shaders are linked. id  ( string , optional) - string id (to help indentify the program during debugging). vs  ( VertexShader | String ) - A vertex shader object, or source as a string. fs  ( FragmentShader | String ) - A fragment shader object, or source as a string. varyings  WebGL 2 ( String[] ) - a list of names of varyings. bufferMode = GL.SEPARATE_ATTRIBS  WebGL 2 ( GLenum ) - Optional, specifies how transform feedback should store the varyings. GL.TRANSFORM_FEEDBACK_BUFFER_MODE Description GL.SEPARATE_ATTRIBS One varying per buffer GL.INTERLEAVED_ATTRIBS Multiple varyings per buffer WebGL References  WebGLProgram ,  gl.createProgram delete() : Program Deletes resources held by program. Note: Does not currently delete shaders (to enable shader caching). Methods initialize(props : Object) : Program Relinks a program. Takes the same options as the constructor setUniforms(uniforms : Object) : Program Sets named uniforms from a map, ignoring names key  ( String ) - The name of the uniform to be set. The name of the uniform will be matched with the name of the uniform declared in the shader. You can set more uniforms on the Program than its shaders use, the extra uniforms will simply be ignored. value  ( mixed ) - The value to be set. Can be a float, an array of floats, a typed array, a boolean,  Texture  etc. The values must match the declarations in the shader. gl.useProgram draw(opts) : Program Program.draw  is the entry point for running shaders, rendering and (optionally calculating data using transform feedback techniques). Main parameters vertexArray  - a  VertexArray  object that will be bound and unbound before and after the draw call. uniforms = {}  - a map of uniforms that will be set just before the draw call (and remain set after the call). samplers = {}  - a map of texture  Sampler s that will be bound before the draw call. parameters  - temporary gl settings to be applied to this draw call. transformFeedback = null  - optional  TransformFeedback  object containing buffers that will receive the output of the transform feedback operation. Potentially autodeduced parameters drawMode = GL.TRIANGLES  - geometry primitive format of vertex data vertexCount  - number of vertices to draw offset = 0  - first vertex to draw isIndexed = false  - use indices in the \"elements\" buffer indexType = GL.UNSIGNED_SHORT  - must match the type of the \"elements\" buffer isInstanced = false  - Set to enable instanced rendering. instanceCount = 0  - Number of instances Parameters for drawing a limited range (WebGL 2 only) start  - hint to GPU, activates  gl.drawElementsRange  (WebGL 2) end  - hint to GPU, activates  gl.drawElementsRange  (WebGL 2) Returns:  true  if successful,  false  if draw call is blocked due to missing resources. Notes: Runs the shaders in the program, on the attributes and uniforms. Indexed rendering uses the element buffer ( GL.ELEMENT_ARRAY_BUFFER ), make sure your attributes or  VertexArray  contains one. If a  TransformFeedback  object is supplied,  transformFeedback.begin()  and  transformFeedback.end()  will be called before and after the draw call. A  Sampler  will only be bound if there is a matching Texture with the same key in the supplied  uniforms  object. Once a uniform is set, it's size should not be changed. This is only a concern for array uniforms. The following WebGL APIs are called in this function: gl.useProgram ,\n gl.drawElements ,\n gl.drawRangeElements  (WebGL 2),\n gl.drawArrays ,\n gl.drawElementsInstanced  (WebGL 2),\n gl.drawArraysInstanced  (WebGL 2),\n gl.getExtension ,  ANGLE_instanced_arrays ,\n gl.drawElementsInstancedANGLE ,\n gl.drawArraysInstancedANGLE Constants Limits Limit Value Description GL.MAX_VERTEX_TEXTURE_IMAGE_UNITS >= 0 (GLint) GL.MAX_RENDERBUFFER_SIZE >= 1 (GLint) GL.MAX_VARYING_VECTORS >= 8 (GLint) GL.MAX_VERTEX_ATTRIBS >= 8 (GLint) GL.MAX_VERTEX_UNIFORM_VECTORS >= 128 (GLint) GL.MAX_FRAGMENT_UNIFORM_VECTORS >= 16 (GLint) GL.TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH  (WebGL 2) - - Parameters Use with  Program.getParameter(parameter) Parameter Type Description GL.DELETE_STATUS GLboolean If true, program has been flagged for deletion (by calling  Program.delete() ), but the delete is pending because program is still part of current rendering state GL.LINK_STATUS GLboolean Indicates whether last link operation was successful. Program linking is performed by luma on program initialization GL.VALIDATE_STATUS GLboolean Result of last  gl.validateProgram()  operation GL.ATTACHED_SHADERS GLint Number of attached shaders ( 0 ,  1  or  2 ) GL.ACTIVE_ATTRIBUTES GLint Number of active attribute variables to a program GL.ACTIVE_UNIFORMS GLint Number of active attribute variables to a program GL.TRANSFORM_FEEDBACK_BUFFER_MODE GLenum (WebGL 2) Buffer capture mode,  GL.SEPARATE_ATTRIBS  or  GL.INTERLEAVED_ATTRIBS GL.TRANSFORM_FEEDBACK_VARYINGS GLint (WebGL 2) Number of varying variables to capture in transform feedback mode. GL.ACTIVE_UNIFORM_BLOCKS GLint (WebGL 2) Number of uniform blocks containing active uniforms.","headings":[{"value":"Program","depth":1},{"value":"Usage","depth":2},{"value":"Members","depth":2},{"value":"Constructor","depth":2},{"value":"Program(gl : WebGLRenderingContext, props : Object)","depth":3},{"value":"delete() : Program","depth":3},{"value":"Methods","depth":2},{"value":"initialize(props : Object) : Program","depth":3},{"value":"setUniforms(uniforms : Object) : Program","depth":3},{"value":"draw(opts) : Program","depth":3},{"value":"Constants","depth":2},{"value":"Limits","depth":3},{"value":"Parameters","depth":3}],"slug":"modules/webgl/docs/api-reference/program","title":"Program"},{"excerpt":"Query A  Query  object provides single unified API for using WebGL asynchronus queries, which include query objects ('Occlusion' and 'Transform Feedback') and timer queries. See also: WebGL 1 timer extension:  EXT_disjoint_timer_query WebGL 2 timer extension:  EXT_disjoint_timer_query_webgl2 Usage Use a query to time GPU calls Query Types A query can be started by passing following query type to to  begin()  or by using corresponding begin *  method. Query Type begin method Description GL_TIME_ELAPSED_EXT beginTimeElapsedQuery() Time taken by GPU to fully complete a set of GL commands GL.ANY_SAMPLES_PASSED beginOcclusionQuery({conservative: false}) Occlusion query: these queries detect whether an object is visible (whether the scoped drawing commands pass the depth test and if so, how many samples pass). GL.ANY_SAMPLES_PASSED_CONSERVATIVE beginOcclusionQuery({conservative: true}) Same as above above, but less accurate and faster version. GL.TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN beginTransformFeedbackQuery() Number of primitives that are written to transform feedback buffers. In addition to above queries, Query object also provides  getTimeStamp  which returns GPU time stamp at the time this query is executed by GPU. Two sets of these methods can be used to calculate time taken by GPU for a set of GL commands. Methods static Query.isSupported(gl : WebGLRenderingContext, options : Object) Returns true if Query is supported by the WebGL implementation\n(depends on the EXT_disjoint_timer_query extension)/\nCan also check whether timestamp queries are available. options.queries=false {Object} - If true, checks if Query objects (occlusion/transform feedback) are supported options.timers=false {Object} - If true, checks if 'TIME_ELAPSED_EXT' queries are supported Returns: {Boolean} - Query API is supported with specified configuration Options queries = false, timers = false, constructor(gl : WebGLRenderingContext, props : Object) new Query(gl, {}) delete() Destroys the WebGL object. Rejects any pending query. return {Query} - returns itself, to enable chaining of calls. beginTimeElapsedQuery() Shortcut for timer query (dependent on extension in both WebGL 1 and 2) Query.beginOcclusionQuery({conservative = false}) Shortcut for occlusion query (dependent on WebGL 2) beginTransformFeedbackQuery() Shortcut for transform feedback query (dependent on WebGL 2) Query.begin(target) Measures GPU time delta between this call and a matching  end  call in the GPU instruction stream. Remarks: Due to OpenGL API limitations, after calling  begin()  on one Query\ninstance,  end()  must be called on that same instance before\ncalling  begin()  on another query. While there can be multiple\noutstanding queries representing disjoint  begin() / end()  intervals.\nIt is not possible to interleave or overlap  begin  and  end  calls. Triggering a new query when a Query is already tracking an\nunresolved query causes that query to be cancelled. target {GLenum} - target to query return {Query} - returns itself, to enable chaining of calls. end Inserts a query end marker into the GPU instruction stream.\nNote: Can be called multiple times. return {Query} - returns itself, to enable chaining of calls. isResultAvailable return {Boolean} - true if query result is available getResult Returns the query result return {Number} - query result. Semantics depend on query type getTimerMilliseconds Shorthand for getting timer query results and converting to milliseconds to match JavaScript conventions. return {Number} - measured time or timestamp, in milliseconds isTimerDisjoint Returns  true  if the timer query was disjoint, indicating that timing results are invalid.\nThis is rare and might occur, for example, if the GPU was throttled while timing. return {Boolean} - true if timer query was disjoint createPoll(limit = Number.POSITIVE_INFINITY) Begins polling  Query  once per frame to check if results are available. limit {Number} - Maximum number of frames to poll before rejecting the  Promise . return {Promise} - Resolves to the  Query  result if it becomes available before  limit \nframes have elapsed, and is rejected otherwise. Remarks Even when supported, timer queries can fail whenever a change in the GPU occurs that will make the values returned by this extension unusable for performance metrics, for example if the GPU is throttled mid-frame. This occurance is captured in  isTimerDisjoint  method. Note that from a JavaScript perspective, where callback driven APIs are the norm, the functionality of the WebGL  Query  class seems limited. Many operations that require expensive roundtrips to the GPU (such as  readPixels ) that would obviously benefit from asynchronous queries, are not covered by the  Query  class.","headings":[{"value":"Query","depth":1},{"value":"Usage","depth":2},{"value":"Query Types","depth":2},{"value":"Methods","depth":2},{"value":"static Query.isSupported(gl : WebGLRenderingContext, options : Object)","depth":3},{"value":"constructor(gl : WebGLRenderingContext, props : Object)","depth":3},{"value":"delete()","depth":3},{"value":"beginTimeElapsedQuery()","depth":3},{"value":"Query.beginOcclusionQuery({conservative = false})","depth":3},{"value":"beginTransformFeedbackQuery()","depth":3},{"value":"Query.begin(target)","depth":3},{"value":"end","depth":3},{"value":"isResultAvailable","depth":3},{"value":"getResult","depth":3},{"value":"getTimerMilliseconds","depth":3},{"value":"isTimerDisjoint","depth":3},{"value":"createPoll(limit = Number.POSITIVE_INFINITY)","depth":3},{"value":"Remarks","depth":2}],"slug":"modules/webgl/docs/api-reference/query","title":"Query"},{"excerpt":"Renderbuffer Renderbuffer s are WebGL Objects that contain textures. They are optimized for use as render targets, while vanilla  Texture s may not be, and are the logical choice when you do not need to sample (i.e. in a post-pass shader) from the produced image. If you do need to sample (such as when reading depth back in a second shader pass), use  Texture  instead. In addition, in WebGL 2,  Renderbuffer  can do  Multisampling (MSAA)  just like standard framebuffer. For additional information, see  OpenGL Wiki Usage Creating a  Renderbuffer Reformatting/reinitializing a  Renderbuffer Resizing a  Renderbuffer Attaching a  Renderbuffer  to a  Framebuffer  (automatically resizes the  Renderbuffer ) Members id  (string) - id for debugging handle  ( WebGLRenderbuffer ) - the underlying WebGLRenderbuffer object width  (number) - width of renderbuffer in pixels height  (number) - height of renderbuffer in pixels format  (number) - internal format of the renderbuffer (e.g.  GL.DEPTH_COMPONENT16 ) samples  (number) - samples (always  0  in non-WebGL 2 contexts) Methods getSamplesForFormat (static method) Queries valid sample counts for a  Renderbuffer  format. The sample counts can be provided as a parameter to the  Renderbuffer  constructor. Renderbuffer.getSamplesForFormat({format}) format  (GLenum) - internal format of the renderbuffer (e.g.  GL.DEPTH_COMPONENT16 ) Returns (Number[]) - An list of valid sample counts in descending order. If multisampling is not supported the returned value will be  [0] , e.g. signed and unsigned integer internal formats in WebGL 2. Note that this method always returns  [0]  in WebGL 1. constructor Creates a new  Renderbuffer  and initalizes it by calling  initialize  with the provided parameters. new Renderbuffer(gl, {id=, format, width, height, samples=}) gl  (WebGLRenderingContext) - gl context id = (String) - optional string id format  (GLenum) - internal format of the renderbuffer (e.g.  GL.DEPTH_COMPONENT16 ) width = 1  (GLint) - width of renderbuffer in pixels height = 1  (GLint) - height of renderbuffer in pixels samples =0 (GLint) - (WebGL 2) number of samples to be used for storage. WebGL References  gl.createRenderbuffer , also see  initialize . initialize Creates and initializes a renderbuffer object's data store. Used to update a  Renderbuffer s format and size after it was initially created. Renderbuffer.initialize({format, width, height, samples=}) format  (GLenum) - internal format of the renderbuffer (e.g.  GL.DEPTH_COMPONENT16 ) width = 1  (GLint) - width of renderbuffer in pixels height = 1  (GLint) - height of renderbuffer in pixels samples =0 (GLint) - (WebGL 2) number of samples to be used for storage. Returns itself to enable chaining initialize  erases the current content of the  Renderbuffer . WebGL References  gl.renderbufferStorage ,  gl.renderbufferStorageMultisample  (WebGL 2),  gl.bindRenderbuffer resize Reinitializes the  Renderbuffer 's data store with the new  width  and  height  but unchanged  format  (and  samples , if available). Renderbuffer.resize({width, height}) width  (GLint) - width of  Renderbuffer  in pixels height  (GLint) - height of  Renderbuffer  in pixels Returns itself to enable chaining Checks if  width  or  height  have actually changed before calling  initialize . If a resize happens,  resize  erases the current content of the  Renderbuffer . WebGL References see  initialize . Renderbuffer Formats The \"internal\" format of the  Renderbuffer . Value Description GL.RGBA4 4 red bits, 4 green bits, 4 blue bits 4 alpha bits GL.RGB565 5 red bits, 6 green bits, 5 blue bits GL.RGB5_A1 5 red bits, 5 green bits, 5 blue bits, 1 alpha bit GL.DEPTH_COMPONENT16 16 depth bits GL.STENCIL_INDEX8 8 stencil bits This table lists the basic formats supported in WebGL 1. For a full table of formats supported in WebGL 2 and via WebGL extensions, see  Texture . Sized Internal Format Format Type Depth Bits Stencil Bits GL.DEPTH_COMPONENT16 GL.DEPTH_COMPONENT GL.UNSIGNED_SHORT ,  GL.UNSIGNED_INT 16 0 GL.DEPTH_COMPONENT24 GL.DEPTH_COMPONENT GL.UNSIGNED_INT 24 0 GL.DEPTH_COMPONENT32F GL.DEPTH_COMPONENT GL.FLOAT f32 0 GL.DEPTH24_STENCIL8 GL.DEPTH_STENCIL GL.UNSIGNED_INT_24_8 24 8 GL.DEPTH32F_STENCIL8 GL.DEPTH_STENCIL GL.FLOAT_32_UNSIGNED_INT_24_8_REV f32 8 When using the WEBGL_depth_texture extension:\n GL.DEPTH_COMPONENT \n GL.DEPTH_STENCIL \nWhen using the EXT_sRGB extension:\n EXT.SRGB_EXT \n EXT.SRGB_ALPHA_EXT When using a WebGL 2 context, the following values are available additionally: GL.R8 GL.R16F GL.R32F GL.R8UI GL.RG8 GL.RG16F GL.RG32F GL.RGUI GL.RGB8 GL.SRGB8 GL.RGB565 GL.R11F_G11F_B10F GL.RGB9_E5 GL.RGB16F GL.RGB32F GL.RGB8UI GL.RGBA8 GL.SRGB_APLHA8 GL.RGB5_A1 GL.RGBA4444 GL.RGBA16F GL.RGBA32F GL.RGBA8UI Parameters Parameter Type Read/Write Description GL.RENDERBUFFER_WIDTH GLint R height of the image of renderbuffer GL.RENDERBUFFER_HEIGHT GLint R height of the image of renderbuffer GL.RENDERBUFFER_INTERNAL_FORMAT GLenum R See below GL.RENDERBUFFER_GREEN_SIZE GLint R resolution (bits) of green color GL.RENDERBUFFER_BLUE_SIZE GLint R resolution (bits) of blue color GL.RENDERBUFFER_RED_SIZE GLint R resolution (bits) of red color GL.RENDERBUFFER_ALPHA_SIZE GLint R resolution (bits) of alpha component GL.RENDERBUFFER_DEPTH_SIZE GLint R resolution (bits) of depth component GL.RENDERBUFFER_STENCIL_SIZE GLint R resolution (bits) of stencil component GL.RENDERBUFFER_SAMPLES  (WebGL 2) GLint R Limits Limit WebGL 2 WebGL 1 GL.MAX_RENDERBUFFER_SIZE Max renderbuffer width/height >=2048 >=1 GL.MAX_SAMPLES Max samples for multisampling >=4 0 Remarks The only way to work with a renderbuffer, besides creating it, is to attach it to a  Framebuffer . A  Renderbuffer  cannot be accessed by a shader in any way. Multisampling is only available in WebGL 2","headings":[{"value":"Renderbuffer","depth":1},{"value":"Usage","depth":2},{"value":"Members","depth":2},{"value":"Methods","depth":2},{"value":"getSamplesForFormat (static method)","depth":3},{"value":"constructor","depth":3},{"value":"initialize","depth":3},{"value":"resize","depth":3},{"value":"Renderbuffer Formats","depth":2},{"value":"Parameters","depth":2},{"value":"Limits","depth":2},{"value":"Remarks","depth":2}],"slug":"modules/webgl/docs/api-reference/renderbuffer","title":"Renderbuffer"},{"excerpt":"Resource Overview The  Resource  class is the base class of all WebGL resource classes (e.g.  Buffer ,  Texture , etc.) Usage Resources must be created through subclasses, e.g. Deleting a resource Getting parameters Methods constructor gl  - WebGL context, which is stored on the object. opts  - options opts.id  (string) - stores a string id, helpful for printing and debugging. opts.handle  - by supplying an existing handle, the object will be created\nas a wrapper for that handle (instead of creating a new handle). This\nallows you to use the luma.gl class methods to interface with WebGL resource\nhandles created using the raw WebGL API or through other WebGL frameworks.\nluma.gl will make an attempt to extract information about the handle to\nenable as much functionality as possible, although some operations may\nnot be possible on imported handles. Also, imported handles can\ntypically not be automatically reinitialized after context loss. delete Deletes any WebGL resources associated with this resources (i.e the underlying WebGLResource handle). getParameter(pname) Gets a given parameter from the resource. Note querying for parameters in WebGL is slow and should be avoided in loops and other performance critical situations. getParameters(parameters) Gets list of parameters from the resource (or all parameters). If the special parameter  keys  is set to true, keys and enumerations will be converted to strings. Note querying for parameters in WebGL is slow and should be avoided in loops and other performance critical situations. Note - querying without parameters returns all parameters. This can be useful during debugging. Properties gl The WebGL context is stored on the object. id Stores a string id, helpful for printing and debugging. userData An empty object to which the application can add keys and values. Note that\nthe resource object. itself is sealed to prevent additional key being added,\nand any keys and values added directly to the underlying WebGL object will\nbe lost during WebGL context loss.","headings":[{"value":"Resource","depth":1},{"value":"Overview","depth":2},{"value":"Usage","depth":2},{"value":"Methods","depth":2},{"value":"constructor","depth":3},{"value":"delete","depth":3},{"value":"getParameter(pname)","depth":3},{"value":"getParameters(parameters)","depth":3},{"value":"Properties","depth":2},{"value":"gl","depth":3},{"value":"id","depth":3},{"value":"userData","depth":3}],"slug":"modules/webgl/docs/api-reference/resource","title":"Resource"},{"excerpt":"Shader The  Shader  class are the base class for  VertexShader  class and  FragmentShader  class Usage Create a pair of shaders Members handle  - holds the underlying  WebGLShader  object Constructor Shader(gl : WebGLRenderingContext, source : String) source  - string containing shader instructions. Remarks Shader sources: A  Program  needs to be constructed with two strings containing source code for vertex and fragment shaders. Default Shaders: luma.gl comes with a set of default shaders that can be used for basic rendering and picking.","headings":[{"value":"Shader","depth":1},{"value":"Usage","depth":2},{"value":"Members","depth":2},{"value":"Constructor","depth":2},{"value":"Shader(gl : WebGLRenderingContext, source : String)","depth":3},{"value":"Remarks","depth":2}],"slug":"modules/webgl/docs/api-reference/shader","title":"Shader"},{"excerpt":"Texture2D 2D textures hold basic \"single image\" textures (although technically they can contain multiple mipmap levels). They hold image memory of a certain format and size, determined at initialization time. They can be read from using shaders and written to by attaching them to frame buffers. Most texture related functionality is implemented by and documented on the  Texture  base class. For additional information, see  OpenGL Wiki . Usage Construct a new texture from an image Construct a texture initialized with a data array Construct an empty 1x1 texture Resize it (this clears the texture). Write a sub image into the texture Accessing elements Methods constructor(gl : WebGLRenderingContext, props : Object | data : any) There is also a short form where the image data (or a promise resolving to the image data) can be the second argument of the constructor: gl  (WebGLRenderingContext) - gl context data =null ( * ) - If not provided (null), a solid color texture will be allocated of the specified size. width = 0  ( Number ) - The width of the texture. height = 0  ( Number ) - The height of the texture. mipmaps = - ( Boolean ) - Generates mipmaps when true. format = GL.RGBA  ( GLenum  ) - internal format that WebGL should use. type = ( enum ) - type of pixel data ( GL.UNSIGNED_BYTE ,  GL.FLOAT  etc). Default is autodeduced from  format . dataFormat = ( GLenum ) - internal format that WebGL should use. Default is autodeduced from  format . parameters = {}  ( object ) - map of texture sampler parameters. pixelStore = {}  ( object ) - map of pixel store parameters (controls how  data  is interpreted when Textures are initialized from memory) Notes: setting  mipmaps  to true when  format  set to  RGB32F  will fail, even though  RGB32F  is supported texture format (with EXT_color_buffer_float), it is not supported as renderable format. Note that since many of the constructor parameters are common to all the  Texture  classes they are detailed in  Texture . Pixel store parameters are specified in  State Management","headings":[{"value":"Texture2D","depth":1},{"value":"Usage","depth":2},{"value":"Methods","depth":2},{"value":"constructor(gl : WebGLRenderingContext, props : Object | data : any)","depth":3}],"slug":"modules/webgl/docs/api-reference/texture-2d","title":"Texture2D"},{"excerpt":"Texture3D (WebGL 2) 3D textures hold basic volumetric textures and can be thought of 3-dimentional arrays with a width, height and depth. They hold image memory of a certain format and size, determined at initialization time. They can be sampled in shaders using the  texture  function with a 3D texture coordinate. Most texture related functionality is implemented by and documented on the  Texture  base class. For additional information, see  OpenGL Wiki . Usage Create a new 3D texture Members handle  - The underlying  WebGLTexture target  - Always  GL.TEXTURE_3D width  - width of texture height  - height of texture depth  - depth of the texture format  - format of texture Methods Texture3D  is a subclass of the  Texture  and  Resource  classes and inherit all methods and members of those classes. Note that  setSubImageData  is not currently supported for 3D textures. Texture3D.isSupported(gl) Returns true if the context supports creation of  Texture3Ds . constructor new Texture3D(gl, {parameters}) ; gl  (WebGLRenderingContext) - gl context data = null  ( * ) - See below. width = 0  ( Number ) - The width of the texture. height = 0  ( Number ) - The height of the texture. depth = 0  ( Number ) - The depth of the texture. mipmaps = true  ( Boolean ) - whether to generate mipmaps format  ( enum , default  GL.RGBA ) - internal format that WebGL should use. type  ( enum , default is autodeduced from format) - type of pixel data (GL.UNSIGNED_BYTE, GL.FLOAT etc). dataFormat  ( enum , default is autodeduced from  format ) - internal format that WebGL should use. parameters = {}  (object) - texture Limits The maximum size of a  Texture3D  (width/height/depth) is implementation defined, it can be queried via  GL.MAX_3D_TEXTURE_SIZE  (at least 256).","headings":[{"value":"Texture3D (WebGL 2)","depth":1},{"value":"Usage","depth":2},{"value":"Members","depth":2},{"value":"Methods","depth":2},{"value":"Texture3D.isSupported(gl)","depth":3},{"value":"constructor","depth":3},{"value":"Limits","depth":2}],"slug":"modules/webgl/docs/api-reference/texture-3d","title":"Texture3D (WebGL 2)"},{"excerpt":"TextureCube A texture cube holds six textures that represent faces of the cube. A main feature of  TextureCube s are that they can be passed to shaders and sampled with a direction vector (looking out from the center of the cube) rather than a normal set of texture coordinates, see Usage below. TextureCube s are typically used to store environment maps. As an example, by rendering an environment into a texture cube, reflections in objects can then be rendered efficiently. Most texture related functionality is implemented by and documented on the  Texture  base class. For additional information, see  OpenGL Wiki . Usage Creating a  TextureCube Creating a  TextureCube  using multiple level-of-detail (LODs) images. This class supports  Async Textures . You can provide promises (that resolve to images) instead of images.\nFor example  [GL.TEXTURE_CUBE_MAP_POSITIVE_X]: [promisePosX_LOD_0, promisePosX_LOD_1, promisePosX_LOD_2] . Replacing one or more faces texture data Passing a  TextureCube  to a draw call... ...and accessing it in the shader Members handle  - the underlying  WebGLTexture target  - Always  GL.TEXTURE_CUBE depth  - Always  6 width  - width of the face textures height  - height of the face textures format  - format Methods TextureCube constructor faceSpecification  can be: A single image. A single promise resolving in an image. An array of images (for multiple  levels of detail ). An array of promises each resolving in an image (for multiple  levels of detail ). For every level of detail: Needs to supply 6 images all of same size and format. Images all need to be of the same square size, i.e.  width  and  height  must be the same. The same  format ,  type  etc parameters will be applied to each cube face. Limits GL.MAX_CUBE_MAP_TEXTURE_SIZE","headings":[{"value":"TextureCube","depth":1},{"value":"Usage","depth":1},{"value":"Members","depth":2},{"value":"Methods","depth":2},{"value":"TextureCube constructor","depth":3},{"value":"Limits","depth":2}],"slug":"modules/webgl/docs/api-reference/texture-cube","title":"TextureCube"},{"excerpt":"Texture A  Texture  is a WebGL object that contains one or more images that all have the same image format. Shaders can read from textures (through a sampler uniform) and they can be set up as render targets (by attaching them to a framebuffer). Note: This section describes the  Texture  base class that implements functionality common to all four types of WebGL: Texture2D  - Contains a \"normal\" image texture TextureCube  - Holds 6 textures representing sides of a cube. Texture3D  (WebGL 2) - Holds a \"stack\" of textures which enables 3D interpolation. For more details see  OpenGL Wiki . Note that textures have a lot of optional capabilities made available by extensions, see the Limits section below. Usage For additional usage examples,  Texture  inherits from  Resource . Configuring a Texture Using Textures Members A number of read only accessors are available: width  - width of one face of the cube map height  - height of one face of the cube map format  - internal format of the face textures border  - Always 0. type  - type used to create face textures dataFormat  - data format used to create face textures. offset  - offset used to create face textures. Always 0, unless specified using WebGL 2 buffer constructor. handle  - The underlying WebGL object. id  - An identifying string that is intended to help debugging. Sampler parameters can be accessed using  Texture.getParameter , e.g: texture.getParameter(GL.TEXTURE_MAG_FILTER); Methods constructor(gl : WebGLRenderingContext, props : Object) The texture class cannot be constructed directly. It is a base class that provides common methods the the concrete texture classes. Texture2D , TextureCube  and Texture3D . The constructors for these classes should be used to create textures. They constructors all take common parameters, many of which are specified in this document. Pixel store parameters are described in  State Management . resize(options : Object) : Texture2D Call to resize a texture. If size has changed, reinitializes texture with current format. Note: calling  resize  clears image and mipmaps. width  (GLint) - width to resize to. height  (GLint) - height to resize to. mipmaps  (bool) - turn on/off mipmapping. default  false . generateMipmap() : Texture2D Call to regenerate mipmaps after modifying texture(s) WebGL References  gl.generateMipmap setImageData(options : Object) : Texture2D Allocates storage and sets image data data  ( * ) - Image data. Can be one of several data types see table below pixels  ( * ) - alternative to  data width  (GLint) - height  (GLint) - level  (GLint) - format  (GLenum) - format of image data. type  (GLenum) format of array (autodetect from type) or (WEBGL2) format of buffer offset  (Number) - (WEBGL2) offset from start of buffer border  (GLint) - must be 0. compressed  (Boolean) - parameters  (Object) - GL parameters to be temporarily applied (most of the time, pixelStorage parameters) when updating the texture. Valid image data types: null  - create empty texture of specified format Typed array - initializes from image data in typed array according to  format Buffer | WebGLBuffer  - (WEBGL2) initialized from image data in WebGLBuffer accoeding to  format . HTMLImageElement | Image  - Initializes with content of image. Auto deduces texture width/height from image. HTMLCanvasElement  - Inits with contents of canvas. Auto width/height. HTMLVideoElement  - Creates video texture that continuously updates. Auto width/height. setSubImageData(options : Object) : Texture2D Redefines an area of an existing texture\nNote: does not allocate storage x  ( GLint ) - xOffset from where texture to be updated y  ( GLint ) - yOffset from where texture to be updated width  ( GLint ) - width of the sub image to be updated height  ( GLint ) - height of the sub image to be updated level  ( GLint ) - mip level to be updated format  ( GLenum ) - internal format of image data. typ  ( GLenum ) - format of array (autodetect from type) or (WEBGL2) format of buffer or ArrayBufferView dataFormat  ( GLenum ) - format of image data. offset  ( Number ) - (WEBGL2) offset from start of buffer border  ( GLint ) - must be 0. parameters - temporary settings to be applied, can be used to supply pixel store settings. See also  gl.compressedTexSubImage2D ,  gl.texSubImage2D ,  gl.bindTexture ,  gl.bindBuffer update() Update this texture if  HTMLVideoElement  is used as the data source. This method is automatically called before every draw call if this texture is bound to a uniform. getActiveUnit() Returns number of active textures. bind() Binds itself to given textureUnit. The following WebGL APIs are called in the function\n gl.activeTexture ,  gl.bindTexture unbind() The following WebGL APIs are called in the function\n gl.activeTexture ,  gl.bindTexture Texture Image Data WebGL allows textures to be created from a number of different data sources. Type Description null A texture will be created with the appropriate format, size and width. Bytes will be \"uninitialized\". typed array Bytes will be interpreted according to format/type parameters and pixel store parameters. Buffer  or  WebGLBuffer  ( WebGL 2 ) Bytes will be interpreted according to format/type parameters and pixel store parameters. Image  ( HTMLImageElement ) image will be used to fill the texture. width and height will be deduced. Video  ( HTMLVideoElement ) video will be used to continously update the texture. width and height will be deduced. Canvas  ( HTMLCanvasElement ) canvas will be used to fill the texture. width and height will be deduced. ImageData canvas.getImageData()  - Used to fill the texture. width and height will be deduced. Texture Formats Internal Format If an application wants to store the texture at a certain resolution or in a certain format, it can request the resolution and format with  internalFormat . WebGL will choose an internal representation with least the internal component sizes, and exactly the component types shown for that format, although it may not match exactly. WebGL 2 adds sized internal formats which enables the application to request\nspecific components sizes and types (float and integer formats). While sized formats offer more control, unsized formats do give the GPU freedom to select the most performant internal representation. Unsized Internal Format Components Description GL.RGB 3 sampler reads the red, green and blue components, alpha is 1.0 GL.RGBA 4 Red, green, blue and alpha components are sampled from the color buffer. GL.LUMINANCE 1 Each color contains a single luminance value. When sampled, rgb are all set to this luminance, alpha is 1.0. GL.LUMINANCE_ALPHA 2 Each component is a luminance/alpha double. When sampled, rgb are all set to luminance, alpha from component. GL.ALPHA 1 Discards the red, green and blue components and reads the alpha component. GL.DEPTH_COMPONENT 1 WebGL 2 or  WEBGL_depth_texture GL.DEPTH_STENCIL 2 WebGL 2 or  WEBGL_depth_texture Sized Internal Format Comp. Size Description GL.R8  (WebGL 2) 1 8 bits red component GL.R16F  (WebGL 2) 1 16 bits half float red component GL.R32F  (WebGL 2) 1 32 bits float red component GL.R8UI  (WebGL 2) 1 8 bits unsigned int red component,  usampler , no filtering GL.RG8  (WebGL 2) 1 16 bits red and green components GL.RG16F  (WebGL 2) 2 32 bits red and green components, half float GL.RG32F  (WebGL 2) 2 64 bits red and green components, float GL.RGUI  (WebGL 2) 2 16 bits red and green components,  usampler , no filtering GL.RGB8  (WebGL 2) 3 24 bits red, green and blue components GL.SRGB8  (WebGL 2, EXT_sRGB) 3 24 bits Color values are encoded to/decoded from sRGB before being written to/read from framebuffer GL.RGB565  (WebGL 2) 3 16 bits 5 bit red, 6 bit green, 5 bit blue GL.R11F_G11F_B10F  (WebGL 2) 3 32 bits 11 and 10 bit floating point colors GL.RGB9_E5  (WebGL 2) 3 32 bits 14 bit floating point RGB, shared exponent GL.RGB16F  (WebGL 2) 3 48 bits half float RGB GL.RGB32F  (WebGL 2) 3 96 bits float RBG GL.RGB8UI  (WebGL 2) 3 24 bits unsigned integer 8 bit RGB: use  usampler , no filtering GL.RGBA8  (WebGL 2) 4 32 bits 8 bit RGBA, typically what  GL.RGBA  \"resolves\" to GL.SRGB_APLHA8  (WebGL 2, EXT_sRGB) 4 32 bits Color values are encoded to/decoded from sRGB before being written to/read from framebuffer GL.RGB5_A1  (WebGL 2) 4 16 bits 5 bit RGB, 1 bit alpha GL.RGBA4444  (WebGL 2) 4 16 bits 4 bit RGBA GL.RGBA16F  (WebGL 2) 4 64 bits half float RGBA GL.RGBA32F  (WebGL 2) 4 128 bits float RGA GL.RGBA8UI  (WebGL 2) 4 32 bits unsigned integer 8 bit RGBA,  usampler , no filtering Texture Component Type Describes the layout of each color component in memory. Value WebGL 2 WebGL 1 Description GL.UNSIGNED_BYTE Yes Yes GLbyte 8 bits per channel for  GL.RGBA GL.UNSIGNED_SHORT_5_6_5 Yes Yes 5 red bits, 6 green bits, 5 blue bits GL.UNSIGNED_SHORT_4_4_4_4 Yes Yes 4 red bits, 4 green bits, 4 blue bits, 4 alpha bits GL.UNSIGNED_SHORT_5_5_5_1 Yes Yes 5 red bits, 5 green bits, 5 blue bits, 1 alpha bit GL.BYTE Yes No GL.UNSIGNED_SHORT Yes WEBGL_depth_texture GL.SHORT Yes No GL.UNSIGNED_INT Yes WEBGL_depth_texture GL.INT Yes No GL.HALF_FLOAT Yes OES_texture_half_float GL.FLOAT Yes OES_texture_float GL.UNSIGNED_INT_2_10_10_10_REV Yes No GL.UNSIGNED_INT_10F_11F_11F_REV Yes No GL.UNSIGNED_INT_5_9_9_9_REV Yes No GL.UNSIGNED_INT_24_8 Yes WEBGL_depth_texture GL.FLOAT_32_UNSIGNED_INT_24_8_REV Yes No (pixels must be null) Texture Format Combinations This a simplified table illustrating what combinations of internal formats\nwork with what data formats and types. Note that luma.gl deduces  dataFormat  and  type  from  format  by taking the first value from the data format and data type entries in this table. For more details, see tables in: WebGL 2 spec OpenGL ES spec Internal Format Data Format Data Type GL.RGB GL.RGB GL.UNSIGNED_BYTE   GL.UNSIGNED_SHORT_5_6_5 GL.RGBA GL.RGBA GL.UNSIGNED_BYTE   GL.UNSIGNED_SHORT_4_4_4_4   GL.UNSIGNED_SHORT_5_5_5_1 GL.LUMINANCE_ALPHA GL.LUMINANCE_ALPHA GL.UNSIGNED_BYTE GL.LUMINANCE GL.LUMINANCE GL.UNSIGNED_BYTE GL.ALPHA GL.ALPHA GL.UNSIGNED_BYTE GL.R8 GL.RED GL.UNSIGNED_BYTE GL.R16F GL.RED GL.HALF_FLOAT   GL.FLOAT GL.R32F GL.RED GL.FLOAT GL.R8UI GL.RED_INTEGER GL.UNSIGNED_BYTE GL.RG8 GL.RG GL.UNSIGNED_BYTE GL.RG16F GL.RG GL.HALF_FLOAT   GL.FLOAT GL.RG32F GL.RG GL.FLOAT GL.RG8UI GL.RG_INTEGER GL.UNSIGNED_BYTE GL.RGB8 GL.RGB GL.UNSIGNED_BYTE GL.SRGB8 GL.RGB GL.UNSIGNED_BYTE GL.RGB565 GL.RGB GL.UNSIGNED_BYTE   GL.UNSIGNED_SHORT_5_6_5 GL.R11F_G11F_B10F GL.RGB GL.UNSIGNED_INT_10F_11F_11F_REV   GL.HALF_FLOAT   GL.FLOAT GL.RGB9_E5 GL.RGB GL.HALF_FLOAT   GL.FLOAT GL.RGB16FG GL.RGB GL.HALF_FLOAT   GL.FLOAT GL.RGB32F GL.RGB GL.FLOAT GL.RGB8UI GL.RGB_INTEGER GL.UNSIGNED_BYTE GL.RGBA8 GL.RGBA GL.UNSIGNED_BYTE GL.SRGB8_ALPHA8 GL.RGBA GL.UNSIGNED_BYTE GL.RGB5_A1 GL.RGBA GL.UNSIGNED_BYTE   GL.UNSIGNED_SHORT_5_5_5_1 GL.RGBA4 GL.RGBA GL.UNSIGNED_BYTE   GL.UNSIGNED_SHORT_4_4_4_4 GL.RGBA16F GL.RGBA GL.HALF_FLOAT   GL.FLOAT GL.RGBA32F GL.RGBA GL.FLOAT GL.RGBA8UI GL.RGBA_INTEGER GL.UNSIGNED_BYTE Limits and Capabilities Optional capabilities controlled by extensions Create floating point textures ( GL.NEAREST  sampling only) TEXTURE_FLOAT Create half-floating point textures ( GL.NEAREST  sampling) TEXTURE_HALF_FLOAT Floating point textures are color-renderable and readable COLOR_BUFFER_FLOAT Half float textures are color-renderable and readable COLOR_BUFFER_HALF_FLOAT sRGB format support SRGB depth texture support DEPTH_TEXTURE anisotropic filtering TEXTURE_FILTER_ANISOTROPIC GL.LINEAR_*  sampling of floating point textures TEXTURE_FILTER_LINEAR_FLOAT GL.LINEAR_*  sampling of half-floating point textures TEXTURE_FILTER_LINEAR_HALF_FLOAT NPOT Textures (WebGL 1) Any texture with a  non power of two  dimension (width or height) is referred as  NPOT  texture, under WebGL 1 NPOT textures have following limitations. State Limitation Mipmapping Should be disabled GL.TEXTURE_MIN_FILTER Must be either  GL.LINEAR  or  GL.NEAREST GL.TEXTURE_WRAP_S Must be  GL.CLAMP_TO_EDGE GL.TEXTURE_WRAP_T Must be  GL.CLAMP_TO_EDGE 'Texture' class will perform above settings when NPOT texture resource is created. When un-supported filtering is set using  Texture.setParameters , those will be overwritten with above supported values ( GL.TEXTURE_MIN_FILTER  will be set to  GL.LINEAR ). This only happens for NPOT textures when using WebGL 1, and a warning log will be printed every time a setting is overwritten. Remarks Textures can be supplied as uniforms to shaders that can sample them using texture coordinates and color pixels accordingly. Parameters that affect texture sampling can be set on textures or sampler objects. Textures can be created from a number of different sources, including typed arrays, HTML Images, HTML Canvases, HTML Videos and WebGLBuffers (WebGL 2). The WebGL Context has global \"pixel store\" parameters that control how pixel data is laid out, including Y direction, color space etc. Textures are read from supplied data and written to the specified format/type parameters and pixel store parameters.","headings":[{"value":"Texture","depth":1},{"value":"Usage","depth":2},{"value":"Members","depth":2},{"value":"Methods","depth":2},{"value":"constructor(gl : WebGLRenderingContext, props : Object)","depth":3},{"value":"resize(options : Object) : Texture2D","depth":3},{"value":"generateMipmap() : Texture2D","depth":3},{"value":"setImageData(options : Object) : Texture2D","depth":3},{"value":"setSubImageData(options : Object) : Texture2D","depth":3},{"value":"update()","depth":3},{"value":"getActiveUnit()","depth":3},{"value":"bind()","depth":3},{"value":"unbind()","depth":3},{"value":"Texture Image Data","depth":2},{"value":"Texture Formats","depth":2},{"value":"Internal Format","depth":3},{"value":"Texture Component Type","depth":3},{"value":"Texture Format Combinations","depth":3},{"value":"Limits and Capabilities","depth":2},{"value":"NPOT Textures (WebGL 1)","depth":2},{"value":"Remarks","depth":2}],"slug":"modules/webgl/docs/api-reference/texture","title":"Texture"},{"excerpt":"TransformFeedback (WebGL 2) TransformFeedback  objects holds state needed to perform transform feedback operations. They store the buffer bindings that are being recorded to. This makes it easy to switch between different sets of feedback buffer bindings (somewhat similar to how  VertexArrayObjects  hold input vertex buffers. The state managed by  TransformFeedback  objects includes the buffers the GPU will use to record the requested varyings. When  TransformFeedback  objects must be \"activated\" ( TransformFeedback.begin ) before it can be used. There a number of caveats to be aware of when manually managing  TransformFeedback  object activation, see the remarks. For this reason, luma.gl  Program.draw  call takes an optional  TransformFeedback  object as a parameter and activates and deactivates it before and after the draw call. Finally, note that when using transform feedback it is frequently desirable to turn off rasterization:  gl.enable(GL.RASTERIZER_DISCARD)  to prevent the fragment shader from running. For more information, see  OpenGL Wiki . Usage Setting up a model object for transform feedback. Setting up a transform feedback object and binding buffers When binding the buffers, index should be equal to the corresponding varying entry in  varyings  array passed to  Program  constructor. Buffers can also be bound using varying name if information about varyings are retrieved from  Program  object. Running program (drawing) with implicit activation of transform feedback (will call  begin  and  end  on supplied  transformFeedback ) Running a transform feedback operation while turning off rasterization (drawing): or equivalently, just call draw with an additional parameter: Methods constructor(gl : WebGL2RenderingContext, props: Object) See  TransformFeedback.setProps  for parameters. WebGL APIs  gl.createTransformFeedback initialize(props : Object) : TransformFeedback Reinitializes an existing  TransformFeedback  object with new props. setProps(props : Object) : TransformFeedback props.program = (Object) - Gets a mapping of varying name to buffer indices from a linked program if supplied. props.buffers =(Object) - Map of location index or name to Buffer object or buffer parameters object. If buffer parameters object is supplied, it contains following fields. buffer =(Buffer) - Buffer object to be bound. byteOffset =(Number, default: 0) - Byte offset that is used to start recording the data in the buffer. byteSize =(Number, default: remaining buffer size) - Size in bytes that is used for recording the data. props.bindOnUse = true  - If true, binds and unbinds buffers before and after use, rather than right away when set. Workaround for a possible  Khronos/Chrome bug . Notes: buffers  - will get bound to indices in the  GL.TRANSFORM_FEEDBACK_BUFFER  target. delete() : TransformFeedback Destroys a  TransformFeedback  object. WebGL APIS  gl.deleteTransformFeedback setBuffers(buffers: Object) : TransformFeedback buffers =(Object) - Map of location index or name to Buffer object or buffer parameters object. If buffer parameters object is supplied, it contains following fields. buffer =(Buffer) - Buffer object to be bound. byteOffset =(Number, default: 0) - Byte offset that is used to start recording the data in the buffer. byteSize =(Number, default: remaining buffer size) - Size in bytes that is used for recording the data. Notes: To use  gl.bindBufferRange , either  offsetInByts  or  byteSize  must be specified, when only one is specified, default value is used for the other, when both not specified,  gl.bindBufferBase  is used for binding. WebGL APIs  gl.bindBufferBase ,  gl.bindBufferRange begin(primitiveMode : GLEnum) : TransformFeedback Activates transform feedback using the buffer bindings in this  TransformFeedback  object. primitiveMode  ( GLenum ) - returns ( TransformFeedback ) - returns self to enable chaining Notes: Buffers can not be accessed until  TransformFeedback.end  or  TransformFeedback.pause  have been called. Buffers can not be changed until  TransformFeedback.end  or has been called, which includes doing anything which reads from or writes to any part of these buffers (outside of feedback writes, of course, or reallocating storage for any of these buffers). WebGL APIs  gl.beginTransformFeedback end() : TransformFeedback returns ( TransformFeedback ) - returns self to enable chaining WebGL APIs  gl.endTransformFeedback See also Program  constructor -  varyings  argument to specify which vertex shader outputs to expose to transform feedback operations. Enumerations Primitive Mode Compatible Draw Modes GL.POINTS GL.POINTS GL.LINES GL.LINES ,  GL.LINE_LOOP ,  GL.LINE_STRIP GL.TRIANGLES GL.TRIANGLES ,  GL.TRIANGLE_STRIP ,  GL.TRIANGLE_FAN Limits Limit Value Description GL.MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS >=4 total number of variables that can be captured } GL.MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS >=4 number of components that any particular variable can contain GL.MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS >= 64 total number of components in interleaved capture GL.MAX_TRANSFORM_FEEDBACK_BUFFERS TBD Advanced interleaving total number of buffers Remarks About  TransformFeedback  activation caveats When activated,  TransformFeedback  are coupled to the \"current\"  Program Note that a started and unpaused TransformFeedback prevents the app from changing or re-linking the current program. So for instance,  Program.use  ( gl.useProgram ) cannot be called.","headings":[{"value":"TransformFeedback (WebGL 2)","depth":1},{"value":"Usage","depth":2},{"value":"Methods","depth":2},{"value":"constructor(gl : WebGL2RenderingContext, props: Object)","depth":3},{"value":"initialize(props : Object) : TransformFeedback","depth":3},{"value":"setProps(props : Object) : TransformFeedback","depth":3},{"value":"delete() : TransformFeedback","depth":3},{"value":"setBuffers(buffers: Object) : TransformFeedback","depth":3},{"value":"begin(primitiveMode : GLEnum) : TransformFeedback","depth":3},{"value":"end() : TransformFeedback","depth":3},{"value":"See also","depth":2},{"value":"Enumerations","depth":2},{"value":"Limits","depth":2},{"value":"Remarks","depth":2}],"slug":"modules/webgl/docs/api-reference/transform-feedback","title":"TransformFeedback (WebGL 2)"},{"excerpt":"UniformBufferLayout (WebGL 2) A helper class that lets the application describe the contents of a uniform block and then perform  setUniforms({uniform: value})  calls on it, manipulating individual values without concern for memory layout requirements. Usage Create a  UniformBufferLayout  that matches the uniform block declaration in your shader Setting values on a  UniformBufferLayout : Creating a uniform buffer to hold the data required by the layout Updating your actual uniform buffer Updating a minimal part of the actual uniform buffer Binding your uniform buffer Methods constructor Takes a layout object and creates an internal layout description. Once constructed the layout cannot be changed. Once constructed the size of the required memory buffer is known, and the buffer layout provides a convenient interface for updating values. Note: The order and type of the uniforms in the layout object provided to the constructor must match the order and type of the uniform declarations in the GLSL uniform block setValues Sets uniform values. getBytes Returns the number of bytes needed to hold all the uniforms in the layout, which can be used to create a  Buffer  with enough data to hold the entire memory layout. getData Returns a  Float32Array  representing all the memory in the layout. The length of this array ( *  4) will correspond to the value returned by  getBytes() getSubData Returns a  Float32Array  representing all the memory in the layout. The length of this array ( *  4) will correspond to the value returned by  getBytes() Types Use the following WebGL types to declare uniforms corresponding to your GLSL data types. GLSL Type WebGL type float GL.FLOAT vec2 GL.FLOAT_VEC2 vec3 GL.FLOAT_VEC3 vec4 GL.FLOAT_VEC4 int GL.INT ivec2 GL.INT_VEC2 ivec3 GL.INT_VEC3 ivec4 GL.INT_VEC4 uint GL.UNSIGNED_INT uvec2 GL.UNSIGNED_INT_VEC2 uvec3 GL.UNSIGNED_INT_VEC3 uvec4 GL.UNSIGNED_INT_VEC4 bool GL.BOOL bvec2 GL.BOOL_VEC2 bvec3 GL.BOOL_VEC3 bvec4 GL.BOOL_VEC4 mat2 GL.FLOAT_MAT2 mat3 GL.FLOAT_MAT3 mat4 GL.FLOAT_MAT4 mat2x3 GL.FLOAT_MAT2x3 mat2x4 GL.FLOAT_MAT2x4 mat3x2 GL.FLOAT_MAT3x2 mat3x4 GL.FLOAT_MAT3x4 mat4x2 GL.FLOAT_MAT4x2 mat4x3 GL.FLOAT_MAT4x3 Remarks WebGL requires the data representing the uniforms in to be laid out in memory according to specific rules (essentially some padding needs to be injected between successive values to facilitate memory access by the GPU). Note that WebGL 2 uniform buffers are just  Buffer  objects and can be manipulated directly. The  UniformBufferLayout  class is not a WebGL 2 object, it is just an optional helper class that makes it easy to create and update a block of memory with the required layout. More information on the  std140  layout specification:  OpenGL spec","headings":[{"value":"UniformBufferLayout (WebGL 2)","depth":1},{"value":"Usage","depth":2},{"value":"Methods","depth":2},{"value":"constructor","depth":3},{"value":"setValues","depth":3},{"value":"getBytes","depth":3},{"value":"getData","depth":3},{"value":"getSubData","depth":3},{"value":"Types","depth":2},{"value":"Remarks","depth":2}],"slug":"modules/webgl/docs/api-reference/uniform-buffer-layout","title":"UniformBufferLayout (WebGL 2)"},{"excerpt":"VertexArrayObject The WebGL  VertexArrayObject  object holds a map of \"buffers\" that will be made available as input data to shaders during a draw call, similar to how a  TransformFeedback  object holds a set of  Buffer  instances that will receive output data from shaders.For  Buffer  objects, the  VertexArrayObject  also stores some additional information about how that data in the buffer should be accessed, such as offsets, strides, etc. However, the use of  VertexArrayObject  is problematic in WebGL 1. While it is crucial for the operation of a program, its presence under WebGL 1 is dependent on an  extension  that is fairly common, but not universally available. In particular it is not available in headless gl which is essential for running tests under Node.js. Therefore, in basic WebGL environments where the  VertexArrayObject  is not supported, luma.gl ensures that one (\"fake\") instance of the  VertexArrayObject  class can still be obtained, emulating the default ( null  handle)  VertexArrayObject . This instance has the  isDefaultArray  flag set, and applications can adapt their behavior accordingly, while still using the same API to manage vertex attributes, albeit with a small performance loss. Since there is a considerable amount of work required to handle both cases, luma.gl also provides a higher level  VertexArray  class that works around these issues and provided additional conveniences. It is usually not necessary to create neither  VertexArrayObject  nor  VertexArray  instances in luma.gl applications. It is often simpler to just provides attributes directly to the  Model  class. Still, it can be useful to review this documentation to understand how attributes are handled by WebGL. For more information on WebGL  VertexArrayObject s, see the  OpenGL Wiki . Usage Import the  VertexArrayObject  class so that your app can use it: Getting the global  VertexArrayObject  for a WebGL context Create a new VertexArray Adding attributes to a VertexArray Deleting a VertexArray Setting a constant vertex attribute Methods VertexArrayObject  inherits from  Resource . VertexArray(gl : WebGLRenderingContext, props : Object) Creates a new VertexArray props  (Object) - passed through to  Resource  superclass constructor and to  initialize VertexArray.getDefaultArray() : VertexArray Returns the \"global\"  VertexArrayObject . Note: The global  VertexArrayObject  object is always available. Binds the  null  VertexArrayObject. initialize(props : Object) : VertexArray Reinitializes a  VertexArrayObject . attributes = {}  ( Object ) - map of attributes, can be keyed by index or names, can be constants (small arrays),  Buffer , arrays or typed arrays of numbers, or attribute descriptors. elements = null  ( Buffer ) - optional buffer representing elements array (i.e. indices) program  - Transfers information on vertex attribute locations and types to this vertex array. setConstant(values : Array) : VertexArray Sets a constant value for a vertex attribute. When this  VertexArrayObject  is used in a  Program.draw()  call, all Vertex Shader invocations will get the same value. VertexArray.setConstant(location, array); gl  ( WebGLRenderingContext ) - gl context location  ( GLuint ) - index of the attribute WebGL APIs:\n vertexAttrib4[u]{f,i}v setBuffer(nameOrLocation, buffer : Buffer  , accessor : Object ) : VertexArray Binds the specified attribute in this vertex array to the supplied buffer Set a location in vertex attributes array to a buffer, specifying its data layout and integer to float conversion and normalization flags setBuffer(location, buffer); \n setBuffer(location, buffer, {offset = 0, stride = 0, normalized = false, integer = false}); location  ( GLuint  |  String ) - index/ordinal number of the attribute buffer  ( WebGLBuffer | Buffer ) - WebGL buffer to set as value gl.vertexAttrib{I}Pointer ,  gl.vertexAttribDivisor getParameter(pname, location) :  * Queries a vertex attribute location. pname  (GLenum) - Which parameter to query. See table of parameter constants below for values. location  ( Number ) - index of attributes Note that in WebGL queries are generally slow and should be avoided in performance critical code sections. Types, Constants, Enumarations getParameter Constants Parameter Type Value GL.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING WebGLBuffer  (not  Buffer ) Get currently bound buffer GL.VERTEX_ATTRIB_ARRAY_ENABLED GLboolean true if the vertex attribute at this index is enabled GL.VERTEX_ATTRIB_ARRAY_SIZE GLint indicating the size of an element of the vertex array. GL.VERTEX_ATTRIB_ARRAY_STRIDE GLint indicating the number of bytes between successive elements in the array. 0 means that the elements are sequential. GL.VERTEX_ATTRIB_ARRAY_TYPE GLenum The array type. One of GL.BYTE ,  GL.UNSIGNED_BYTE ,  GL.SHORT ,  GL.UNSIGNED_SHORT ,  GL.FIXED ,  GL.FLOAT . GL.VERTEX_ATTRIB_ARRAY_NORMALIZED GLboolean true if fixed-point data types are normalized for the vertex attribute array at the given index. GL.CURRENT_VERTEX_ATTRIB Float32Array(4) The current value of the vertex attribute at the given index. When using a WebGL 2 context, the following values are available additionally:\n|  GL.VERTEX_ATTRIB_ARRAY_INTEGER  |  GLboolean  | true if an integer data type is in the vertex attribute array at the given index. |\n|  GL.VERTEX_ATTRIB_ARRAY_DIVISOR  |  GLint  | The frequency divisor used for instanced rendering. | Attribute Accessors When setting  Buffer  attributes, additional data can be provided to specify how the buffer should be accessed. This data can be stored directly on the  Buffer  accessor or supplied to  .setBuffer . target = buffer.target  ( GLuint , ) - which target to bind to size  ( GLuint ) - number of values (components) per element (1-4) type  ( GLuint ) - type of values (e.g. gl.FLOAT) normalized  ( boolean , false) - normalize integers to  -1,1  or  0,1 integer  ( boolean , false) -  WebGL 2  disable int-to-float conversion stride  ( GLuint , 0) - supports strided arrays offset  ( GLuint , 0) - supports strided arrays layout.normalized = false  (GLbool) - normalize integers to  -1,1 ,  0,1 layout.integer = false  (GLuint) - WebGL 2 only, disable int-to-float conv. divisor  - Sets the frequency divisor used for instanced rendering (instances that pass between updates of attribute). Usually simply set to 1 or 0 to enable/disable instanced rendering. 0 disables instancing, >=1 enables it. Notes: The application can enable normalization by setting the  normalized  flag to  true  in the  setBuffer  call. WebGL 2  The application can disable integer to float conversion when running under WebGL 2, by setting the  integer  flag to  true . glVertexAttribIPointer  specifies  integer  data formats and locations of vertex attributes. Values are always left as integer values. Only accepts the integer types gl.BYTE, gl.UNSIGNED_BYTE, gl.SHORT, gl.UNSIGNED_SHORT, gl.INT, gl.UNSIGNED_INT Notes about Instanced Rendering About setting  divisor  in attributes: Instanced attributes requires WebGL 2 or a (widely supported) WebGL 1 extension. Apps can use the luma.gl feature detection system to determine if instanced rendering is available, though the extension is so ubiquitously supported that many apps just make the assumption:  instanced_arrays . An attribute is referred to as  instanced  if its divisor value is non-zero. The divisor modifies the rate at which vertex attributes advance when rendering multiple instances of primitives in a single draw call. If divisor is zero, the attribute at slot index advances once per vertex. If divisor is non-zero, the attribute advances once per divisor instances of the set(s) of vertices being rendered.","headings":[{"value":"VertexArrayObject","depth":1},{"value":"Usage","depth":2},{"value":"Methods","depth":2},{"value":"VertexArray(gl : WebGLRenderingContext, props : Object)","depth":3},{"value":"VertexArray.getDefaultArray() : VertexArray","depth":3},{"value":"initialize(props : Object) : VertexArray","depth":3},{"value":"setConstant(values : Array) : VertexArray","depth":3},{"value":"setBuffer(nameOrLocation, buffer : Buffer , accessor : Object) : VertexArray","depth":3},{"value":"getParameter(pname, location) : *","depth":3},{"value":"Types, Constants, Enumarations","depth":2},{"value":"getParameter Constants","depth":3},{"value":"Attribute Accessors","depth":2}],"slug":"modules/webgl/docs/api-reference/vertex-array-object","title":"VertexArrayObject"},{"excerpt":"VertexArray The  VertexArray  class (like its lower level counterpart, the  VertexArrayObject ) manages an \"array\" of values (\"buffers\") that will be made available as input data to shaders during a draw call. For each WebGL  Buffer , the  VertexArray  also stores some additional information about how that data in the buffer should be accessed, such as offsets, strides, etc, and whether the attribute is instanced. The  VertexArray  class provides the following features on top of the lower level  VertexArrayObject  class: Reads a \"program configuration\", enabling attributes to be set using names instead of locations Avoids duplicating information already specified in shaders, such as size and type of attributes. Automatic deduction of draw parameters from currently set attributes Handles the \"constant attribute 0\" complication that is common on desktop WebGL browsers. Can generated debug output of attribute bank Can fall back to sharing single  VertexArrayObject  across all  VertexArray  objects. The  VertexArray  is a wrapper class around the  VertexArrayObject  class which encapsulates the underlying WebGL object. The  VertexArrayObject  class has a number of complications that the  VertexArray  takes care of. It is usually not necessary to create  VertexArray  instances in luma.gl applications. The application can just supply a map of  attributes  to the  Model  class, and rely on that class to automatically manage the vertex attributes array and supply it to any draw calls (e.g. when rendering, picking etc). Still, it can be useful to review this documentation to better understand how attributes are handled. For more information on the WebGL  VertexArrayObject , see the  OpenGL Wiki . Usage Import the  VertexArray  class so that your app can use it: Create a new VertexArray Deleting a VertexArray Adding attributes to a VertexArray: without program metadata, buffers must be specified using location indices Adding attributes to a VertexArray: adding a program configuration enables setting attributes by name Constructor VertexArray(gl : WebGLRenderingContext, props : Object) Creates a new VertexArray props  (Object) - passed through to  Resource  superclass constructor and to  initialize  it. Methods initialize(props : Object) : VertexArray Reinitializes a  VertexArray . attributes = {}  ( Object ) - map of attributes, can be keyed by index or names, can be constants (small arrays),  Buffer , arrays or typed arrays of numbers, or attribute descriptors. elements = null  ( Buffer ) - optional buffer representing elements array (i.e. indices) program  - Transfers information on vertex attribute locations and types to this vertex array. setAttributes(attributes : Object) : VertexArray Sets named uniforms from a map. attributes  - ( object ) An object with key value pairs matching a buffer name and its value respectively. Attributes is an object with key-value pairs:  {nameOrLocation: value, ....} . nameOrLocation  - ( string|number ) The name of the attribute as declared in the shader, or the location specified by a layout qualifier in the shader. The name can contain an offset to the actual location in the format of  name__LOCATION_0 . This is useful for setting  mat  type attributes. See the section at the bottom for more details. value  - ( Buffer|Array|typed array ) An attribute value must be a  Buffer  or a typed array. Each value can be an a  Buffer , an  Array  starting with a  Buffer  or a typed array. Typed Array - Sets a constant value as if  .setConstant(value)  was called. Buffer  - Binds the atttribute to a buffer, using buffer's accessor data as if  .setBuffer(value)  was called. Array  - Binds the atttribute to a buffer, with extra accessor data overrides. Expects a two element array with  [buffer : Buffer, accessor : Object] . Binds the attribute to the buffer as if  .setBuffer(buffer, accessor)  was called. setConstant(value : Array  , accessor : Object ) : VertexArray Sets a constant value for a vertex attribute. When this  VertexArray  is used in a  Program.draw()  call, all Vertex Shader invocations will get the same value. VertexArray.setConstant(location, array); gl  ( WebGLRenderingContext ) - gl context location  ( GLuint ) - index of the attribute WebGL APIs:\n vertexAttrib4[u]{f,i}v setBuffer(nameOrLocation, buffer : Buffer  , accessor : Object ) : VertexArray Binds the specified attribute in this vertex array to the supplied buffer Set a location in vertex attributes array to a buffer, specifying its data layout and integer to float conversion and normalization flags setBuffer(location, buffer); \n setBuffer(location, buffer, {offset = 0, stride = 0, normalized = false, integer = false}); location  ( GLuint  |  String ) - index/ordinal number of the attribute buffer  ( WebGLBuffer | Buffer ) - WebGL buffer to set as value gl.vertexAttrib{I}Pointer ,  gl.vertexAttribDivisor setElementBuffer(buffer : Buffer  , accessor : Object ) : VertexArray Binds the supplied buffer as index buffer ( GL.ELEMENT_ARRAY_BUFFER ). Attribute Accessors When setting  Buffer  attributes, additional data can be provided to specify how the buffer should be accessed. This data can be stored directly on the  Buffer  accessor or supplied to  .setBuffer . target = buffer.target  ( GLuint , ) - which target to bind to size  ( GLuint ) - number of values (components) per element (1-4) type  ( GLuint ) - type of values (e.g. gl.FLOAT) normalized  ( boolean , false) - normalize integers to  -1,1  or  0,1 integer  ( boolean , false) -  WebGL 2  disable int-to-float conversion stride  ( GLuint , 0) - supports strided arrays offset  ( GLuint , 0) - supports strided arrays layout.normalized = false  (GLbool) - normalize integers to  -1,1 ,  0,1 layout.integer = false  (GLuint) - WebGL 2 only, disable int-to-float conv. divisor  - Sets the frequency divisor used for instanced rendering (instances that pass between updates of attribute). Usually simply set to 1 or 0 to enable/disable instanced rendering. 0 disables instancing, >=1 enables it. Notes about Integer Attributes The application can enable normalization by setting the  normalized  flag to  true  in the  setBuffer  call. WebGL 2  The application can disable integer to float conversion when running under WebGL 2, by setting the  integer  flag to  true . glVertexAttribIPointer  specifies  integer  data formats and locations of vertex attributes. Values are always left as integer values. Only accepts the integer types gl.BYTE, gl.UNSIGNED_BYTE, gl.SHORT, gl.UNSIGNED_SHORT, gl.INT, gl.UNSIGNED_INT Notes about Instanced Rendering About setting  divisor  in attributes: Instanced attributes requires WebGL 2 or a (widely supported) WebGL 1 extension. Apps can use the luma.gl feature detection system to determine if instanced rendering is available, though the extension is so ubiquitously supported that many apps just make the assumption:  instanced_arrays . An attribute is referred to as  instanced  if its divisor value is non-zero. The divisor modifies the rate at which vertex attributes advance when rendering multiple instances of primitives in a single draw call. If divisor is zero, the attribute at slot index advances once per vertex. If divisor is non-zero, the attribute advances once per divisor instances of the set(s) of vertices being rendered. Notes about setting  mat  type attributes Setting a  mat  type in the shader requires to manually add an  offset  to the location. This can be done by using special name format  name__LOCATION_0 . This will add 0 to the  LOCATION  resulting in no change.  name__LOCATION_1  will add  1 . For example: if we have the following declaration in the shader: We should specify  matrix__LOCATION_0 ,  matrix__LOCATION_1 ,  matrix__LOCATION_2   and   matrix__LOCATION_3  as  vec4 .","headings":[{"value":"VertexArray","depth":1},{"value":"Usage","depth":2},{"value":"Constructor","depth":2},{"value":"VertexArray(gl : WebGLRenderingContext, props : Object)","depth":3},{"value":"Methods","depth":2},{"value":"initialize(props : Object) : VertexArray","depth":3},{"value":"setAttributes(attributes : Object) : VertexArray","depth":3},{"value":"setConstant(value : Array , accessor : Object) : VertexArray","depth":3},{"value":"setBuffer(nameOrLocation, buffer : Buffer , accessor : Object) : VertexArray","depth":3},{"value":"setElementBuffer(buffer : Buffer , accessor : Object) : VertexArray","depth":3},{"value":"Attribute Accessors","depth":2},{"value":"Notes about Integer Attributes","depth":2},{"value":"Notes about Instanced Rendering","depth":2},{"value":"Notes about setting mat type attributes","depth":2}],"slug":"modules/webgl/docs/api-reference/vertex-array","title":"VertexArray"},{"excerpt":"KeyFrames Manages key frame animation data. Associates time points with arbitrary data and provides methods to access key times and data, and an interpolation factor, based on the current time. Usage Properties startIndex  (Number): Current start key frame index (i.e. the index of the key frame being interpolated from). endIndex  (Number): Current end key frame index (i.e. the index of the key frame being interpolated to). factor  (Number): A value between 0 and 1 representing the interpolation factor between the start and end key frame pair. Methods constructor(keyFrameData: Array) Takes an array of  [time, data]  pairs to initialize the key frames. setKeyFrames(keyFrameData: Array) Replaces the current set of key frames with a new one. Takes the same argument as the constructor. getStartTime() : Number Returns the time at the current start key frame index. getEndTime() : Number Returns the time at the current end key frame index. getStartData() : Any Returns the data at the current start key frame index (i.e. the data being interpolated from). getEndData() : Any Returns the data at the current end key frame index (i.e. the data being interpolated to). setTime(time: Number) Set the current time of the key frames.","headings":[{"value":"KeyFrames","depth":1},{"value":"Usage","depth":2},{"value":"Properties","depth":2},{"value":"Methods","depth":2},{"value":"constructor(keyFrameData: Array)","depth":3},{"value":"setKeyFrames(keyFrameData: Array)","depth":3},{"value":"getStartTime() : Number","depth":3},{"value":"getEndTime() : Number","depth":3},{"value":"getStartData() : Any","depth":3},{"value":"getEndData() : Any","depth":3},{"value":"setTime(time: Number)","depth":3}],"slug":"modules/engine/docs/api-reference/animation/key-frames","title":"KeyFrames"},{"excerpt":"Timeline Manages an animation timeline, with multiple channels that can be running at different rates, durations, etc. Many methods ( play ,  pause ) assume that the  update  method is being called once per frame with a \"global time\". This automatically done for  AnimationLoop.timeline  object. Parallel Times The key concept at work in the  Timeline  is running multiple time frames in parallel: Global Time: The \"system time\" as determined by the application. Used by  Timeline  to determine the rate at which to play. Timeline Time: The \"parent\" time of all channels on the timeline. Can be played at the same rate as \"Global Time\" or manipulated manually. Channel Time: Will update in lock step with \"Timeline Time\", but may move at different rates, loop, etc. depending on channel parameters. Usage Automatic update usage (assume  update  method is being called once per frame): Manual usage: Methods addChannel( props: Object ) : Number Add a new channel to the timeline. Returns a handle to the channel that can be use for subsequent interactions. Valid propeties are: rate  the speed of the channel's time relative to timeline time. delay  offset into timeline time at which channel time starts elapsing, in timeline time units. duration  the length of the channel time frame, in timeline time units. repeat  how many time to repeat channel time's timeline. Only meaningful if  duration  is finite. removeChannel(handle : Number) Remove a channel from the timeline.  handle  should be a value that was returned by  addChannel . isFinished(handle : Number) : Boolean Returns whether the channel's time has completely elapsed. getTime( handle : Number ) : Number Return the current time of the channel indicated by  handle . If no handle is provided, return timeline time. setTime(time : Number) Set the timeline time to the given value. play Allow timeline time to be updated by calls to  update . pause Prevent timeline time from being updated by calls to  update . reset Reset timeline time to  0 . attachAnimation(animation: Object,  channelHandle : Number ) : Number Attach an animation object (can be any object with a  setTime  method, e.g.  KeyFrames ,  GLTFAnimator ) to the timeline, optionally attached to a specific channel referenced by  channelHandle .\nThe animation object's time will be updated whenever the timeline updates. Returns a handle that can be used to reference the animation attachement. detachAnimation(handle : Number) Detach an animation object from the timeline.  handle  should be a value that was returned by  attachAnimation . update(globalTime : Number) Expected to be called once per frame, with whatever is considered the \"system time\". Required for  play  and  pause  to work properly.","headings":[{"value":"Timeline","depth":1},{"value":"Parallel Times","depth":2},{"value":"Usage","depth":2},{"value":"Methods","depth":2},{"value":"addChannel(props: Object) : Number","depth":3},{"value":"removeChannel(handle : Number)","depth":3},{"value":"isFinished(handle : Number) : Boolean","depth":3},{"value":"getTime(handle : Number) : Number","depth":3},{"value":"setTime(time : Number)","depth":3},{"value":"play","depth":3},{"value":"pause","depth":3},{"value":"reset","depth":3},{"value":"attachAnimation(animation: Object, channelHandle : Number) : Number","depth":3},{"value":"detachAnimation(handle : Number)","depth":3},{"value":"update(globalTime : Number)","depth":3}],"slug":"modules/engine/docs/api-reference/animation/timeline","title":"Timeline"},{"excerpt":"BufferTransform BufferTransform  is an internal helper class for  Transform , responsible for managing resources and state required for reading from and/or writing to  Buffer  objects. It auto creates  feedbackBufferes  when requested, creates  TransformFeedback  objects. Maintains all buffer bindings, when swapping is eanbled, two binding objects are created for easy switching of all WebGL resource binginds. NOTE: In following sections 'buffer transform' is used to refer to 'reading from and/or writing to  Buffer  objects'. Constructor Transform(gl : WebGL2RenderingContext, props: Object) gl  ( WebGLRenderingContext ) gl - context props  ( Object , Optional) - contains following data. sourceBuffers  ( Object , Optional) - key and value pairs, where key is the name of vertex shader attribute and value is the corresponding  Attribute ,  Buffer  or attribute descriptor object. feedbackBuffers  ( Object , Optional) - key and value pairs, where key is the name of vertex shader varying and value is the corresponding  Buffer  object or buffer params object. If a buffer params object is specified, it will contain following fields, these can be used to capture data into the buffer at particular offset and size. buffer =(Buffer) - Buffer object to be bound. byteOffset =(Number, default: 0) - Byte offset that is used to start recording the data in the buffer. byteSize =(Number, default: remaining buffer size) - Size in bytes that is used for recording the data. varyings  ( Array , Optional) - Array of vertex shader varyings names. When not provided this can be deduced from  feedbackBuffers . NOTE: If only reading from  Buffer  objects, above optional props doesn't have to be supplied during construction, but can be supplied using  update  method. If writing to  Buffer  objects, either  varyings  or  feedbackBuffers  must be supplied. Methods (Model props) getDrawOptions(opts: Object) : Object Returns resources required when performing  Model.draw()  options. opts  ( Object ) - Any existing  opts.attributes  will be merged with new attributes. Returns an Object : {attributes, transformFeedback}. updateModelProps(props: Object) : Object Updates input  props  object with data required for buffer transform. opts  ( Object ) - If writing to  Buffer  objects,  opts.varying  will be updated. Returns updated object. Methods (Resource management) setupResources(opts: Object) Sets up internal resources needed writing to buffers. opts  ( Object ) - contains following data. model  ( Model , Optional) -  Model  object that is used to perform draw operations. swap() If  feedbackMap  is provided during construction, performs source and feedback buffers swap as per the  feedbackMap . update(props: Object) Updates buffer bindings for one or more source or feedback buffers. props  ( Object ) - contains following data. sourceBuffers  ( Object , Optional) - key and value pairs, where key is the name of vertex shader attribute and value is the corresponding  Attribute ,  Buffer  or attribute descriptor object. feedbackBuffers  ( Object , Optional) - key and value pairs, where key is the name of vertex shader varying and value is the corresponding  Buffer  object or buffer params object. If a buffer params object is specified, it will contain following fields, these can be used to capture data into the buffer at particular offset and size. buffer =(Buffer) - Buffer object to be bound. byteOffset =(Number, default: 0) - Byte offset that is used to start recording the data in the buffer. byteSize =(Number, default: remaining buffer size) - Size in bytes that is used for recording the data. Methods (Accessors) getBuffer(varyingName : String) : Buffer Returns current feedback buffer corresponding to given varying name. varyingName  ( String ) - varying name. getData( options : Object ) : ArrayBufferView Reads and returns data from current feedback buffer corresponding to the given varying name. options.varyingName  ( String , Optional) - when specified, first checks if there is a corresponding feedback buffer, if so reads data from this buffer and returns. When not specified, there must be target texture and data is read from this texture and returned.","headings":[{"value":"BufferTransform","depth":1},{"value":"Constructor","depth":2},{"value":"Transform(gl : WebGL2RenderingContext, props: Object)","depth":3},{"value":"Methods (Model props)","depth":2},{"value":"getDrawOptions(opts: Object) : Object","depth":3},{"value":"updateModelProps(props: Object) : Object","depth":3},{"value":"Methods (Resource management)","depth":2},{"value":"setupResources(opts: Object)","depth":3},{"value":"swap()","depth":3},{"value":"update(props: Object)","depth":3},{"value":"Methods (Accessors)","depth":2},{"value":"getBuffer(varyingName : String) : Buffer","depth":3},{"value":"getData(options : Object) : ArrayBufferView","depth":3}],"slug":"modules/engine/docs/api-reference/transform/buffer-transform","title":"BufferTransform"},{"excerpt":"TextureTransform TextureTransform  is an internal helper class for  Transform , responsible for managing resources and state required for reading from and/or writing to  Texture  objects. It auto creates  Texture  objects when requested, creates  Framebuffer  objects. Maintains all texture bindings, when swapping is eanbled, two binding objects are created for easy switching of all WebGL resource binginds. NOTE: In following sections 'texture transform' is used to refer to 'reading from and/or writing to  Texture  objects'. Constructor Transform(gl : WebGL2RenderingContext, props: Object) gl  ( WebGLRenderingContext ) gl - context props  ( Object , Optional) - contains following data. sourceTextures  ( Object , Optional) - key and value pairs, where key is the name of vertex shader attribute and value is the corresponding  Texture  object. targetTexture  ( Texture | String , Optional) -  Texture  object to which data to be written. When it is a  String , it must be one of the source texture attributes name, a new texture object is cloned from it. targetTextureVarying  ( String ) : varying name used in vertex shader who's data should go into target texture. swapTexture  ( String ) : source texture attribute name, that is swapped with target texture every time  swap()  is called. fs  ( String , Optional) - fragment shader string, when rendering to a texture, fragments can be processed using this custom shader, when not specified, pass through fragment shader will be used. Methods (Model props) getDrawOptions(opts: Object) : Object Returns options required when performing  Model.draw()  options. opts  ( Object ) - Any existing  opts.attributes  ,  opts.parameters , and  opts.uniforms  will be merged with new values. Returns an Object : {attributes, framebuffer, uniforms, discard, parameters}. updateModelProps(props: Object) : Object Updates input  props  object used to build  Model  object, with data required for texture transform. props  ( Object ) - props for building  Model  object, it will updated with required options ( {vs, fs, modules, uniforms, inject} ) for texture transform. Returns updated object. Methods (Resource management) swap() If  swapTexture  is provided during construction, performs source and feedback buffers swap as per the  swapTexture  mapping. update(props: Object) Updates bindings for source and target texture. props  ( Object ) - contains following data. sourceTextures  ( Object , Optional) - key and value pairs, where key is the name of vertex shader attribute and value is the corresponding  Texture  object. targetTexture  ( Texture | String , Optional) -  Texture  object to which data to be written. When it is a  String , it must be one of the source texture attributes name, a new texture object is cloned from it. Methods (Accessors) getTargetTexture() : Texture Returns current target texture object. getData( options : Object ) : ArrayBufferView Reads and returns data from current target texture. options.packed  (Boolean, Optional, Default: false) - When true, data is packed to the actual size varyings. When false return array contains 4 values (R, G, B and A) for each element. Un-used element value will be 0 for R, G and B and 1 for A channel. getFramebuffer() : Framebuffer Returns current  Framebuffer  object.","headings":[{"value":"TextureTransform","depth":1},{"value":"Constructor","depth":2},{"value":"Transform(gl : WebGL2RenderingContext, props: Object)","depth":3},{"value":"Methods (Model props)","depth":2},{"value":"getDrawOptions(opts: Object) : Object","depth":3},{"value":"updateModelProps(props: Object) : Object","depth":3},{"value":"Methods (Resource management)","depth":2},{"value":"swap()","depth":3},{"value":"update(props: Object)","depth":3},{"value":"Methods (Accessors)","depth":2},{"value":"getTargetTexture() : Texture","depth":3},{"value":"getData(options : Object) : ArrayBufferView","depth":3},{"value":"getFramebuffer() : Framebuffer","depth":3}],"slug":"modules/engine/docs/api-reference/transform/texture-transform","title":"TextureTransform"},{"excerpt":"GroupNode A  GroupNode  is a subclass of  ScenegraphNode  that holds a list of  ScenegraphNode  children. Since . A  GroupNode  can be a child of another  GroupNode  and thus be used to create hierarchical scene graphs. Usage Add a moon and a box models to the group. Add a moon and a box models to the group. Then remove them. Properties Model  extends the  ScenegraphNode  class and inherits the transformation matrix properties from that class. children : ScenegraphNode[] Methods constructor(props : Object) Create an instance of  GroupNode . setProps(props : Object) Updates properties. add(node : ScenegraphNode  , ... ) Add one or more  ScenegraphNode  objects to the  GroupNode . group.add(model); A variable argument list of  ScenegraphNode  instances. remove(node: Node) Removes an  ScenegraphNode  object from the GroupNode. model - ( object ) The scene graph node to be removed.","headings":[{"value":"GroupNode","depth":1},{"value":"Usage","depth":2},{"value":"Properties","depth":2},{"value":"children : ScenegraphNode[]","depth":3},{"value":"Methods","depth":2},{"value":"constructor(props : Object)","depth":3},{"value":"setProps(props : Object)","depth":3},{"value":"add(node : ScenegraphNode , ...)","depth":3},{"value":"remove(node: Node)","depth":3}],"slug":"modules/experimental/docs/api-reference/scenegraph/group-node","title":"GroupNode"},{"excerpt":"ModelNode ModelNode  is simply a  ScenegraphNode  that contains a  Model  for drawing. Constructor ModelNode(webglContextOrModel, props: Object) If a WebGL context is passed, a  Model  will be created internally, otherwise the passed  Model  will be used. props  is the same props as  Model , plus  props.managedResources , an array of resources that this model owns. Methods ModelNode  wraps the following  Model  method and simply proxies them to its internal  Model : draw setUniforms setAttributes updateModuleSettings delete  (calls  Model.delete  and also deletes managed resource)","headings":[{"value":"ModelNode","depth":1},{"value":"Constructor","depth":2},{"value":"Methods","depth":2}],"slug":"modules/experimental/docs/api-reference/scenegraph/model-node","title":"ModelNode"},{"excerpt":"ScenegraphNode The  ScenegraphNode  is a base class for objects in the luma.gl scene graph, such as  Model ,  Group  and  Camera . It holds the transformation matrix (i.e. the position, orientation and scale) of the object. Usage ScenegraphNode  is a base class, normally only instantiated via base classes. Properties A Model instance has a number of public properties that can be accessed/modified: position  ( object ) - A  Vector3  indicating the position of the Model. rotation  ( object ) - A  Vector3  indicating the rotation of the Model. scale  ( object ) - A  Vecto3  indicating the scaling of the Model. matrix  ( object ) - A  Matrix4  containing information about position, rotation and scale. This matrix gets updated each time the method  update  is called on a Model instance. Properties matrix ( Number[16] ) The model matrix of this scenegraph node. Methods constructor(props : Object) setProps(props: Object) position  ( Number[3] ) - Sets the position part of the matrix rotation  ( Number[3] ) - Sets the rotation part of the matrix scale  ( Number[3] ) - Sets the scale part of the matrix Note that setting orientation props does not actually update the object's matrix.  update()  must be called. update() - DEPRECATED Update the model matrix. Useful to update changes to the  position ,  rotation  or  scale  properties. Remarks Before luma.gl v7,  ScenegraphNode  was called  Object3D .","headings":[{"value":"ScenegraphNode","depth":1},{"value":"Usage","depth":2},{"value":"Properties","depth":2},{"value":"Properties","depth":2},{"value":"matrix (Number[16])","depth":3},{"value":"Methods","depth":2},{"value":"constructor(props : Object)","depth":3},{"value":"setProps(props: Object)","depth":3},{"value":"update() - DEPRECATED","depth":3},{"value":"Remarks","depth":2}],"slug":"modules/experimental/docs/api-reference/scenegraph/scenegraph-node","title":"ScenegraphNode"},{"excerpt":"Context Properties luma.gl provides several helper functions for testing properties of a WebGL context: getContextLimits : get resource limits for a context getGLContextInfo : get various properties of a gl context (using WebGL enums as keys) getContextInfo : get various properties of a gl context (using strings as keys) Usage There are a few additional capability query functions sprinkled through the luma.gl API. In particular, WebGL 2 specific classes have an  isSupported  method that duplicates some of the queryies that can be made using the capability system Functions getContextLimits(gl) Returns an object with limits, each limit is an object with multiple values value  - the value of the limit in the current context webgl1  - the minimum allowed value of the limit for WebGL 1 contexts webgl2  - the minimum allowed value of the limit for WebGL 2 contexts WebGL Limits In addition to capabilities, luma.gl can also query the context for all limits. Limits WebGL 2 WebGL 1 Description GL.ALIASED_LINE_WIDTH_RANGE 1, 1 GL.ALIASED_POINT_SIZE_RANGE 1, 1 GL.MAX_TEXTURE_SIZE 2048 64 GL.MAX_CUBE_MAP_TEXTURE_SIZE 16 GL.MAX_TEXTURE_IMAGE_UNITS 8 GL.MAX_COMBINED_TEXTURE_IMAGE_UNITS 8 GL.MAX_VERTEX_TEXTURE_IMAGE_UNITS 0 GL.MAX_RENDERBUFFER_SIZE 1 GL.MAX_VARYING_VECTORS 8 GL.MAX_VERTEX_ATTRIBS 8 GL.MAX_VERTEX_UNIFORM_VECTORS 128 GL.MAX_FRAGMENT_UNIFORM_VECTORS 16 GL.MAX_VIEWPORT_DIMS 0, 0 GL.MAX_TEXTURE_MAX_ANISOTROPY_EXT 1.0 1.0 'EXT_texture_filter_anisotropic' WebGL 2 Limits WebGL 2 WebGL 1 (mock) Description GL.MAX_3D_TEXTURE_SIZE 256 0 GL.MAX_ARRAY_TEXTURE_LAYERS 256 0 GL.MAX_CLIENT_WAIT_TIMEOUT_WEBGL 0 0 GL.MAX_COLOR_ATTACHMENTS 4 0 GL.MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS 0 0 GL.MAX_COMBINED_UNIFORM_BLOCKS 0 0 GL.MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS 0 0 GL.MAX_DRAW_BUFFERS 4 0 GL.MAX_ELEMENT_INDEX 0 0 GL.MAX_ELEMENTS_INDICES 0 0 GL.MAX_ELEMENTS_VERTICES 0 0 GL.MAX_FRAGMENT_INPUT_COMPONENTS 0 0 GL.MAX_FRAGMENT_UNIFORM_BLOCKS 0 0 GL.MAX_FRAGMENT_UNIFORM_COMPONENTS 0 0 GL.MAX_PROGRAM_TEXEL_OFFSET 0 0 GL.MAX_SAMPLES 0 0 GL.MAX_SERVER_WAIT_TIMEOUT 0 0 GL.MAX_TEXTURE_LOD_BIAS 0 0 GL.MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS 0 0 GL.MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS 0 0 GL.MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS 0 0 GL.MAX_UNIFORM_BLOCK_SIZE 0 0 GL.MAX_UNIFORM_BUFFER_BINDINGS 0 0 GL.MAX_VARYING_COMPONENTS 0 0 GL.MAX_VERTEX_OUTPUT_COMPONENTS 0 0 GL.MAX_VERTEX_UNIFORM_BLOCKS 0 0 GL.MAX_VERTEX_UNIFORM_COMPONENTS 0 0 GL.MIN_PROGRAM_TEXEL_OFFSET 0 0 GL.UNIFORM_BUFFER_OFFSET_ALIGNMENT 0 0 getGLContextInfo(gl) Returns an object with following parameters as keys and corresponding value for each key. parameter 'GL.VENDOR' 'GL.RENDERER' 'GL.UNMASKED_VENDOR_WEBGL' 'GL.UNMASKED_RENDERER_WEBGL' 'GL.VERSION' 'GL.SHADING_LANGUAGE_VERSION' getContextInfo(gl) Returns an object containing following details. vendor: info GL.UNMASKED_VENDOR_WEBGL  || info GL.VENDOR , renderer: info GL.UNMASKED_RENDERER_WEBGL  || info GL.RENDERER , version: info GL.VERSION , shadingLanguageVersion: info GL.SHADING_LANGUAGE_VERSION , info, limits, webgl1MinLimits: gl.luma.webgl1MinLimits, webgl2MinLimits: gl.luma.webgl2MinLimits Remarks WebGL 1 only supports one color buffer format (RBG32F is deprecated) WebGL 2 supports multiple color buffer formats Some extensions will not be enabled until they have been queries. luma always queries on startup to enable, app only needs to query again it wants to test platform. The capability detection system works regardless of whether the app is running in a browser or in headless mode under Node.js. Naturally, given that queries to driver and GPU are typically expensive in WebGL, the capabilities system will cache any queries.","headings":[{"value":"Context Properties","depth":1},{"value":"Usage","depth":2},{"value":"Functions","depth":2},{"value":"getContextLimits(gl)","depth":3},{"value":"WebGL Limits","depth":3},{"value":"getGLContextInfo(gl)","depth":3},{"value":"getContextInfo(gl)","depth":3},{"value":"Remarks","depth":2}],"slug":"modules/webgl/docs/api-reference/context/context-properties","title":"Context Properties"},{"excerpt":"Feature Checking Provides WebGL feature detection. WebGL capabilities can vary quite dramatically between browsers (from minimal WebGL 1 (e.g. headless-gl) to WebGL 1 with dozens of extensions to full WebGL 2, which also has a growing number of extensions). Unfortunately, the raw WebGL API sometimes expose the same functionalities through APIs that are slightly different and not exactly compatible. To simplify detecting and working with conditionally available capabilities (or \"features\") luma.gl provides: A set of functions that enable you to check if the application is currently running on an environment that supports a certain feature (regardless of whether it is supported through e.g. WebGL 2 or a WebGL 1 extension). In addition, luma.gl's WebGL classes transparently use WebGL extensions or WebGL 2 APIs as appropriate, meaning that the amount of conditional logic in application code can be kept to a minimum. Once you have established that a capability exists, luma.gl offers you one unified way to use it. Usage Check if a feature is available (whether as a WebGL 1 or WebGL 2 extension or through WebGL 2) Another example of feature detection There are a few additional capability query functions sprinkled through the luma.gl API. In particular, WebGL 2 specific classes have an  isSupported  method that duplicates some of the queryies that can be made using the capability system Functions hasFeature Allows the app to query whether a capability is supported without being concerned about how it is being provided (WebGL 2, an extension etc) gl  ( WebGLRenderingContext ) - gl context capability ( String ) - capability name (can be a webgl extension name or a luma.gl  FEATURES  constant). hasFeatures Allows the app to query whether a capability is supported without being concerned about how it is being provided (WebGL 2, an extension etc) gl  ( WebGLRenderingContext ) - gl context feature ( String | String[] ) - capability name (can be a webgl extension name or a luma.gl  FEATURES  constant). getFeatures This function returns an object containing all available features. WebGL Feature Detection WebGL 2 Classes with some WebGL 1 support Note that luma has a few WebGL 2 classes that  can  be instantiated under WebGL 1 VertexAttributeObject . Can be instanitated under WebGL 1 if the commonly supported extension is available. Also, luma.gl treats the global vertex array as a \"default\" VertexArrayObject, so that can always be accessed. Query  objects use GPU timing extensions if available. They can always be created but obviously queries will fail if capabilities are not present. UniformBufferLayout  - this class does not create any WebGL resources, it just helps the application access memory in the layout format expected by WebGL 2 uniform buffers. VertexAttributeObject  and  Query  have a static  isSupported()  method that you can call instead of checking for WebGL 2. WebGL 2 Classes that only work in WebGL 2 A list of luma classes that can only be instantiated under WebGL 2: Texture3D  - e.g for volumetric rendering Texture2DArray  - an array of textures, e.g. a texture atlas Sampler  - holds a separate set of texture sampler parameters TransformFeedback  - holds a list of output buffers for shaders to write to. Sync  - Each of these classes has a static  isSupported()  method that you can call instead of checking for WebGL 2. WebGL 2-only Features A partial list of features that are only available in WebGL 2: Non-power-of-2 textures - non-POT textures can have mipmaps in WebGL 2 Sized texture formats - Integer based texture formats and attributes - Multi-Sampled renderbuffers - Guaranteed texture access in vertex shaders - WebGL 1 is not required to support this (although it often does) GLSL 3.00 textureSize  - query  size of texture  from within shaders texelFetch  - access textures by  pixel  coordinates (0-width, 0-height) instead of  texel  coordinates (0-1) inverse  and  transpose  Matrix operations available in GLSL loop restrictions removed Optional Feature Detection The WebGL standard comes with an elaborate \"extension\" system allowing applications to check for the availability of features beyond the base WebGL 1 and WebGL 2 standards. These extensions tend to be rather technical, plus they have to be used differently in WebGL 1 and WebGL 2, so luma provides a simplified feature detection system. Following table lists all the available features, and their support under WebGL 1 and WebGL 2 ,  NO  implies not supported, 'YES' implies supported and  *  implies supported through an extension. Parameters to  hasFeatures : FEATURE WebGL 2 WebGL 1 Description General WebGL Features FEATURES.WEBGL2 YES NO True for WebGL 2 Context FEATURES.INSTANCED_RENDERING YES * Instanced rendering (via instanced vertex attributes)  ANGLE_instanced_arrays FEATURES.VERTEX_ARRAY_OBJECT YES * VertexArrayObjects  can be created  OES_vertex_array_object FEATURES.ELEMENT_INDEX_UINT32 YES * 32 bit indices available for  GL.ELEMENT_ARRAY_BUFFER s  OES_element_index_uint FEATURES.BLEND_MINMAX YES * GL.MIN ,  GL.MAX  blending modes are available:  EXT_blend_minmax FEATURES.TIMER_QUERY * * Query  objects support asynchronous GPU timings  EXT_disjoint_timer_query_webgl2 ,  EXT_disjoint_timer_query Texture s and  Framebuffer s FEATURES.TEXTURE_FLOAT YES * Floating point ( Float32Array ) textures can be created and set as samplers (Note that filtering and rendering need to be queried separately, even in WebGL 2)  OES_texture_float FEATURES.TEXTURE_HALF_FLOAT YES Half float ( Uint16Array ) textures can be created and set as samplers  OES_texture_half_float   WEBGL_color_buffer_float FEATURES.MULTIPLE_RENDER_TARGETS YES * Framebuffer s can have multiple color attachments that fragment shaders can access, see  Framebuffer.drawBuffers   WEBGL_draw_buffers FEATURES.COLOR_ATTACHMENT_RGBA32F * * Floating point  Texture s using the  GL.RGBA32F  format are renderable and readable  EXT_color_buffer_float   WEBGL_color_buffer_float FEATURES.COLOR_ATTACHMENT_FLOAT * NO Floating point  Texture s are renderable and readable, i.e. can be attached to  Framebuffer s and written to from fragment shaders, and read from with  readPixels  etc. Note that the formats include  GL.RGBA32F .  EXT_color_buffer_float FEATURES.COLOR_ATTACHMENT_HALF_FLOAT * NO Half float format  Texture s are renderable and readable EXT_color_buffer_half_float FEATURES.FLOAT_BLEND * * Blending with 32-bit floating point color buffers EXT_float_blend WEBGL_depth_texture FEATURES.TEXTURE_DEPTH_BUFFERS YES * Depth buffers can be stored in  Texture s, e.g. for shadow map calculations TEXTURE_FILTER_LINEAR_FLOAT YES * Linear texture filtering for floating point textures  OES_texture_float_linear FEATURES.TEXTURE_FILTER_LINEAR_HALF_FLOAT Yes * Linear texture filtering for half float textures  OES_texture_half_float_linear FEATURES.TEXTURE_FILTER_ANISOTROPIC * * Anisotropic texture filtering  EXT_texture_filter_anisotropic FEATURES.SRGB YES * sRGB encoded rendering is available  EXT_sRGB extensions * * FEATURES.SHADER_TEXTURE_LOD ES300 * Enables shader control of LOD  EXT_shader_texture_lod FEATURES.FRAGMENT_SHADER_DRAW_BUFFERS ES300 * Fragment shader can draw to multiple render targets  WEBGL_draw_buffers FEATURES.FRAGMENT_SHADER_DEPTH ES300 * Fragment shader can control fragment depth value  EXT_frag_depth FEATURES.FRAGMENT_SHADER_DERIVATIVES ES300 * Derivative functions are available in GLSL  OES_standard_derivatives Remarks WebGL 1 only supports one color buffer format (RBG32F is deprecated) WebGL 2 supports multiple color buffer formats Some extensions will not be enabled until they have been queries. luma always queries on startup to enable, app only needs to query again it wants to test platform. The capability detection system works regardless of whether the app is running in a browser or in headless mode under Node.js. Naturally, given that queries to driver and GPU are typically expensive in WebGL, the capabilities system will cache any queries.","headings":[{"value":"Feature Checking","depth":1},{"value":"Usage","depth":2},{"value":"Functions","depth":2},{"value":"hasFeature","depth":3},{"value":"hasFeatures","depth":3},{"value":"getFeatures","depth":3},{"value":"WebGL Feature Detection","depth":2},{"value":"WebGL 2 Classes with some WebGL 1 support","depth":3},{"value":"WebGL 2 Classes that only work in WebGL 2","depth":3},{"value":"WebGL 2-only Features","depth":3},{"value":"GLSL 3.00","depth":3},{"value":"Optional Feature Detection","depth":3},{"value":"Remarks","depth":2}],"slug":"modules/webgl/docs/api-reference/context/feature-checking","title":"Feature Checking"}]}},"staticQueryHashes":["484347790"]}